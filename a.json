{
	"__v": 0,
	"_id": "588b396851bf2abba7a7f2ef",
	"actions": [
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e5264",
			"id": "add-blog-entry",
			"name": "Add Blog Entry",
			"description": "Creates a new Blog Post",
			"important": true,
			"priority": 4,
			"entity": "blog",
			"beta": true,
			"actionRequest": "function actionRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  if (!params.params || !params.params.blog_id || !params.params.title || !params.params.author || !params.params.body_html) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'required params blog id ,title, author or body_html is missing',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const body = {\n    article: {}\n  }\n\n  Object.keys(params.params)\n    .forEach(key => {\n      const data = params.params[key]\n      if (key === 'image_src') {\n        body.article.image = {\n          src: data\n        }\n      } else if (key === 'tags') {\n        if (data && data.length) {\n          body.article.tags = data\n            .map(tag => tag.value)\n            .toString()\n        }\n      } else {\n        body.article[key] = data\n      }\n    })\n\n  const url = `https://${shopUrl}/admin/blogs/${params.params.blog_id}/articles.json`\n\n  const options = {\n    body,\n    url,\n    method: 'POST',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n  \n  return callback(retObj)\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 201) {\n    retObj.status = 'SUCCESS'\n    retObj.data = {\n      parsedValues: {\n        entry_id: body.article.id\n      }\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"params": [
				{
					"fixedValueSource": [],
					"id": "blog_id",
					"name": "Blog",
					"type": "String",
					"inputType": "select",
					"dynamicValueSourceRequest": "function dynamicValueSourceRequest(params, utils, callback) {\n\n    var blogUrl  = '/admin/blogs.json';\n    var retObj        = {status: \"ERROR\"};\n    var shopUrl;\n    var userapp;\n    var options;\n    var fetchedParams;\n\n  // if appinfo or userapp are not present in params\n    if (!params || !params['appinfo'] || !params['userapp']) {\n        retObj['status'] = \"ERROR\";\n        retObj['error'] = {};\n        retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing\";\n\n    } else {\n        userapp = params['userapp'];\n        // fetch the auth params for given userapp\n        fetchedParams = userapp.fetchAuthParams(params['appinfo']);\n         // fetching the shop url\n        shopUrl =  userapp['params'].find(p => p.id === 'shop');\n\n        options = {\n            method: 'GET',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + blogUrl,\n            json: true,\n        };\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = {\n            options: options\n        };\n    }\n    callback(retObj);\n}",
					"dynamicValueSourceParse": "function dynamicValueSourceParse(params, utils, callback) {\n\n    var retObj      = {status: \"ERROR\"};\n    var blogs;\n    var errors;\n    var errorMessage;\n\n    // if response or body are not present in params\n    if (!params || !params['response'] || !params['body']) {\n        retObj['error']            = {};\n        retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing.\";\n\n    } else {\n\n        let response = params.response\n\n        if (params['response']['statusCode'] == 200) {\n            // Extracting the products array\n            blogs = params['body']['blogs'];\n\n           // if any product returned from \n            if (blogs && blogs instanceof Array && blogs.length) {\n\n                var optionsArray = [];\n                // creating a option for each product\n                blogs.forEach(function(element){\n                    // if title and id exists for the product\n                    if(element['id'] && element['title'])\n                    optionsArray.push({\n                        name: element['title'],\n                        id  : element['id'] \n                    });\n                });\n                retObj['status'] = \"SUCCESS\";\n                retObj['data']   = optionsArray;\n            } else {\n                retObj.status = 'SUCCESS'\n                retObj.data = []\n            }\n        } else {\n            // when error data present, flattening the object\n            errors   =  params['body']['errors']; \n            if(errors){\n                errorMessage = '';\n                if(typeof errors == 'string')\n                    errorMessage  = errors;\n                else {\n                    Object.keys(errors).forEach(function(key){\n                        errorMessage += key + ': ';\n                        if(errors[key] && errors[key] instanceof Array)\n                            errorMessage += errors[key].join(',');\n                        else if(typeof errors[key] == 'string')\n                            errorMessage += errors[key];\n                        else \n                            errorMessage += errors[key];\n                        errorMessage += ', ';\n                    });\n                } \n            } \n            if (response['statusCode'] && response['statusCode'] == '401') {\n                // when oauth errors occurs because of wrong access token\n                retObj['error'] = {\n                    code    : 'ERROR_AUTH',\n                    message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n                };\n\n            } else if (response['statusCode'] && response['statusCode'] == '429') {\n                // when rate limit occurs \n                retObj['error'] = {\n                    code    : 'ERROR_RATE_LIMIT',\n                    message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n                };\n\n            } else if (response['statusCode']){\n                // for all the other errors\n                retObj['error'] = {\n                    code    : 'ERROR_UNKNOWN',\n                    message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n                };\n            }\n        }\n    }\n    callback(retObj);\n}",
					"required": true
				},
				{
					"fixedValueSource": [],
					"id": "title",
					"name": "Title",
					"type": "String",
					"inputType": "input",
					"required": true
				},
				{
					"fixedValueSource": [],
					"id": "author",
					"name": "Author Name",
					"type": "String",
					"inputType": "input",
					"required": true
				},
				{
					"fixedValueSource": [],
					"id": "body_html",
					"name": "Content",
					"type": "String",
					"inputType": "textArea",
					"description": "Supports HTML",
					"required": true
				},
				{
					"fixedValueSource": [],
					"id": "image_src",
					"name": "Featured Image URL",
					"type": "String",
					"inputType": "input",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "summary_html",
					"name": "Excerpt/Summary",
					"type": "String",
					"inputType": "textArea",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "tags",
					"name": "Tags",
					"type": "String",
					"inputType": "multiinput",
					"required": false
				},
				{
					"fixedValueSource": [
						{
							"id": "true",
							"name": "Yes"
						},
						{
							"id": "false",
							"name": "No"
						}
					],
					"id": "published",
					"name": "Is Visible?",
					"type": "String",
					"inputType": "select",
					"required": false,
					"defaultValue": "true"
				}
			],
			"responseFields": [
				{
					"id": "entry_id",
					"name": "Blog Entry Id"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e5263",
			"name": "Add or Update Customer",
			"id": "add-customer",
			"description": "Creates a new Customer or Updates an existing Customer",
			"priority": 1,
			"entity": "person",
			"actionRequest": "function actionRequest(params, utils, callback) {\n\n  var url             = '/admin/customers/search.json';\n  var emailPattern    = /^([a-z0-9_.-]+)@([\\da-z.-]+)\\.([a-z.]{2,6})$/i;\n  var firstAddPrefix  = 'add1_';\n  var secondAddPrefix = 'add2_';\n  var retObj          = {status: \"ERROR\"};\n  var customer        = {addresses: []};\n  var address1        = {};\n  var address2        = {};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var update;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!(params || {}).userapp || !(params || {}).appinfo) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['error']['message']  = \"Missing the userapp or appinfo params\";\n    callback(retObj);\n    return;\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // extracting parameters\n    parameters = params.params;\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n    // defining the update mode based on the user input\n    update = (parameters && parameters['update']) ? (parameters['update'] === \"Yes\") ? true: false: false;    \n\n    if(!params['step']){\n        if(update && update === true)\n            params['step'] = {value: \"SEARCH\"};\n        else\n            params['step'] = {value: \"CREATE\"}\n    }\n\n    // creating customer object\n    for(var key in parameters){\n        if(key === 'first_name' || key === 'last_name' || key === 'email' || key === 'phone' \n                || key === 'tags' || key === 'note')\n                \n            customer[key]   =   parameters[key] || undefined;\n        else if ( key.includes(firstAddPrefix) )\n            address1[key.substring(firstAddPrefix.length)]    =   parameters[key] || undefined;\n        else if ( key.includes(secondAddPrefix) ) \n            address2[key.substring(secondAddPrefix.length)]   =   parameters[key] || undefined;\n    }\n    customer['addresses'].push(address1);\n    customer['addresses'].push(address2);\n\n    customer['accepts_marketing']   =   parameters['accepts_marketing'] ? parameters['accepts_marketing'] === \"Yes\" ? true : false : false; \n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['error']['message']  = \"Missing access token in the fetched auth params\"; \n        callback(retObj);\n        return;\n\n    } else if (!parameters || !parameters['email']) {\n        // checking for parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['error']['message']  = \"Missing required parameters\";\n        callback(retObj);\n        return;\n\n    } else if(params['step']['value'] === 'SEARCH') {\n        // firstly we need to search the customer with provided email id\n        if(emailPattern.test(parameters['email'])) {\n\n            // compiling the options for searching customers for the given email\n            options = {\n                method: 'GET',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + url,\n                json: true,\n                qs: {\n                    query: `email:${parameters.email}`\n                }\n            }\n            \n            retObj['status']        = \"SUCCESS\";\n            retObj['data']          = { options: options };\n            retObj['step']          = {};\n            retObj['step']['value'] = \"SEARCH\";\n\n        } else {\n            retObj['error']             = {};\n            retObj['error']['code']     = 'ERROR_UNKNOWN';\n            retObj['error']['message']  = \"Not a valid email\"; \n            callback(retObj);\n            return;\n        }\n    } else if (params['step']['value'] === 'UPDATE' && params['step']['customer_id'] && update) {\n        // when we already have a customer corresponding to the given email id, and user wants to update    \n        // compiling the options for searching customers for the given email\n        options = {\n            method: 'PUT',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + '/admin/customers/' + params['step']['customer_id'] + '.json',\n            json: true,\n            body: {\n                customer : customer,\n            }\n        }\n\n        retObj['status']        = \"SUCCESS\";\n        retObj['data']          = { options: options };\n        retObj['step']          = {};\n        retObj['step']['value'] = \"UPDATE\";\n\n    } else if(params['step']['value'] && params['step']['value'] === 'CREATE'){\n        // create a new customer\n        \n        options = {\n            method: 'POST',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + '/admin/customers.json',\n            json: true,\n            body: {\n                customer : customer,\n            }\n        }\n        retObj['status']        = \"SUCCESS\";\n        retObj['data']          = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var id       = null;\n  var errors;\n  var errorMessage;\n  var response;\n  var parsedBody;\n  var body;\n\n  // if response and body are not present in params\n  if (!(params || {}).response || !(params || {}).body) {\n    retObj['error'] = {};\n    retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n    retObj['error']['message'] = \"Invalid/Missing API response\";\n\n    callback(retObj);\n    return;\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful updation of customer with the given email\n    if (response['statusCode'] && response['statusCode'] == '200') {\n      \n        // setting the existing customer id in the step and parsed data\n        if (parsedBody['customers'] && parsedBody['customers'].length && params['step']['value'] === \"SEARCH\") {\n            id                      = parsedBody['customers'][0]['id'];\n            retObj['step']          = {};\n            retObj['step']['value'] = \"UPDATE\";\n            retObj['step']['customer_id'] = id;  \n\n        } else if (parsedBody['customer'] && parsedBody['customer']['id'] && params['step']['value'] === \"UPDATE\"){\n            // updated successfuly, no further need for actionrequest\n            id  = parsedBody['customer']['id'];\n        } else {\n            // no existing customer for given email so create a new one\n            retObj['step']          = {};\n            retObj['step']['value'] = \"CREATE\";\n        }\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { parsedValues: { id: id } };\n      \n    } else if (response['statusCode'] && response['statusCode'] == 201) {\n      // when a new customer is successfuly created with the given user data\n\n        if(parsedBody['customer'] && parsedBody['customer']['id']){\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { parsedValues: { id: parsedBody['customer']['id'] } };\n        } else {\n            retObj['error']            = {};\n            retObj['error']['code']    = \"ERROR_UNKNOWN\";\n            retObj['error']['message'] = \"API response not as expected, missing created customer id\"\n        }\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    } \n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
			"params": [
				{
					"fixedValueSource": [
						{
							"name": "Yes",
							"id": "Yes"
						},
						{
							"name": "No",
							"id": "No"
						}
					],
					"name": "Update if Customer exists",
					"id": "update",
					"description": "Duplicates are checked based on Email.",
					"inputType": "select",
					"defaultValue": "Yes",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "First Name",
					"id": "first_name",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Last Name",
					"id": "last_name",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Email",
					"id": "email",
					"inputType": "input",
					"type": "String",
					"required": true
				},
				{
					"fixedValueSource": [],
					"name": "Phone",
					"id": "phone",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "First Name",
					"id": "add1_first_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 1"
				},
				{
					"fixedValueSource": [],
					"name": "Last Name",
					"id": "add1_last_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 1"
				},
				{
					"fixedValueSource": [],
					"name": "Company",
					"id": "add1_company",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 1"
				},
				{
					"fixedValueSource": [],
					"name": "Phone",
					"id": "add1_phone",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 1"
				},
				{
					"fixedValueSource": [],
					"name": "Address",
					"id": "add1_address1",
					"inputType": "textArea",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 1"
				},
				{
					"fixedValueSource": [],
					"name": "City",
					"id": "add1_city",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 1"
				},
				{
					"fixedValueSource": [],
					"name": "Postal/Zip Code",
					"id": "add1_zip",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 1"
				},
				{
					"fixedValueSource": [],
					"name": "Country",
					"id": "add1_country",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 1"
				},
				{
					"fixedValueSource": [],
					"name": "State",
					"id": "add1_province",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 1"
				},
				{
					"fixedValueSource": [],
					"name": "First Name",
					"id": "add2_first_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 2"
				},
				{
					"fixedValueSource": [],
					"name": "Last Name",
					"id": "add2_last_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 2"
				},
				{
					"fixedValueSource": [],
					"name": "Company",
					"id": "add2_company",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 2"
				},
				{
					"fixedValueSource": [],
					"name": "Phone",
					"id": "add2_phone",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 2"
				},
				{
					"fixedValueSource": [],
					"name": "Address",
					"id": "add2_address1",
					"inputType": "textArea",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 2"
				},
				{
					"fixedValueSource": [],
					"name": "City",
					"id": "add2_city",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 2"
				},
				{
					"fixedValueSource": [],
					"name": "Postal/Zip Code",
					"id": "add2_zip",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 2"
				},
				{
					"fixedValueSource": [],
					"name": "Country",
					"id": "add2_country",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 2"
				},
				{
					"fixedValueSource": [],
					"name": "State",
					"id": "add2_province",
					"inputType": "input",
					"description": "Full name of state/province",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Address 2"
				},
				{
					"fixedValueSource": [],
					"name": "Tags",
					"id": "tags",
					"description": "Comma separated short descriptors",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Note",
					"id": "note",
					"inputType": "textArea",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [
						{
							"name": "Yes",
							"id": "Yes"
						},
						{
							"name": "No",
							"id": "No"
						}
					],
					"name": "Accepts Marketing",
					"id": "accepts_marketing",
					"inputType": "select",
					"defaultValue": "No",
					"type": "String",
					"required": false
				}
			],
			"responseFields": [
				{
					"name": "Customer ID",
					"id": "id",
					"description": "Shopify id of the created or update Customer",
					"type": "String"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e5262",
			"name": "Add Order",
			"id": "add-order",
			"description": "Creates a new Order",
			"priority": 2,
			"entity": "invoice",
			"deprecated": true,
			"actionRequest": "function actionRequest(params, utils, callback) {\n\n  var createUrl     = '/admin/orders.json';\n  var retObj        = {status: \"ERROR\"};\n  var order         = {line_items: [{}]};\n  var shippingPrefix= \"ship_\";\n  var billingPrefix = \"bill_\"\n  var shipAddress   = {};\n  var billAddress   = {};\n  var requiredPresent= false;\n  var qs;\n  var searchID;\n  var productUrl;\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!(params || {}).userapp || !(params || {}).appinfo || !(params || {}).params) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['error']['message']  = \"Missing the userapp, appinfo or params\";\n    callback(retObj);\n    return;\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // extracting parameters\n    parameters = params.params;\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // creating the order object to be created\n    for(var key in parameters){\n        if (key === 'note' || key === 'financial_status')\n            order[key] = parameters[key] || undefined;\n        else if (key === 'send_receipt' || key === 'send_fulfillment_receipt')\n            order[key] = parameters[key] ? parameters[key] === \"Yes\" ? true : false : false;\n        else if ( key.includes(shippingPrefix)) \n            shipAddress[key.substring(shippingPrefix.length)] = parameters[key] || undefined;\n        else if (key.includes(billingPrefix))\n            billAddress[key.substring(billingPrefix.length)] = parameters[key] || undefined;\n    }\n\n    order['line_items'][0]['price']      = parameters['price'] ? parameters['price'] : undefined;\n    order['line_items'][0]['quantity']   = parameters['quantity'] ? parameters['quantity'] : undefined;\n\n    if (parameters['variant_id']) {\n    \n        order['line_items'][0]['variant_id'] = parameters['variant_id'];\n\n        if(!params['step']){\n            params['step'] = {};\n            params['step']['value'] = \"CREATE_ORDER\";\n        } \n    } else if (!params['step']) {\n\n        params['step'] = {};\n        if (parameters['product_id'] || parameters['direct_product_id']) \n            params['step']['value'] = \"SEARCH_BY_PRODUCT_ID\";\n        else if (parameters['product_title']) \n            params['step']['value'] = \"SEARCH_BY_PRODUCT_TITLE\";\n    }\n\n    order['email']            = parameters['email'] ? parameters['email'] : undefined;\n    order['shipping_address'] = shipAddress && Object.keys(shipAddress).length ? shipAddress : undefined;\n    order['billing_address']  = billAddress && Object.keys(billAddress).length ? billAddress : undefined;\n\n    if (parameters['email']) {\n        order['customer']          = {};\n        order['customer']['email'] = parameters['email'];\n    }\n\n    if(parameters['product_id'] || parameters['direct_product_id'] || parameters['product_title'])\n        requiredPresent = true;\n    \n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['error']['message']  = \"Missing access token or shop url in the fetched auth params\"; \n        callback(retObj);\n        return;\n\n    } else if (!parameters || requiredPresent === false) {\n        // checking for parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['error']['message']  = \"Missing required parameters\";\n        callback(retObj);\n        return;\n\n    } else if (params['step'] && params['step']['value'] && params['step']['value'] === \"SEARCH_BY_PRODUCT_ID\" || params['step']['value'] === \"SEARCH_BY_PRODUCT_TITLE\") {\n\n        if (params['step']['value'] === \"SEARCH_BY_PRODUCT_ID\"){\n            searchID        = parameters['product_id'] ? parameters['product_id'] : parameters['direct_product_id'];\n            productUrl      = `/admin/products/${searchID}.json`; \n        } else {\n            qs = {title: parameters['product_title']}; \n            productUrl  = '/admin/products.json';\n        }\n        \n        retObj['step']  = {\"value\": params['step']['value']};\n       // compiling the options for searching prodcut for the given id or title \n        options = {\n            method: 'GET',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + productUrl,\n            json: true\n        }\n\n        if (params['step']['value'] === \"SEARCH_BY_PRODUCT_TITLE\") \n            options['qs'] = qs;\n\n    } else if (params['step'] && params['step']['value'] && params['step']['value'] === \"CREATE_ORDER\") {\n\n        if (params['step']['variant_id']) \n            order['line_items'][0]['variant_id'] = params['step']['variant_id'];\n        else if (params['step']['use_title'] && params['step']['use_title'] === true)\n            order['line_items'][0]['title']      = parameters['product_title'] ? parameters['product_title'] : undefined;\n\n        // compiling options for creating a new order\n        options = {\n            method: 'POST',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + createUrl,\n            json: true,\n            body: {\n                order : order,\n            }\n        }\n    }\n  }\n  // final callback\n  retObj['status']    = \"SUCCESS\";\n  retObj['data']      = { options: options };\n  callback(retObj);\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var errors;\n  var errorMessage;\n  var parsedBody;\n  var body;\n\n  // if response and body are not present in params\n  if (!(params || {}).response || !(params || {}).body) {\n    retObj['error'] = {};\n    retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n    retObj['error']['message'] = \"Invalid/Missing API response.\"\n\n    callback(retObj);\n    return;\n  } else {\n\n    response = params['response'];\n    parsedBody = params['body'];\n\n    // when a new order is successfuly created with given data\n    if (response['statusCode'] && response['statusCode'] == 201) {\n        if(parsedBody['order'] && parsedBody['order']['id']){\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { \n                parsedValues: { \n                    order_id: parsedBody['order']['id']\n                } \n            };\n        } else {\n            retObj['error']            = {};\n            retObj['error']['code']    = \"ERROR_UNKNOWN\";\n            retObj['error']['message'] = \"API response not as expected, missing created order details\"\n        }\n\n    } else if (response['statusCode'] && response['statusCode'] == 200) {\n\n        if (parsedBody['product'] && parsedBody['product']['variants'] && parsedBody['product']['variants'].length && params['step'] && params['step']['value'] === \"SEARCH_BY_PRODUCT_ID\") {\n            retObj['status']             = \"SUCCESS\";\n            retObj['step']               = {};\n            retObj['step']['value']      = \"CREATE_ORDER\";\n            retObj['step']['variant_id'] = parsedBody['product']['variants'][0] && parsedBody['product']['variants'][0]['id'] ? parsedBody['product']['variants'][0]['id'] : null ;\n\n        } else if (parsedBody['products'] && parsedBody['products'].length && parsedBody['products'][0]['variants'] && params['step'] && params['step']['value'] === \"SEARCH_BY_PRODUCT_TITLE\") {\n            retObj['status']             = \"SUCCESS\";\n            retObj['step']               = {};\n            retObj['step']['value']      = \"CREATE_ORDER\";\n            retObj['step']['variant_id'] = parsedBody['products'][0]['variants'][0] && parsedBody['products'][0]['variants'][0]['id'] ? parsedBody['products'][0]['variants'][0]['id'] : null;\n\n        } else {\n            retObj['status']             = \"SUCCESS\";\n            retObj['step']               = {};\n            retObj['step']['value']      = \"CREATE_ORDER\";\n            retObj['step']['use_title']  = true;\n        }\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    } \n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
			"params": [
				{
					"fixedValueSource": [],
					"name": "Customer Email",
					"id": "email",
					"inputType": "input",
					"type": "String",
					"description": "Email address of the Customer, If there is no Customer with Email address provided a new Customer will be created",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Product",
					"id": "product_id",
					"inputType": "select",
					"type": "String",
					"required": true,
					"groupType": "OR_REQUIRED",
					"groupName": "Product",
					"dynamicValueSourceRequest": "function dynamicValueSourceRequest(params, utils, callback) {\n\n    var productIdUrl  = '/admin/products.json?fields=id,title,limit=200';\n    var retObj        = {status: \"ERROR\"};\n    var shopUrl;\n    var userapp;\n    var options;\n    var fetchedParams;\n\n  // if appinfo or userapp are not present in params\n    if (!params || !params['appinfo'] || !params['userapp']) {\n        retObj['status'] = \"ERROR\";\n        retObj['error'] = {};\n        retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing\";\n\n    } else {\n        userapp = params['userapp'];\n        // fetch the auth params for given userapp\n        fetchedParams = userapp.fetchAuthParams(params['appinfo']);\n         // fetching the shop url\n        shopUrl =  userapp['params'].find(p => p.id === 'shop');\n\n        options = {\n            method: 'GET',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + productIdUrl,\n            json: true,\n        };\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = {\n            options: options\n        };\n    }\n    callback(retObj);\n}",
					"dynamicValueSourceParse": "function dynamicValueSourceParse(params, utils, callback) {\n\n    var retObj      = {status: \"ERROR\"};\n    var products;\n    var errors;\n    var errorMessage;\n\n    // if response or body are not present in params\n    if (!params || !params['response'] || !params['body']) {\n        retObj['error']            = {};\n        retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing.\";\n\n    } else {\n\n        let response = params.response\n\n        if (params['response']['statusCode'] == 200) {\n            // Extracting the products array\n            products = params['body']['products'];\n\n           // if any product returned from \n            if (products && products instanceof Array && products.length) {\n\n                var optionsArray = [];\n                // creating a option for each product\n                products.forEach(function(element){\n                    // if title and id exists for the product\n                    if(element['id'] && element['title'])\n                    optionsArray.push({\n                        name: element['title'],\n                        id  : element['id'] \n                    });\n                });\n                retObj['status'] = \"SUCCESS\";\n                retObj['data']   = optionsArray;\n            }\n        } else {\n            // when error data present, flattening the object\n            errors   =  params['body']['errors']; \n            if(errors){\n                errorMessage = '';\n                if(typeof errors == 'string')\n                    errorMessage  = errors;\n                else {\n                    Object.keys(errors).forEach(function(key){\n                        errorMessage += key + ': ';\n                        if(errors[key] && errors[key] instanceof Array)\n                            errorMessage += errors[key].join(',');\n                        else if(typeof errors[key] == 'string')\n                            errorMessage += errors[key];\n                        else \n                            errorMessage += errors[key];\n                        errorMessage += ', ';\n                    });\n                } \n            } \n            if (response['statusCode'] && response['statusCode'] == '401') {\n                // when oauth errors occurs because of wrong access token\n                retObj['error'] = {\n                    code    : 'ERROR_AUTH',\n                    message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n                };\n\n            } else if (response['statusCode'] && response['statusCode'] == '429') {\n                // when rate limit occurs \n                retObj['error'] = {\n                    code    : 'ERROR_RATE_LIMIT',\n                    message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n                };\n\n            } else if (response['statusCode']){\n                // for all the other errors\n                retObj['error'] = {\n                    code    : 'ERROR_UNKNOWN',\n                    message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n                };\n            }\n        }\n    }\n    callback(retObj);\n}"
				},
				{
					"fixedValueSource": [],
					"name": "Product ID",
					"id": "direct_product_id",
					"description": "Shopify ID of the product. Default variant of the product will be used.",
					"inputType": "input",
					"type": "String",
					"required": true,
					"groupType": "OR_REQUIRED",
					"groupName": "Product"
				},
				{
					"fixedValueSource": [],
					"name": "Product Title",
					"id": "product_title",
					"inputType": "input",
					"description": " Exact title of the product. If no product matches this title, the created Order will not be linked to any product",
					"type": "String",
					"required": true,
					"groupType": "OR_REQUIRED",
					"groupName": "Product"
				},
				{
					"fixedValueSource": [],
					"name": "Variant",
					"id": "variant_id",
					"description": "Select the variant incase you chose the product from the dropdown.",
					"inputType": "select",
					"type": "String",
					"required": false,
					"dynamicValueSourceRequest": "function dynamicValueSourceRequest(params, utils, callback) {\n\n    var requestUrl  =   '/admin/products/';\n    var retObj      =   {status: \"ERROR\"};\n    var options;\n    var paramList;\n    var fetchedParams;\n    var parameters;\n    var shopUrl;\n    var productId;\n    var product;\n\n    // if the must params not available than return with error object straightaway\n    if (!params || !params.params || !params.appinfo || !params.userapp) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['error']['message']  = \"Missing the params in input parameters\";\n        return callback(retObj);\n    \n    } else {\n\n        // fetch the auth params for given userapp\n        fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n        // extracting parameters\n        parameters  = params.params;\n        // find the value of product_id\n        product        = parameters.product_id\n        // fetching the shop url\n        shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n        if(shopUrl.value && product) {\n            // compiling options for creating a new order\n            options = {\n                method: 'GET',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + requestUrl + product + '/variants.json',\n                json: true,\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n\n        } else {\n            retObj['error']             = {};\n            retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n            retObj['error']['message']  = \"Missing the shopUrl or product id\";\n        }\n        return callback(retObj);\n    }\n}",
					"dynamicValueSourceParse": "function dynamicValueSourceParse(params, utils, callback) {\n\n    var retObj          =   {status: \"ERROR\"};\n    var data            =   [];\n    var errors;\n    var errorMessage;\n    var variants;\n\n    // if response and body are not present in params\n    if (!params || !params['response'] || !params['body']) {\n        retObj['error']            = {};\n        retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing\";\n        return callback(retObj);\n\n    } else if (params['response']['statusCode'] && params['response']['statusCode'] == 200 && params['body']['variants']){\n\n\n        variants  =  params['body']['variants'];\n\n        // creating the options for the select type input\n        if(variants && variants instanceof Array){\n            variants.forEach(function(element){\n                data.push({\n                    name: element['title'],\n                    id  : element['id'] \n                });\n            }, this);\n        }\n        return callback({ data, status: 'SUCCESS' });   \n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n    callback(retObj);\n}",
					"dependsOn": "product_id"
				},
				{
					"fixedValueSource": [],
					"name": "Unit Price",
					"id": "price",
					"description": "Required if you are using Product Title above.",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Quantity",
					"id": "quantity",
					"inputType": "input",
					"type": "String",
					"defaultValue": "1",
					"required": false
				},
				{
					"fixedValueSource": [
						{
							"name": "Pending",
							"id": "pending"
						},
						{
							"name": "Authorized",
							"id": "authorized"
						},
						{
							"name": "Partially Paid",
							"id": "partially_paid"
						},
						{
							"name": "Paid",
							"id": "paid"
						},
						{
							"name": "Partially Refunded",
							"id": "partially_refunded"
						},
						{
							"name": "Refunded",
							"id": "refunded"
						},
						{
							"name": "Voided",
							"id": "voided"
						}
					],
					"name": "Financial Status",
					"id": "financial_status",
					"description": "Status of the order finances",
					"inputType": "select",
					"defaultValue": "pending",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [
						{
							"name": "Yes",
							"id": "Yes"
						},
						{
							"name": "No",
							"id": "No"
						}
					],
					"name": "Send Reciept",
					"id": "send_receipt",
					"defaultValue": "No",
					"description": "Whether to send a order confirmation to customer",
					"inputType": "select",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [
						{
							"name": "Yes",
							"id": "Yes"
						},
						{
							"name": "No",
							"id": "No"
						}
					],
					"name": "Send fulfilment confirmation",
					"id": "send_fulfillment_receipt",
					"defaultValue": "No",
					"description": "Whether to send a fulfilment confirmation to customer",
					"inputType": "select",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Notes",
					"id": "note",
					"inputType": "textArea",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "First Name",
					"id": "ship_first_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Last Name",
					"id": "ship_last_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Company",
					"id": "ship_company",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Phone",
					"id": "ship_phone",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Address",
					"id": "ship_address1",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "City",
					"id": "ship_city",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Province",
					"id": "ship_province",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Country",
					"id": "ship_country",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Zip Code",
					"id": "ship_zip",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "First Name",
					"id": "bill_first_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Last Name",
					"id": "bill_last_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Company",
					"id": "bill_company",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Phone",
					"id": "bill_phone",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Address",
					"id": "bill_address1",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "City",
					"id": "bill_city",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Province",
					"id": "bill_province",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Country",
					"id": "bill_country",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Zip Code",
					"id": "bill_zip",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				}
			],
			"responseFields": [
				{
					"name": "Order ID",
					"id": "order_id",
					"description": "Shopify id of the created order",
					"type": "String"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e5261",
			"name": "Add Order",
			"id": "add-order-new",
			"description": "Creates a new Order",
			"beta": true,
			"priority": 2,
			"entity": "invoice",
			"actionRequest": "function actionRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  if (!params.params || !params.params['line-item-1-variant_id']) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'required param line item 1 variant id is missing',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const body = {\n    order: {\n      note_attributes: [],\n      line_items: []\n    }\n  }\n\n  const shippingPrefix = 'ship_'\n  const billingPrefix = 'bill_'\n  const lineItemPrefix = 'line-item-'\n  const noteAttrPrefix = 'additional_details_'\n\n  Object.keys(params.params)\n    .forEach(key => {\n      const data = params.params[key]\n      if (key.includes(shippingPrefix)) {\n\n        if (!body.order.shipping_address)\n          body.order.shipping_address = {}\n\n        body.order.shipping_address[key.substring(shippingPrefix.length)] = data\n\n      } else if (key.includes(billingPrefix)) {\n        \n        if (!body.order.billing_address)\n          body.order.billing_address = {}\n\n        body.order.billing_address[key.substring(billingPrefix.length)] = data\n\n      } else if (key.includes(lineItemPrefix)) {\n\n        const keyArr = key.split('-')\n        const [, , index, lineKey] = keyArr\n      \n        if(!body.order.line_items[index - 1])\n          body.order.line_items[index - 1] = {\n            properties: []\n          }\n        \n        if (lineKey.includes('lineItemProperty')) {\n          const propKey = lineKey\n            .replace(/AUTOMATEDASH/g, '-')\n            .replace('lineItemProperty', '')\n          body.order.line_items[index - 1].properties.push({\n            name: utils.libText.decodeKey(propKey),\n            value: data\n          })\n        } else {\n          body.order.line_items[index - 1][lineKey] = data \n        }\n\n      } else if (key === 'tags' && data && data.length) {\n        body.order[key] = data\n          .map(tag => tag.value)\n          .toString()\n      } else if (key.includes(noteAttrPrefix)) {\n        body.order.note_attributes.push({\n          name: utils.libText.decodeKey(key.replace(noteAttrPrefix, '')),\n          value: data\n        })\n      } else {\n        body.order[key] = data\n      }\n    })\n\n  const url = `https://${shopUrl}/admin/orders.json`\n\n  const options = {\n    body,\n    url,\n    method: 'POST',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n  \n  return callback(retObj)\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 201) {\n    retObj.status = 'SUCCESS'\n    retObj.data = {\n      parsedValues: {\n        order_id: body.order.id\n      }\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"params": [
				{
					"fixedValueSource": [],
					"id": "email",
					"name": "Customer Email",
					"description": "Email address of the Customer, If there is no Customer with Email address provided a new Customer will be created",
					"type": "String",
					"inputType": "input",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "line-item-1-variant_id",
					"name": "Variant Id",
					"type": "String",
					"inputType": "input",
					"required": true,
					"searchAction": "search-variant",
					"searchID": "id",
					"groupType": "COLLECTION",
					"groupName": "Line Item 1"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-1-title",
					"name": "Title",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 1"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-1-quantity",
					"name": "Quantity",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 1"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-1-price",
					"name": "Price",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 1"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-2-variant_id",
					"name": "Variant Id",
					"type": "String",
					"inputType": "input",
					"required": false,
					"searchAction": "search-variant",
					"searchID": "id",
					"groupType": "COLLECTION",
					"groupName": "Line Item 2"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-2-title",
					"name": "Title",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 2"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-2-quantity",
					"name": "Quantity",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 2"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-2-price",
					"name": "Price",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 2"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-3-variant_id",
					"name": "Variant Id",
					"type": "String",
					"inputType": "input",
					"required": false,
					"searchAction": "search-variant",
					"searchID": "id",
					"groupType": "COLLECTION",
					"groupName": "Line Item 3"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-3-title",
					"name": "Title",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 3"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-3-quantity",
					"name": "Quantity",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 3"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-3-price",
					"name": "Price",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 3"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-4-variant_id",
					"name": "Variant Id",
					"type": "String",
					"inputType": "input",
					"required": false,
					"searchAction": "search-variant",
					"searchID": "id",
					"groupType": "COLLECTION",
					"groupName": "Line Item 4"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-4-title",
					"name": "Title",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 4"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-4-quantity",
					"name": "Quantity",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 4"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-4-price",
					"name": "Price",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 4"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-5-variant_id",
					"name": "Variant Id",
					"type": "String",
					"inputType": "input",
					"required": false,
					"searchAction": "search-variant",
					"searchID": "id",
					"groupType": "COLLECTION",
					"groupName": "Line Item 5"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-5-title",
					"name": "Title",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 5"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-5-quantity",
					"name": "Quantity",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 5"
				},
				{
					"fixedValueSource": [],
					"id": "line-item-5-price",
					"name": "Price",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Line Item 5"
				},
				{
					"fixedValueSource": [
						{
							"name": "Pending",
							"id": "pending"
						},
						{
							"name": "Authorized",
							"id": "authorized"
						},
						{
							"name": "Partially Paid",
							"id": "partially_paid"
						},
						{
							"name": "Paid",
							"id": "paid"
						},
						{
							"name": "Partially Refunded",
							"id": "partially_refunded"
						},
						{
							"name": "Refunded",
							"id": "refunded"
						},
						{
							"name": "Voided",
							"id": "voided"
						}
					],
					"name": "Financial Status",
					"id": "financial_status",
					"description": "Status of the order finances",
					"inputType": "select",
					"defaultValue": "pending",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [
						{
							"name": "Yes",
							"id": "true"
						},
						{
							"name": "No",
							"id": "false"
						}
					],
					"name": "Send Reciept",
					"id": "send_receipt",
					"defaultValue": "false",
					"description": "Whether to send a order confirmation to customer",
					"inputType": "select",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [
						{
							"name": "Yes",
							"id": "true"
						},
						{
							"name": "No",
							"id": "false"
						}
					],
					"name": "Send fulfilment confirmation",
					"id": "send_fulfillment_receipt",
					"defaultValue": "false",
					"description": "Whether to send a fulfilment confirmation to customer",
					"inputType": "select",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Notes",
					"id": "note",
					"inputType": "textArea",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "tags",
					"name": "Tags",
					"type": "String",
					"inputType": "multiinput",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "First Name",
					"id": "ship_first_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Last Name",
					"id": "ship_last_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Company",
					"id": "ship_company",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Phone",
					"id": "ship_phone",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Address Line 1",
					"id": "ship_address1",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Address Line 2",
					"id": "ship_address2",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "City",
					"id": "ship_city",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Province",
					"id": "ship_province",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Country",
					"id": "ship_country",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "Zip Code",
					"id": "ship_zip",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Shipping Address"
				},
				{
					"fixedValueSource": [],
					"name": "First Name",
					"id": "bill_first_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Last Name",
					"id": "bill_last_name",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Company",
					"id": "bill_company",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Phone",
					"id": "bill_phone",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Address",
					"id": "bill_address1",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "City",
					"id": "bill_city",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Province",
					"id": "bill_province",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Country",
					"id": "bill_country",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				},
				{
					"fixedValueSource": [],
					"name": "Zip Code",
					"id": "bill_zip",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Billing Address"
				}
			],
			"dynamicInputFields": true,
			"dynamicInputFieldsRequest": "function dynamicInputFieldsRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/orders.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      limit: 20,\n      status: 'any',\n      fields: 'line_items,note_attributes,name'\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"dynamicInputFieldsParse": "function dynamicResponseFieldsParse(params, utils, callback) {\n  const retObj = {}\n  const capitalize = word => word[0].toUpperCase() + word.slice(1, word.length).toLowerCase()\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n\n    retObj.status = 'SUCCESS'\n    retObj.data = []\n\n    if (body && body.orders && body.orders.length) {\n      const responseObjArray = []\n      const noteAtrrObj = {}\n      const propObj = {}\n\n      body.orders\n        .forEach(order => {\n          //note atrributes\n          const note_attributes = order.note_attributes\n          if (note_attributes && Array.isArray(note_attributes) && note_attributes.length) {\n            note_attributes\n              .forEach(attr => {\n                if (attr.name) {\n                  noteAtrrObj[attr.name] = attr.value || ''\n                }\n              })\n          }\n          //end note attributes\n\n          //line item properties\n          const lineItems = order.line_items\n          if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n            lineItems\n              .forEach(line => {\n                const props = line.properties\n                if (props && Array.isArray(props) && props.length) {\n                  props.forEach(prop => {\n                    if (prop.name) {\n                      propObj[prop.name] = prop.value || ''\n                    }\n                  })\n                }\n              })\n          }\n        })\n\n      Object.keys(noteAtrrObj)\n        .forEach(key => {\n          responseObjArray.push({\n            id: `additional_details_${utils.libText.encodeKey(key)}`,\n            name: `${key}`,\n            type: 'String',\n            inputType: 'input',\n            required: false,\n            groupType: \"COLLECTION\",\n            groupName: \"Additional Details\"\n          })\n        })\n\n      if (Object.keys(propObj).length) {\n        Array(5).fill(0).forEach((_, index) => {\n          Object.keys(propObj)\n            .forEach(key => {\n              responseObjArray.push({\n                id: `line-item-${ index + 1 }-lineItemProperty${utils.libText.encodeKey(key.replace(/-/g, 'AUTOMATEDASH'))}`,\n                name: `${key}`,\n                type: 'String',\n                inputType: 'input',\n                required: false,\n                groupType: 'COLLECTION',\n                groupName: `Line Item ${ index + 1 }`\n              })\n            })\n        })\n      }\n\n      retObj.data = responseObjArray\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"responseFields": [
				{
					"id": "order_id",
					"name": "Order Id"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e5260",
			"name": "Add or Update Product",
			"id": "add-product",
			"description": "Creates a new Product or Updates an existing Product",
			"priority": 2,
			"entity": "product",
			"actionRequest": "function actionRequest(params, utils, callback) {\n\n    var createUrl = '/admin/products.json';\n    var retObj = { status: \"ERROR\" };\n    var product = { variants: [{}], images: [{}] };\n    var address = {};\n    var update = false;\n    var productTitle;\n    var shopUrl;\n    var fetchedParams;\n    var parameters;\n    var options;\n\n    // if the must params not available than return with error object straightaway\n    if (!(params || {}).userapp || !(params || {}).appinfo || !(params || {}).params) {\n        retObj['error'] = {};\n        retObj['error']['code'] = 'ERROR_MISSING_PARAM';\n        retObj['error']['message'] = \"Missing the userapp or appinfo params\";\n        callback(retObj);\n        return;\n\n    } else {\n\n        // fetch the auth params for given userapp\n        fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n        // extracting parameters\n        parameters = params.params;\n        // fetching the shop url\n        shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n\n        if (!params.step)\n            params.step = {}\n\n        if (parameters && parameters['update'] && !params.step.value) {\n\n            if (parameters['update'] === 'create') {\n                params['step']['value'] = \"CREATE\";\n            }\n            else if (parameters['update'] === 'update') {\n                update = true;\n                params['step']['value'] = \"SEARCH\";\n            }\n        } else if (!parameters['update'] && !params['step']['value']) {\n            params['step']['value'] = \"CREATE\"\n        }\n\n        if (parameters) {\n            productTitle = parameters['title'];\n            // creating the product object to be created or updated\n            for (var key in parameters) {\n\n                if (key === 'image_url')\n                    product['images'][0]['src'] = parameters[key] || undefined;\n                else if (key === 'inventory_policy' || key === 'price' || key === 'sku')\n                    product['variants'][0][key] = parameters[key] || undefined;\n                else if (key != 'operation')\n                    product[key] = parameters[key] || undefined;\n            }\n\n            if (parameters.location_id && parameters.inventory_quantity) {\n                if (!product['variants'])\n                    product['variants'] = [{}]\n                product['variants'][0]['inventory_management'] = 'shopify'\n            }\n        }\n\n        // if the access token not available than return with error object\n        if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n            // checking for access token\n            retObj['error'] = {};\n            retObj['error']['code'] = 'ERROR_MISSING_PARAM';\n            retObj['error']['message'] = \"Missing access token or shop url in the fetched auth params\";\n            callback(retObj);\n            return;\n\n        } else if (!parameters || !parameters['title']) {\n            // checking for parameters\n            retObj['error'] = {};\n            retObj['error']['code'] = 'ERROR_MISSING_PARAM';\n            retObj['error']['message'] = \"Missing required parameter\";\n            callback(retObj);\n            return;\n\n        } else if (params.step && params.step.setQuantity) {\n            options = {\n                method: 'POST',\n                url: `https://${shopUrl.value}/admin/inventory_levels/set.json`,\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type': 'application/json',\n                },\n                body: {\n                    \"location_id\": parameters.location_id,\n                    \"inventory_item_id\": params.step.inventory_item_id,\n                    \"available\": parameters.inventory_quantity\n                },\n                json: true\n            }\n\n            retObj.status = 'SUCCESS'\n            retObj.data = { options }\n            retObj.step = {\n                setQuantityReq: true,\n                product_id: params.step.product_id\n            }\n        } else if (params['step'] && params['step']['value'] === \"CREATE\") {\n\n            // create a new product with given details \n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type': 'application/json',\n                },\n                url: 'https://' + shopUrl.value + createUrl,\n                json: true,\n                body: {\n                    product: product,\n                }\n            }\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { options: options };\n\n            if (parameters.inventory_quantity && parameters.location_id) {\n                retObj.step = {\n                    setQuantity: true\n                }\n            }\n\n        } else if (params['step'] && params['step']['value'] === \"SEARCH\" && productTitle) {\n\n            // compiling the options for searching prodcut for the given title of product\n            options = {\n                method: 'GET',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type': 'application/json',\n                },\n                url: 'https://' + shopUrl.value + '/admin/products.json',\n                json: true,\n                qs: { title: productTitle }\n            }\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { options: options };\n            retObj['step'] = {};\n            retObj['step']['value'] = \"SEARCH\";\n            retObj['step']['product_title'] = productTitle.toLowerCase();\n\n        } else if (params['step'] && params['step']['value'] === \"UPDATE\" && params['step']['product_id']) {\n\n            // search a product with given title first \n            options = {\n                method: 'PUT',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type': 'application/json',\n                },\n                url: 'https://' + shopUrl.value + '/admin/products/' + params['step']['product_id'] + '.json',\n                json: true,\n                body: {\n                    product: product,\n                }\n            }\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { options: options };\n            retObj['step'] = {};\n            retObj['step']['value'] = \"UPDATE\";\n\n            if (parameters.inventory_quantity && parameters.location_id) {\n                retObj.step.setQuantity = true\n            }\n\n        }\n    }\n\n    // final callback\n    callback(retObj);\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var id;\n  var tempProduct;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!(params || {}).response || !(params || {}).body) {\n    retObj['error']            = {};\n    retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n    retObj['error']['message'] = \"Invalid/Missing API response.\";\n\n    callback(retObj);\n    return;\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful updation of customer with the given email\n    if (response['statusCode'] && response['statusCode'] == '200') {\n        \n        retObj['status'] = \"SUCCESS\";\n        if (params.step && params.step.setQuantityReq) {\n            retObj.status = 'SUCCESS'\n            retObj.data = {\n                parsedValues: {\n                    product_id: params.step.product_id\n                }\n            }\n        }\n        // setting the existing customer id in the step and parsed data\n        else if (parsedBody['products'] && parsedBody['products'].length && params['step'] \n            && params['step']['value'] === \"SEARCH\" && params['step']['product_title']) {\n            \n            tempProduct  =   parsedBody['products'].find( p => p.title.toLowerCase() === params['step']['product_title']);\n            id = tempProduct && tempProduct['id'] ? tempProduct['id'] : undefined;\n            \n            // incase a match is found out of given results\n            if(id) {\n                retObj['step']               = {};\n                retObj['step']['value']      = \"UPDATE\";\n                retObj['step']['product_id'] = id;\n\n            } else {\n                // no matched product found in response\n                retObj['step']             = {};\n                retObj['step']['value']    = \"CREATE\";\n            }\n             \n        } else if (parsedBody['product'] && parsedBody['product']['id'] && params['step'] && params['step']['value'] === \"UPDATE\") {\n            \n            id             =   parsedBody['product']['id']\n            retObj['data'] = { parsedValues: { product_id: id } };\n\n            if (params.step && params.step.setQuantity) {\n                const { product } = parsedBody\n                if (product.id && product.variants && product.variants.length) {\n                    if (product.variants[0].inventory_item_id) {\n                        retObj.step = {\n                            setQuantity: true,\n                            product_id: product.id,\n                            inventory_item_id: product.variants[0].inventory_item_id\n                        }\n                    }\n                }\n            } else {\n                retObj.warning = 'Quantity for the product wont be set, as you have not provided a location of inventory for which quantity is to be set'\n            }\n\n            if (params.step && params.step.setQuantity) {\n                const { product } = parsedBody\n                if (product.id && product.variants && product.variants.length) {\n                    if (product.variants[0].inventory_item_id) {\n                        retObj.step = {\n                            setQuantity: true,\n                            product_id: product.id,\n                            inventory_item_id: product.variants[0].inventory_item_id\n                        }\n                    }\n                }\n            } else {\n                retObj.warning = 'Quantity for the product wont be set, as you have not provided a location of inventory for which quantity is to be set'\n            }\n\n        } else {\n            // no product found in response\n            retObj['step']            = {};\n            retObj['step']['value']    = \"CREATE\";\n        }\n\n    } else if (response['statusCode'] && response['statusCode'] == 201) {\n      // when a new product is successfuly created with the given data\n        if(parsedBody['product'] && parsedBody['product']['id']){\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { \n                parsedValues: { \n                    product_id: parsedBody['product']['id'] \n                } \n            };\n\n            if (params.step && params.step.setQuantity) {\n                const { product } = parsedBody\n                if (product.id && product.variants && product.variants.length) {\n                    if (product.variants[0].inventory_item_id) {\n                        retObj.step = {\n                            setQuantity: true,\n                            product_id: product.id,\n                            inventory_item_id: product.variants[0].inventory_item_id\n                        }\n                    }\n                }\n            } else {\n                retObj.warning = 'Quantity for the product wont be set, as you have not provided a location of inventory for which quantity is to be set'\n            }\n\n        } else {\n            retObj['error']            = {};\n            retObj['error']['code']    = \"ERROR_UNKNOWN\";\n            retObj['error']['message'] = \"API response not as expected, missing created product details\"\n        }\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    } \n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
			"params": [
				{
					"fixedValueSource": [
						{
							"name": "Update",
							"id": "update"
						},
						{
							"name": "Create New",
							"id": "create"
						}
					],
					"name": "If a duplicate is found",
					"id": "update",
					"description": "Duplicates are searched based on product title (exact match)",
					"inputType": "select",
					"defaultValue": "update",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Title",
					"id": "title",
					"inputType": "input",
					"type": "String",
					"required": true
				},
				{
					"fixedValueSource": [],
					"name": "Product Type",
					"id": "product_type",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Vendor",
					"id": "vendor",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Description",
					"id": "body_html",
					"inputType": "textArea",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Image URL",
					"id": "image_url",
					"description": "URL of image to be used for product",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Price",
					"id": "price",
					"description": "Price per unit of product",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Quantity",
					"id": "inventory_quantity",
					"description": "Quantity available at your store (This will allow Shopify to track inventory of the product)",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Set Quantity"
				},
				{
					"fixedValueSource": [],
					"id": "location_id",
					"name": "Inventory Location",
					"type": "String",
					"description": "Please select a location to set inventory quantity",
					"inputType": "select",
					"dynamicValueSourceRequest": "function dynamicValueSourceRequest(params, utils, callback) {\n\n  var productIdUrl  = '/admin/locations.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var userapp;\n  var options;\n  var fetchedParams;\n\n// if appinfo or userapp are not present in params\n  if (!params || !params['appinfo'] || !params['userapp']) {\n      retObj['status'] = \"ERROR\";\n      retObj['error'] = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['error']['message'] = \"Error: Input parameters are missing\";\n\n  } else {\n      userapp = params['userapp'];\n      // fetch the auth params for given userapp\n      fetchedParams = userapp.fetchAuthParams(params['appinfo']);\n       // fetching the shop url\n      shopUrl =  userapp['params'].find(p => p.id === 'shop');\n\n      options = {\n          method: 'GET',\n          headers: {\n              'X-Shopify-Access-Token': fetchedParams['access_token'],\n              'Content-Type'          : 'application/json',\n          },\n          url: 'https://' + shopUrl.value + productIdUrl,\n          json: true,\n      };\n\n      retObj['status'] = \"SUCCESS\";\n      retObj['data'] = {\n          options: options\n      };\n  }\n  callback(retObj);\n}",
					"dynamicValueSourceParse": "function dynamicValueSourceParse(params, utils, callback) {\n\n  var retObj = { status: \"ERROR\" };\n  var locations;\n  var errors;\n  var errorMessage;\n\n  // if response or body are not present in params\n  if (!params || !params['response'] || !params['body']) {\n    retObj['error'] = {};\n    retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n    retObj['error']['message'] = \"Error: Input parameters are missing.\";\n\n  } else {\n\n    let response = params.response\n\n    if (params['response']['statusCode'] == 200) {\n      // Extracting the products array\n      locations = params['body']['locations'];\n\n      // if any product returned from \n      if (locations && locations instanceof Array && locations.length) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = locations\n          .map(location => ({\n            id: location.id,\n            name: location.name\n          })\n          )\n\n      } else {\n        retObj.status = 'SUCCESS'\n        retObj.data = []\n      }\n    } else {\n      // when error data present, flattening the object\n      errors = params['body']['errors'];\n      if (errors) {\n        errorMessage = '';\n        if (typeof errors == 'string')\n          errorMessage = errors;\n        else {\n          Object.keys(errors).forEach(function (key) {\n            errorMessage += key + ': ';\n            if (errors[key] && errors[key] instanceof Array)\n              errorMessage += errors[key].join(',');\n            else if (typeof errors[key] == 'string')\n              errorMessage += errors[key];\n            else\n              errorMessage += errors[key];\n            errorMessage += ', ';\n          });\n        }\n      }\n      if (response['statusCode'] && response['statusCode'] == '401') {\n        // when oauth errors occurs because of wrong access token\n        retObj['error'] = {\n          code: 'ERROR_AUTH',\n          message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n        };\n\n      } else if (response['statusCode'] && response['statusCode'] == '429') {\n        // when rate limit occurs \n        retObj['error'] = {\n          code: 'ERROR_RATE_LIMIT',\n          message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n        };\n\n      } else if (response['statusCode']) {\n        // for all the other errors\n        retObj['error'] = {\n          code: 'ERROR_UNKNOWN',\n          message: errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode']\n        };\n      }\n    }\n  }\n  callback(retObj);\n}",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Set Quantity"
				},
				{
					"fixedValueSource": [],
					"name": "SKU",
					"id": "sku",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [
						{
							"name": "Deny Order",
							"id": "deny"
						},
						{
							"name": "Continue Order",
							"id": "continue"
						}
					],
					"name": "When product is out of stock",
					"id": "inventory_policy",
					"inputType": "select",
					"defaultValue": "deny",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"name": "Tags",
					"id": "tags",
					"description": "Comma separated list of tags for product",
					"inputType": "input",
					"type": "String",
					"required": false
				}
			],
			"responseFields": [
				{
					"name": "Product ID",
					"id": "product_id",
					"description": "Shopify id of the product",
					"type": "String"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e525f",
			"id": "add-variant",
			"name": "Add Product Variant",
			"description": "Creates a new Product Variant",
			"important": true,
			"priority": 3,
			"beta": true,
			"entity": "product",
			"actionRequest": "function actionRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  if (!params.params || !params.params.product_id || !params.params.option1) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'required params product id or title is missing',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  if (params.params.available && params.params.location_id) {\n    retObj.step = {\n      fetchInventoryId: true\n    }\n  }\n\n  params.params.inventory_management = 'shopify'\n\n  const variant = {}\n\n  Object.keys(params.params)\n    .forEach(key => {\n      if (key !== 'amount' && key !== 'location_id') {\n        variant[key] = params.params[key]\n      }\n    })\n\n  const options = {\n    method: 'POST',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    json: true\n  }\n\n  if (params.step && params.step.setQuantity) {\n\n    options.url = `https://${shopUrl}/admin/inventory_levels/set.json`\n    options.body = {\n      \"location_id\": params.params.location_id,\n      \"inventory_item_id\": params.step.inventory_item_id,\n      \"available\": params.params.available\n    }\n    retObj.step = {\n      variant_id: params.step.variant_id\n    }\n\n  } else {\n\n    options.url = `https://${shopUrl}/admin/products/${params.params.product_id}/variants.json`\n\n    options.body = {\n      variant\n    }\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 201 || response.statusCode === 200) {\n    retObj.status = 'SUCCESS'\n    if (body.variant) {\n      if (params.step && params.step.fetchInventoryId) {\n        retObj.step = {\n          setQuantity: true,\n          inventory_item_id: body.variant.inventory_item_id || '',\n          variant_id: body.variant.id\n        }\n      } else {\n        retObj.data = {\n          parsedValues: {\n            variant_id: body.variant.id\n          }\n        }\n      }\n    } else {\n        retObj.data = {\n          parsedValues: {\n            variant_id: params.step.variant_id\n          }\n        }\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"params": [
				{
					"fixedValueSource": [],
					"id": "product_id",
					"name": "Product",
					"type": "String",
					"inputType": "select",
					"required": true,
					"dynamicValueSourceRequest": "function dynamicValueSourceRequest(params, utils, callback) {\n\n    var productIdUrl  = '/admin/products.json?fields=id,title,limit=200';\n    var retObj        = {status: \"ERROR\"};\n    var shopUrl;\n    var userapp;\n    var options;\n    var fetchedParams;\n\n  // if appinfo or userapp are not present in params\n    if (!params || !params['appinfo'] || !params['userapp']) {\n        retObj['status'] = \"ERROR\";\n        retObj['error'] = {};\n        retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing\";\n\n    } else {\n        userapp = params['userapp'];\n        // fetch the auth params for given userapp\n        fetchedParams = userapp.fetchAuthParams(params['appinfo']);\n         // fetching the shop url\n        shopUrl =  userapp['params'].find(p => p.id === 'shop');\n\n        options = {\n            method: 'GET',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + productIdUrl,\n            json: true,\n        };\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = {\n            options: options\n        };\n    }\n    callback(retObj);\n}",
					"dynamicValueSourceParse": "function dynamicValueSourceParse(params, utils, callback) {\n\n    var retObj      = {status: \"ERROR\"};\n    var products;\n    var errors;\n    var errorMessage;\n\n    // if response or body are not present in params\n    if (!params || !params['response'] || !params['body']) {\n        retObj['error']            = {};\n        retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing.\";\n\n    } else {\n\n        let response = params.response\n\n        if (params['response']['statusCode'] == 200) {\n            // Extracting the products array\n            products = params['body']['products'];\n\n           // if any product returned from \n            if (products && products instanceof Array && products.length) {\n\n                var optionsArray = [];\n                // creating a option for each product\n                products.forEach(function(element){\n                    // if title and id exists for the product\n                    if(element['id'] && element['title'])\n                    optionsArray.push({\n                        name: element['title'],\n                        id  : element['id'] \n                    });\n                });\n                retObj['status'] = \"SUCCESS\";\n                retObj['data']   = optionsArray;\n            } else {\n                retObj.status = 'SUCCESS'\n                retObj.data = []\n            }\n        } else {\n            // when error data present, flattening the object\n            errors   =  params['body']['errors']; \n            if(errors){\n                errorMessage = '';\n                if(typeof errors == 'string')\n                    errorMessage  = errors;\n                else {\n                    Object.keys(errors).forEach(function(key){\n                        errorMessage += key + ': ';\n                        if(errors[key] && errors[key] instanceof Array)\n                            errorMessage += errors[key].join(',');\n                        else if(typeof errors[key] == 'string')\n                            errorMessage += errors[key];\n                        else \n                            errorMessage += errors[key];\n                        errorMessage += ', ';\n                    });\n                } \n            } \n            if (response['statusCode'] && response['statusCode'] == '401') {\n                // when oauth errors occurs because of wrong access token\n                retObj['error'] = {\n                    code    : 'ERROR_AUTH',\n                    message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n                };\n\n            } else if (response['statusCode'] && response['statusCode'] == '429') {\n                // when rate limit occurs \n                retObj['error'] = {\n                    code    : 'ERROR_RATE_LIMIT',\n                    message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n                };\n\n            } else if (response['statusCode']){\n                // for all the other errors\n                retObj['error'] = {\n                    code    : 'ERROR_UNKNOWN',\n                    message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n                };\n            }\n        }\n    }\n    callback(retObj);\n}",
					"searchID": "id",
					"searchAction": "search-product"
				},
				{
					"fixedValueSource": [],
					"id": "option1",
					"name": "Title",
					"type": "String",
					"inputType": "input",
					"required": true
				},
				{
					"fixedValueSource": [],
					"id": "price",
					"name": "Price",
					"type": "String",
					"inputType": "input",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "compare_at_price",
					"name": "Compare at Price",
					"type": "String",
					"inputType": "input",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "sku",
					"name": "SKU",
					"type": "String",
					"inputType": "input",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "available",
					"name": "Inventory Quantity",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Set Quantity"
				},
				{
					"fixedValueSource": [],
					"id": "location_id",
					"name": "Inventory Location",
					"type": "String",
					"description": "Please select a location to set inventory quantity",
					"inputType": "select",
					"dynamicValueSourceRequest": "function dynamicValueSourceRequest(params, utils, callback) {\n\n  var productIdUrl  = '/admin/locations.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var userapp;\n  var options;\n  var fetchedParams;\n\n// if appinfo or userapp are not present in params\n  if (!params || !params['appinfo'] || !params['userapp']) {\n      retObj['status'] = \"ERROR\";\n      retObj['error'] = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['error']['message'] = \"Error: Input parameters are missing\";\n\n  } else {\n      userapp = params['userapp'];\n      // fetch the auth params for given userapp\n      fetchedParams = userapp.fetchAuthParams(params['appinfo']);\n       // fetching the shop url\n      shopUrl =  userapp['params'].find(p => p.id === 'shop');\n\n      options = {\n          method: 'GET',\n          headers: {\n              'X-Shopify-Access-Token': fetchedParams['access_token'],\n              'Content-Type'          : 'application/json',\n          },\n          url: 'https://' + shopUrl.value + productIdUrl,\n          json: true,\n      };\n\n      retObj['status'] = \"SUCCESS\";\n      retObj['data'] = {\n          options: options\n      };\n  }\n  callback(retObj);\n}",
					"dynamicValueSourceParse": "function dynamicValueSourceParse(params, utils, callback) {\n\n  var retObj = { status: \"ERROR\" };\n  var locations;\n  var errors;\n  var errorMessage;\n\n  // if response or body are not present in params\n  if (!params || !params['response'] || !params['body']) {\n    retObj['error'] = {};\n    retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n    retObj['error']['message'] = \"Error: Input parameters are missing.\";\n\n  } else {\n\n    let response = params.response\n\n    if (params['response']['statusCode'] == 200) {\n      // Extracting the products array\n      locations = params['body']['locations'];\n\n      // if any product returned from \n      if (locations && locations instanceof Array && locations.length) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = locations\n          .map(location => ({\n            id: location.id,\n            name: location.name\n          })\n          )\n\n      } else {\n        retObj.status = 'SUCCESS'\n        retObj.data = []\n      }\n    } else {\n      // when error data present, flattening the object\n      errors = params['body']['errors'];\n      if (errors) {\n        errorMessage = '';\n        if (typeof errors == 'string')\n          errorMessage = errors;\n        else {\n          Object.keys(errors).forEach(function (key) {\n            errorMessage += key + ': ';\n            if (errors[key] && errors[key] instanceof Array)\n              errorMessage += errors[key].join(',');\n            else if (typeof errors[key] == 'string')\n              errorMessage += errors[key];\n            else\n              errorMessage += errors[key];\n            errorMessage += ', ';\n          });\n        }\n      }\n      if (response['statusCode'] && response['statusCode'] == '401') {\n        // when oauth errors occurs because of wrong access token\n        retObj['error'] = {\n          code: 'ERROR_AUTH',\n          message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n        };\n\n      } else if (response['statusCode'] && response['statusCode'] == '429') {\n        // when rate limit occurs \n        retObj['error'] = {\n          code: 'ERROR_RATE_LIMIT',\n          message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n        };\n\n      } else if (response['statusCode']) {\n        // for all the other errors\n        retObj['error'] = {\n          code: 'ERROR_UNKNOWN',\n          message: errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode']\n        };\n      }\n    }\n  }\n  callback(retObj);\n}",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Set Quantity"
				},
				{
					"fixedValueSource": [
						{
							"id": "deny",
							"name": "Deny"
						},
						{
							"id": "continue",
							"name": "Allow"
						}
					],
					"id": "inventory_policy",
					"name": "Allow customers to purchase this product when it's out of stock",
					"type": "String",
					"inputType": "select",
					"required": false
				}
			],
			"responseFields": [
				{
					"id": "variant_id",
					"name": "Product Variant Id",
					"type": "String"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e525e",
			"id": "archive-order",
			"name": "Archive an Order",
			"description": "Archives an existing Order",
			"important": true,
			"priority": 3,
			"beta": true,
			"entity": "product",
			"actionRequest": "function actionRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  if (!params.params || !params.params.order_id) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'required params customer id or tags are missing',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const body = {}\n\n  const url = `https://${shopUrl}/admin/orders/${params.params.order_id}/close.json`\n  const options = {\n    method: 'POST',\n    body,\n    url,\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n    retObj.status = 'SUCCESS'\n    retObj.data = {\n      parsedValues: {\n        order_id: body.order.id\n      }\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else if (response.statusCode === 404) {\n      retObj.error = {\n        message: 'order to archive, not found'\n      }\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"params": [
				{
					"fixedValueSource": [],
					"id": "order_id",
					"name": "Order Id",
					"type": "String",
					"inputType": "input",
					"required": true,
					"searchAction": "search-order",
					"searchID": "id"
				}
			],
			"responseFields": [
				{
					"id": "order_id",
					"name": "Archived Order Id"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e525d",
			"name": "Search a Customer",
			"id": "search-customer",
			"description": "Search for a Customer",
			"priority": 3,
			"entity": "person",
			"actionRequest": "function actionRequest(params, utils, callback) {\n\n  var retObj          = {status: \"ERROR\"};\n  var requiredPresent = false;\n  var url             = '/admin/customers/search.json';\n  var shopUrl;\n  var qs;\n  var fetchedParams;\n  var parameters;\n  var email;\n  var customerID;\n  var customerName;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!(params || {}).userapp || !(params || {}).appinfo) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['error']['message']  = \"Missing the userapp or appinfo params\";\n    callback(retObj);\n    return;\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // extracting parameters\n    parameters = params.params;\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    email        = (parameters && parameters['email']) ? parameters['email'] : null;\n    customerID   = (parameters && parameters['id']) ? parameters['id'] : null;\n    customerName = (parameters && parameters['name']) ? parameters['name'] : null;\n\n    // if any one of the values is present then it is OK\n    if(email || customerID || customerName)\n        requiredPresent = true;\n    \n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['error']['message']  = \"Missing access token in the fetched auth params\"; \n        callback(retObj);\n        return;\n\n    } else if (!parameters || requiredPresent === false) {\n        // checking for parameters\n        retObj.status = 'SUCCESS'\n        retObj.data = {\n            response: {\n                found: 'NO'\n            }\n        }\n        callback(retObj);\n        return;\n\n    } else {\n\n        if(customerID)\n            url         = `/admin/customers/${customerID}.json`;\n        else if (email)\n            qs = {query: `email:${email}`}; \n        else if (customerName)\n            qs = {query: `${customerName}`};\n\n        // compiling the options for searching customers for the given email or name or id\n        options = {\n            method: 'GET',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + url,\n            json: true\n        }\n        \n        if (email || customerName)\n            options['qs'] = qs;\n        if (!customerID && !email && customerName){\n            retObj['step']          = {};\n            retObj['step']['value'] = customerName.toLowerCase();\n        }\n\n        retObj['status']        = \"SUCCESS\";\n        retObj['data']          = { options: options };\n    } \n  }\n  // final callback\n  callback(retObj);\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n\n  var retObj                 = {status: \"ERROR\"};\n  var defaultAddressPrefix   = 'default_address_';\n  var otherAddressPrefix     = 'second_address_';\n  var id                     = null;\n  var searchedCustomer       = {};\n  var errorMessage;\n  var errors;\n  var defaultAddress;\n  var otherAddress;\n  var response;\n  var responseKeys;\n  var parsedBody;\n  var customerBody;\n  var body;\n\n  // if response and body are not present in params\n  if (!(params || {}).response || !(params || {}).body) {\n    retObj['error'] = {};\n    retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n    retObj['error']['message'] = \"Invalid/Missing API response\";\n\n    callback(retObj);\n    return;\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, successful search\n    if (response['statusCode'] && response['statusCode'] == '200' && parsedBody) {\n\n        if(parsedBody['customer'])\n            customerBody = parsedBody['customer'];\n        else if (parsedBody['customers'] && parsedBody['customers'].length){\n            customerBody = parsedBody['customers'][0];\n        } else \n            customerBody = {};\n\n        // extracting the keys of response data of customer\n        responseKeys    = Object.keys(customerBody);\n        \n        if(responseKeys.length){\n\n            searchedCustomer['found']   = \"Yes\";\n\n            // iterating each key of the customer related data json\n            responseKeys.forEach(function(key){\n                \n                if(key === 'addresses'){\n\n                    // find and parse default address\n                    defaultAddress = customerBody[key].find(e => e.default == true);\n                    if(defaultAddress){\n                        Object.keys(defaultAddress).forEach(function(field){\n                            if (field === 'created_at' || field === 'updated_at'){\n                                searchedCustomer[defaultAddressPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(defaultAddress[field]) || '';\n                            } else\n                                searchedCustomer[defaultAddressPrefix + field] = defaultAddress[field] || '';\n                        }, this);\n                    }\n                  \n                    // find and parse secondary or non default address\n                    otherAddress = customerBody[key].find(e => e.default != true);\n                    if(otherAddress) {\n                        Object.keys(otherAddress).forEach(function(field){\n                            if (field === 'created_at' || field === 'updated_at'){\n                                searchedCustomer[defaultAddressPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(otherAddress[field]) || '';\n                            } else\n                                searchedCustomer[otherAddressPrefix + field] = otherAddress[field] || '';\n                        }, this);\n                    }\n\n                } else if (key != 'default_address') {\n                    // if normal details other than address \n                    if(key === 'created_at' || key === 'updated_at')\n                        searchedCustomer[key] = utils.libDate.parseJSDateTimeToStandardString(customerBody[key]) || '';\n                    else \n                        searchedCustomer[key]    =   customerBody[key] || '';\n                }\n                \n                retObj['status'] = \"SUCCESS\";\n                retObj['data'] = { parsedValues: searchedCustomer };\n\n            }, this);\n        } else {\n            searchedCustomer['found']   = \"No\";\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { parsedValues: searchedCustomer };\n        }\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if(response['statusCode'] && response['statusCode'] == 404) {\n            retObj.status = 'SUCCESS'\n            retObj.data = {\n                parsedValues: {\n                    found: 'No'\n                }\n            }\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    } \n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
			"params": [
				{
					"fixedValueSource": [],
					"name": "Email Address",
					"id": "email",
					"inputType": "input",
					"type": "String",
					"groupType": "OR_REQUIRED",
					"groupName": "Customer"
				},
				{
					"fixedValueSource": [],
					"name": "Customer Id",
					"id": "id",
					"inputType": "input",
					"type": "String",
					"groupType": "OR_REQUIRED",
					"groupName": "Customer"
				},
				{
					"fixedValueSource": [],
					"name": "Customer Name",
					"id": "name",
					"description": "Provide full name of customer",
					"inputType": "input",
					"type": "String",
					"groupType": "OR_REQUIRED",
					"groupName": "Customer"
				}
			],
			"responseFields": [
				{
					"name": "Match Found?",
					"id": "found",
					"type": "String"
				},
				{
					"name": "Customer ID",
					"id": "id",
					"description": "Shopify id of the customer",
					"type": "String"
				},
				{
					"name": "First Name",
					"id": "first_name",
					"type": "String"
				},
				{
					"name": "Last Name",
					"id": "last_name",
					"type": "String"
				},
				{
					"name": "Email Address",
					"id": "email",
					"description": "Email address of customer",
					"type": "String"
				},
				{
					"name": "Tags",
					"id": "tags",
					"type": "String"
				},
				{
					"name": "Note",
					"id": "note",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Account State",
					"id": "state",
					"description": "State of the customer account in shop",
					"type": "String"
				},
				{
					"name": "Total spending",
					"id": "total_spent",
					"description": "The total money that the customer has spent at the shop",
					"type": "String"
				},
				{
					"name": "Verified Email",
					"id": "verified_email",
					"type": "String"
				},
				{
					"name": "Default Address ID",
					"id": "default_address_id",
					"type": "String"
				},
				{
					"name": "Default Address First Name",
					"id": "default_address_first_name",
					"type": "String"
				},
				{
					"name": "Default Address Last Name",
					"id": "default_address_last_name",
					"type": "String"
				},
				{
					"name": "Default Address Name",
					"id": "default_address_name",
					"type": "String"
				},
				{
					"name": "Default Address line 1",
					"id": "default_address_address1",
					"type": "String"
				},
				{
					"name": "Default Address line 2",
					"id": "default_address_address2",
					"type": "String"
				},
				{
					"name": "Default Address Company",
					"id": "default_address_company",
					"type": "String"
				},
				{
					"name": "Default Address City",
					"id": "default_address_city",
					"type": "String"
				},
				{
					"name": "Default Address Phone",
					"id": "default_address_phone",
					"type": "String"
				},
				{
					"name": "Default Address Province",
					"id": "default_address_province",
					"type": "String"
				},
				{
					"name": "Default Address Country",
					"id": "default_address_country",
					"type": "String"
				},
				{
					"name": "Default Address Province Code",
					"id": "default_address_zip",
					"type": "String"
				},
				{
					"name": "Default Address Country Code",
					"id": "default_address_country_code",
					"type": "String"
				},
				{
					"name": "Default Address Country Name",
					"id": "default_address_country_name",
					"type": "String"
				},
				{
					"name": "Second Address ID",
					"id": "second_address_id",
					"type": "String"
				},
				{
					"name": "Second Address First Name",
					"id": "second_address_first_name",
					"type": "String"
				},
				{
					"name": "Second Address Last Name",
					"id": "second_address_last_name",
					"type": "String"
				},
				{
					"name": "Second Address Name",
					"id": "second_address_name",
					"type": "String"
				},
				{
					"name": "Second Address line 1",
					"id": "second_address_address1",
					"type": "String"
				},
				{
					"name": "Second Address line 2",
					"id": "second_address_address2",
					"type": "String"
				},
				{
					"name": "Second Address Company",
					"id": "second_address_company",
					"type": "String"
				},
				{
					"name": "Second Address City",
					"id": "second_address_city",
					"type": "String"
				},
				{
					"name": "Second Address Phone",
					"id": "second_address_phone",
					"type": "String"
				},
				{
					"name": "Second Address Province",
					"id": "second_address_province",
					"type": "String"
				},
				{
					"name": "Second Address Country",
					"id": "second_address_country",
					"type": "String"
				},
				{
					"name": "Second Address Province Code",
					"id": "default_address_zip",
					"type": "String"
				},
				{
					"name": "Second Address Country Code",
					"id": "second_address_country_code",
					"type": "String"
				},
				{
					"name": "Second Address Country Name",
					"id": "second_address_country_name",
					"type": "String"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e525c",
			"id": "search-order",
			"name": "Search an order",
			"description": "Search an Order based on Order Id or Customer Email",
			"important": true,
			"priority": 3,
			"beta": true,
			"entity": "product",
			"actionRequest": "function actionRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  if (!params.params || (!params.params.order_id && !params.params.customer_email)) {\n    retObj.status = 'SUCCESS'\n    retObj.data = {\n        response: {\n            found: 'NO'\n        }\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const options = {\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    json: true\n  }\n\n  if (params.params.order_id) {//search by order id\n\n    options.url = `https://${shopUrl}/admin/orders/${params.params.order_id}.json`\n\n  } else { //search by customer email\n    if (params.step && params.step.fetchOrder) {\n      options.url = `https://${shopUrl}/admin/orders/${params.step.order_id}.json`\n    } else {\n      options.url = `https://${shopUrl}/admin/customers/search.json`\n      options.qs = {\n        query: `email:${params.params.customer_email}`\n      }\n      retObj.step = {\n        fetchCustomer: true\n      }\n    }\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n    retObj.status = 'SUCCESS'\n    retObj.data = {\n      parsedValues: {\n        found: 'No'\n      }\n    }\n    if (params.step && params.step.fetchCustomer) {\n      if (body && body.customers && body.customers.length) {\n        if (body.customers[0].last_order_id) {\n          retObj.step = {\n            fetchOrder: true,\n            order_id: body.customers[0].last_order_id\n          }\n        }\n      }\n    } else {\n      if (body && body.order) {\n        retObj.data = parseOrder(body.order)\n      }\n    }\n\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 404) {\n      retObj.status = 'SUCCESS'\n      retObj.data = {\n        parsedValues: {\n          found: 'No'\n        }\n      }\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n\n  function parseOrder(order) {\n    let parsedOrder = {\n      parsedValues: {\n        found: 'Yes'\n      }\n    }\n\n    let newOrderObj = {}\n    let newOrder = {}\n    let customerData = {}\n    let orderData = {}\n\n    let BillingAddressPrefix = 'billing_address_';\n    let shippingAddressPrefix = 'shipping_address_';\n    let customerPrefix = 'customer_'\n\n    let maxItemScan = 5\n\n    const responseKeys = Object.keys(order)\n\n    if (responseKeys.length) {\n      // iterating each key of the order related data json\n      responseKeys.forEach(function (key) {\n\n        if (key === 'line_items') {\n\n          //creating comma separated list of all line item names and ids\n\n          let accumulated = null\n\n          accumulated = order[key].reduce((acc, value) => {\n            acc.line_item_ids.push(value.id ? value.id : '')\n            acc.line_item_names.push(value.name ? value.name : '')\n            acc.line_item_product_codes.push(value.product_id ? value.product_id : '')\n            acc.line_item_titles.push(value.title ? value.title : '')\n            acc.line_item_variant_ids.push(value.variant_id ? value.variant_id : '')\n            acc.line_item_variant_titles.push(value.variant_title ? value.variant_title : '')\n            acc.line_item_quantities.push(value.quantity ? value.quantity : '')\n            acc.line_item_prices.push(value.price ? value.price : '')\n            acc.line_item_skus.push(value.sku ? value.sku : '')\n            acc.line_item_weights.push(value.grams ? value.grams : '')\n\n            return acc\n          }, {\n              line_item_ids: [],\n              line_item_names: [],\n              line_item_product_codes: [],\n              line_item_titles: [],\n              line_item_variant_ids: [],\n              line_item_variant_titles: [],\n              line_item_quantities: [],\n              line_item_prices: [],\n              line_item_skus: [],\n              line_item_weights: []\n            }\n          )\n\n          Object.keys(accumulated).forEach(prop => {\n            let fld = prop\n            let data = accumulated[prop]\n\n            if (data && data.length) {\n              newOrder[fld] = data.toString()\n            }\n          })\n\n          order[key].some(function (element, index) {\n            // deciding the prefix for items\n            const prefix = ['first_item_', 'second_item_', 'third_item_', 'fourth_item_', 'fifth_item_']\n\n            Object.keys(element).forEach(function (field) {\n              if (field != 'properties' && field != 'tax_lines')\n                newOrder[prefix[index] + field] = element[field] || '';\n            }, this);\n\n            // returning after maximum scanning of 3 items of orders\n            return maxItemScan === index + 1;\n          }, this);\n\n        } else if (key === 'billing_address' || key === 'shipping_address' || key === 'customer') {\n          // extracting the basic info of customer \n          if (key === 'customer') {\n            Object.keys(order[key]).forEach(function (field) {\n\n              if (field === 'created_at' || field === 'updated_at')\n                customerData[customerPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(order[key][field]) || '';\n              else if (field != 'default_address')\n                customerData[customerPrefix + field] = order[key][field] || '';\n\n            }, this);\n          } else {\n            // extracting the billing and shipping address of order\n            var prefix = (key === 'billing_address') ? BillingAddressPrefix : shippingAddressPrefix;\n\n            Object.keys(order[key]).forEach(function (field) {\n              newOrder[prefix + field] = order[key][field] || '';\n            }, this);\n          }\n\n        } else if (key === 'shipping_lines') {\n          let shipping_lines = order[key]\n          let selectFields = {\n            title: true,\n            price: true,\n            source: true,\n            phone: true,\n            carrier_identifier: true\n          }\n\n          if (shipping_lines && shipping_lines.length) {\n\n            Object.keys(shipping_lines[0]).forEach(field => {\n              let data = shipping_lines[0][field]\n\n              if (selectFields[field] && data) {\n                orderData[`shipping_line_${field}`] = data\n              }\n\n            })\n          }\n\n        } else if (key != 'refunds' && key != 'fulfillments' && key != 'tax_lines'\n          && key != 'discount_codes' && key != 'note_attributes' && key != 'payment_gateway_names') {\n\n          // standard format of date\n          if (key === 'created_at' || key === 'updated_at' || key === 'processed_at')\n            orderData[key] = utils.libDate.parseJSDateTimeToStandardString(order[key]) || '';\n          else\n            orderData[key] = order[key] || '';\n          // extracting all the other non nested keys\n        }\n      }, this);\n\n      //parsing custom fields\n      const noteAttributes = order.note_attributes\n\n      if (noteAttributes && Array.isArray(noteAttributes) && noteAttributes.length) {\n        noteAttributes\n          .forEach(attr => {\n            if (attr.name && attr.value) {\n              const key = `additional_details_${utils.libText.encodeKey(attr.name)}`\n              newOrderObj[key] = attr.value\n            }\n          })\n      }\n\n      const lineItems = order.line_items.slice(0, 5)\n\n      if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n\n        const indexMapping = ['first', 'second', 'third', 'fourth', 'fifth']\n        lineItems\n          .forEach((item, index) => {\n            const properties = item.properties\n            if (properties && Array.isArray(properties) && properties.length) {\n              properties.forEach(prop => {\n                if (prop.name && prop.value) {\n                  newOrderObj[`${indexMapping[index]}_item_property_${utils.libText.encodeKey(prop.name)}`] = prop.value\n                }\n              })\n            }\n          })\n      }\n\n      const discountCodes = order.discount_codes\n\n      if (discountCodes && Array.isArray(discountCodes) && discountCodes.length) {\n        newOrderObj.discount_codes = discountCodes\n          .map(dc => dc.code)\n          .toString()\n      }\n\n      const landingSite = order.landing_site\n\n      if (landingSite) {\n        let utmParams = {}\n        const splitUrl = landingSite.split('?')\n        if (splitUrl[1]) {\n          utmParams = splitUrl[1]\n            .split('&')\n            .reduce((acc, next) => {\n              const splitParams = next.split('=')\n              if (splitParams && splitParams.length === 2) {\n                acc[splitParams[0]] = splitParams[1]\n              }\n              return acc\n            }, {})\n        }\n        if (Object.keys(utmParams).length) {\n          Object.keys(utmParams)\n            .forEach(key => {\n              newOrderObj[`campaign_${key}`] = utmParams[key]\n            })\n        }\n      }\n      // reordering the JSON data\n\n      parsedOrder.parsedValues = Object.assign({}, parsedOrder.parsedValues, orderData, customerData, newOrder, newOrderObj)\n\n    } else {\n      parsedOrder.parsedValues.found = 'No'\n    }\n\n    return parsedOrder\n  }//end parseCustomer\n}",
			"params": [
				{
					"fixedValueSource": [],
					"id": "order_id",
					"name": "Order Id",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "OR_REQUIRED",
					"groupName": "Search based on"
				},
				{
					"fixedValueSource": [],
					"id": "customer_email",
					"name": "Customer Email",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "OR_REQUIRED",
					"groupName": "Search based on"
				}
			],
			"dynamicResponseFields": true,
			"dynamicResponseFieldsRequest": "function dynamicResponseFieldsRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/orders.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      limit: 20,\n      status: 'any',\n      fields: 'line_items,note_attributes,name'\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"dynamicResponseFieldsParse": "function dynamicResponseFieldsParse(params, utils, callback) {\n  const retObj = {}\n  const capitalize = word => word[0].toUpperCase() + word.slice(1, word.length).toLowerCase()\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n\n    retObj.status = 'SUCCESS'\n    retObj.data = []\n\n    if (body && body.orders && body.orders.length) {\n      const responseObjArray = []\n      const noteAtrrObj = {}\n      const propObj = {}\n\n      body.orders\n        .forEach(order => {\n          //note atrributes\n          const note_attributes = order.note_attributes\n          if (note_attributes && Array.isArray(note_attributes) && note_attributes.length) {\n            note_attributes\n              .forEach(attr => {\n                if (attr.name) {\n                  noteAtrrObj[attr.name] = attr.value || ''\n                }\n              })\n          }\n          //end note attributes\n\n          //line item properties\n          const lineItems = order.line_items\n          if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n            lineItems\n              .forEach(line => {\n                const props = line.properties\n                if (props && Array.isArray(props) && props.length) {\n                  props.forEach(prop => {\n                    if (prop.name) {\n                      propObj[prop.name] = prop.value || ''\n                    }\n                  })\n                }\n              })\n          }\n        })\n\n      Object.keys(noteAtrrObj)\n        .forEach(key => {\n          responseObjArray.push({\n            id: `additional_details_${utils.libText.encodeKey(key)}`,\n            name: `Additional Details ${key}`\n          })\n        })\n\n      if (Object.keys(propObj).length) {\n        ['first', 'second', 'third', 'fourth', 'fifth'].forEach(lineNum => {\n          Object.keys(propObj)\n            .forEach(key => {\n              responseObjArray.push({\n                id: `${lineNum}_item_property_${utils.libText.encodeKey(key)}`,\n                name: `${capitalize(lineNum)} Item Property ${key}`\n              })\n            })\n        })\n      }\n\n      retObj.data = responseObjArray\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"responseFields": [
				{
					"id": "found",
					"name": "Match Found?",
					"type": "String"
				},
				{
					"name": "Order ID",
					"id": "id",
					"description": "Shopify id of the order",
					"type": "String"
				},
				{
					"name": "Order Name",
					"id": "name",
					"type": "String"
				},
				{
					"name": "Email Address",
					"id": "email",
					"description": "Email address of customer",
					"type": "String"
				},
				{
					"name": "Closed At",
					"id": "closed_at",
					"description": "The date and time when the order was closed",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Shop Number",
					"id": "number",
					"description": "Unique identifier of the shop",
					"type": "String"
				},
				{
					"name": "Note",
					"id": "note",
					"type": "String"
				},
				{
					"name": "Token",
					"id": "token",
					"description": "Unique identifier for a particular order",
					"type": "String"
				},
				{
					"id": "discount_codes",
					"name": "Discount Codes Applied",
					"description": "comma seperated list of all discount codes applied"
				},
				{
					"name": "Total Price",
					"id": "total_price",
					"description": "The sum of prices of all the items in the order, taxes and discounts included",
					"type": "String"
				},
				{
					"name": "Subtotal Price",
					"id": "subtotal_price",
					"description": "Price of the order before shipping and taxes",
					"type": "String"
				},
				{
					"name": "Total Weight",
					"id": "total_weight",
					"description": "The sum of all the weights of the line items in the order(grams)",
					"type": "String"
				},
				{
					"name": "Tax Included",
					"id": "taxes_included",
					"description": "whether or not taxes are included in the order subtotal",
					"type": "String"
				},
				{
					"name": "Total Tax",
					"id": "total_tax",
					"type": "String"
				},
				{
					"name": "Currency",
					"id": "currency",
					"type": "String"
				},
				{
					"name": "Financial Status",
					"id": "financial_status",
					"type": "String"
				},
				{
					"name": "Confirmation Status",
					"id": "confirmed",
					"type": "String"
				},
				{
					"name": "Total Discounts",
					"id": "total_discounts",
					"type": "String"
				},
				{
					"name": "Total Line Item Price",
					"id": "total_line_items_price",
					"description": "The sum of all the prices of all the items in the order",
					"type": "String"
				},
				{
					"name": "Cart Token",
					"id": "cart_token",
					"description": "Unique token of cart attached to order",
					"type": "String"
				},
				{
					"name": "Buyer Accepts Marketing",
					"id": "buyer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Referring Site",
					"id": "referring_site",
					"description": "The website that the customer clicked on to come to the shop",
					"type": "String"
				},
				{
					"name": "Landing Site",
					"id": "landing_site",
					"description": "The URL for the page where the buyer landed when entering the shop",
					"type": "String"
				},
				{
					"name": "Total Price In USD",
					"id": "total_price_usd",
					"type": "String"
				},
				{
					"name": "User ID",
					"id": "user_id",
					"description": "The unique numerical identifier for the user logged into the terminal at the time the order was processed at POS",
					"type": "String"
				},
				{
					"name": "Location ID",
					"id": "location_id",
					"description": "The unique numeric identifier for the physical location of POS at which the order is created",
					"type": "String"
				},
				{
					"name": "Processing Date And Time",
					"id": "processed_at",
					"type": "String"
				},
				{
					"name": "Browser IP Address",
					"id": "browser_ip",
					"description": "IP address of the browser used by customer at the time of placing pf order",
					"type": "String"
				},
				{
					"name": "Order Number",
					"id": "order_number",
					"description": "Unique order number to be used by shop owners and customers",
					"type": "String"
				},
				{
					"name": "Processing Method",
					"id": "processing_method",
					"description": "Valid methods are: checkout, direct, manual, offsite or express",
					"type": "String"
				},
				{
					"id": "checkout_id",
					"name": "Order Checkout Id"
				},
				{
					"id": "checkout_token",
					"name": "Order Checkout Token"
				},
				{
					"id": "phone",
					"name": "Order Phone"
				},
				{
					"id": "customer_locale",
					"name": "Order Customer Locale"
				},
				{
					"id": "gateway",
					"name": "Order Payment Gateway"
				},
				{
					"name": "Order Fulfillment Status",
					"id": "fulfillment_status",
					"type": "String"
				},
				{
					"name": "Source Name",
					"id": "source_name",
					"description": "Source of the creation of order, example: shopify_draft_order, web etc",
					"type": "String"
				},
				{
					"name": "Tags",
					"id": "tags",
					"type": "String"
				},
				{
					"name": "Contact Email Address",
					"id": "contact_email",
					"type": "String"
				},
				{
					"name": "Order Status URL",
					"id": "order_status_url",
					"description": "The url pointing to the checkout accessible from the web",
					"type": "String"
				},
				{
					"id": "additional_details",
					"name": "Order Additional Details"
				},
				{
					"name": "Customer ID",
					"id": "customer_id",
					"type": "String"
				},
				{
					"name": "Customer First Name",
					"id": "customer_first_name",
					"type": "String"
				},
				{
					"name": "Customer Last Name",
					"id": "customer_last_name",
					"type": "String"
				},
				{
					"name": "Customer Email Address",
					"id": "customer_email",
					"type": "String"
				},
				{
					"name": "Customer Phone Number",
					"id": "customer_phone",
					"type": "String"
				},
				{
					"name": "Customer Accepts Marketing",
					"id": "customer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Customer Creation Date And Time",
					"id": "customer_created_at",
					"type": "String"
				},
				{
					"name": "Customer Updation Date And Time",
					"id": "customer_updated_at",
					"type": "String"
				},
				{
					"name": "Customer Order Count",
					"id": "customer_orders_count",
					"type": "String"
				},
				{
					"name": "Customer Account State",
					"id": "customer_state",
					"type": "String"
				},
				{
					"name": "Customer Total Spendings",
					"id": "customer_total_spent",
					"type": "String"
				},
				{
					"name": "Customer Last Order ID",
					"id": "customer_last_order_id",
					"type": "String"
				},
				{
					"name": "Customer Note",
					"id": "customer_note",
					"type": "String"
				},
				{
					"name": "Customer Email Verified",
					"id": "customer_verified_email",
					"type": "String"
				},
				{
					"name": "Customer Tax Exempted",
					"id": "customer_tax_exempt",
					"type": "String"
				},
				{
					"name": "Customer Tags",
					"id": "customer_tags",
					"type": "String"
				},
				{
					"name": "Customer Last Order Name",
					"id": "customer_last_order_name",
					"type": "String"
				},
				{
					"name": "All Line Item Ids",
					"id": "line_item_ids",
					"type": "String",
					"description": "comma seperated list of line ids"
				},
				{
					"name": "All Line Item Product Codes",
					"id": "line_item_product_codes",
					"type": "String",
					"description": "comma seperated list of product codes"
				},
				{
					"name": "All Line Item Product Names",
					"id": "line_item_names",
					"type": "String",
					"description": "comma seperated list of product names"
				},
				{
					"name": "All Line Item Product Titles",
					"id": "line_item_titles",
					"type": "String",
					"description": "comma seperated list of product titles"
				},
				{
					"name": "All Line Item Product Variant Ids",
					"id": "line_item_variant_ids",
					"type": "String",
					"description": "comma seperated list of product variant ids"
				},
				{
					"name": "All Line Item Product Variant Titles",
					"id": "line_item_variant_titles",
					"type": "String",
					"description": "comma seperated list of product variant titles"
				},
				{
					"name": "All Line Item Quantities",
					"id": "line_item_quantities",
					"type": "String",
					"description": "comma seperated list of product quantities"
				},
				{
					"name": "All Line Item Prices",
					"id": "line_item_prices",
					"type": "String",
					"description": "comma seperated list of product unit prices"
				},
				{
					"name": "All Line Item Skus",
					"id": "line_item_skus",
					"type": "String",
					"description": "comma seperated list of product skus"
				},
				{
					"name": "All Line Item Product Weights",
					"id": "line_item_weights",
					"type": "String",
					"description": "comma seperated list of product weights"
				},
				{
					"name": "First Item ID",
					"id": "first_item_id",
					"type": "String"
				},
				{
					"name": "First Item Name",
					"id": "first_item_name",
					"type": "String"
				},
				{
					"name": "First Item Product ID",
					"id": "first_item_product_id",
					"type": "String"
				},
				{
					"name": "First Item Variant ID",
					"id": "first_item_variant_id",
					"type": "String"
				},
				{
					"name": "First Item Variant Title",
					"id": "first_item_variant_title",
					"type": "String"
				},
				{
					"name": "First Item Title",
					"id": "first_item_title",
					"type": "String"
				},
				{
					"name": "First Item Quantity",
					"id": "first_item_quantity",
					"type": "String"
				},
				{
					"name": "First Item Unit Price",
					"id": "first_item_price",
					"type": "String"
				},
				{
					"id": "first_item_sku",
					"name": "First Item SKU"
				},
				{
					"id": "first_item_grams",
					"name": "First Item Weight (grams)"
				},
				{
					"id": "first_item_gift_card",
					"name": "First Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "First Item Vendor",
					"id": "first_item_vendor",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Service",
					"id": "first_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "First Item Requires Shipping",
					"id": "first_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "First Item Taxable",
					"id": "first_item_taxable",
					"type": "String"
				},
				{
					"name": "First Item Exists",
					"id": "first_item_product_exists",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "First Item Total Discount",
					"id": "first_item_total_discount",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "first_item_properties",
					"name": "First Item Properties"
				},
				{
					"name": "Second Item ID",
					"id": "second_item_id",
					"type": "String"
				},
				{
					"name": "Second Item Name",
					"id": "second_item_name",
					"type": "String"
				},
				{
					"name": "Second Item Product ID",
					"id": "second_item_product_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant ID",
					"id": "second_item_variant_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant Title",
					"id": "second_item_variant_title",
					"type": "String"
				},
				{
					"name": "Second Item Title",
					"id": "second_item_title",
					"type": "String"
				},
				{
					"name": "Second Item Quantity",
					"id": "second_item_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Unit Price",
					"id": "second_item_price",
					"type": "String"
				},
				{
					"id": "second_item_sku",
					"name": "Second Item SKU"
				},
				{
					"id": "second_item_grams",
					"name": "Second Item Weight (grams)"
				},
				{
					"id": "second_item_gift_card",
					"name": "Second Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Second Item Vendor",
					"id": "second_item_vendor",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Service",
					"id": "second_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Second Item Requires Shipping",
					"id": "second_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Second Item Taxable",
					"id": "second_item_taxable",
					"type": "String"
				},
				{
					"name": "Second Item Exists",
					"id": "second_item_product_exists",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Total Discount",
					"id": "second_item_total_discount",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "second_item_properties",
					"name": "Second Item Properties"
				},
				{
					"name": "Third Item ID",
					"id": "third_item_id",
					"type": "String"
				},
				{
					"name": "Third Item Name",
					"id": "third_item_name",
					"type": "String"
				},
				{
					"name": "Third Item Product ID",
					"id": "third_item_product_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant ID",
					"id": "third_item_variant_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant Title",
					"id": "third_item_variant_title",
					"type": "String"
				},
				{
					"name": "Third Item Title",
					"id": "third_item_title",
					"type": "String"
				},
				{
					"name": "Third Item Quantity",
					"id": "third_item_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Unit Price",
					"id": "third_item_price",
					"type": "String"
				},
				{
					"id": "third_item_sku",
					"name": "Third Item SKU"
				},
				{
					"id": "third_item_grams",
					"name": "Third Item Weight (grams)"
				},
				{
					"id": "third_item_gift_card",
					"name": "Third Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Third Item Vendor",
					"id": "third_item_vendor",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Service",
					"id": "third_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Third Item Requires Shipping",
					"id": "third_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Third Item Taxable",
					"id": "third_item_taxable",
					"type": "String"
				},
				{
					"name": "Third Item Exists",
					"id": "third_item_product_exists",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Total Discount",
					"id": "third_item_total_discount",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "third_item_properties",
					"name": "Third Item Properties"
				},
				{
					"name": "Fourth Item ID",
					"id": "fourth_item_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Name",
					"id": "fourth_item_name",
					"type": "String"
				},
				{
					"name": "Fourth Item Product ID",
					"id": "fourth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant ID",
					"id": "fourth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant Title",
					"id": "fourth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Title",
					"id": "fourth_item_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Quantity",
					"id": "fourth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Unit Price",
					"id": "fourth_item_price",
					"type": "String"
				},
				{
					"id": "fourth_item_sku",
					"name": "Fourth Item SKU"
				},
				{
					"id": "fourth_item_grams",
					"name": "Fourth Item Weight (grams)"
				},
				{
					"id": "fourth_item_gift_card",
					"name": "Fourth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fourth Item Vendor",
					"id": "fourth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Service",
					"id": "fourth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fourth Item Requires Shipping",
					"id": "fourth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fourth Item Taxable",
					"id": "fourth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fourth Item Exists",
					"id": "fourth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Total Discount",
					"id": "fourth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fourth_item_properties",
					"name": "Fourth Item Properties"
				},
				{
					"name": "Fifth Item ID",
					"id": "fifth_item_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Name",
					"id": "fifth_item_name",
					"type": "String"
				},
				{
					"name": "Fifth Item Product ID",
					"id": "fifth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant ID",
					"id": "fifth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant Title",
					"id": "fifth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Title",
					"id": "fifth_item_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Quantity",
					"id": "fifth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Unit Price",
					"id": "fifth_item_price",
					"type": "String"
				},
				{
					"id": "fifth_item_sku",
					"name": "Fifth Item SKU"
				},
				{
					"id": "fifth_item_grams",
					"name": "Fifth Item Weight (grams)"
				},
				{
					"id": "fifth_item_gift_card",
					"name": "Fifth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fifth Item Vendor",
					"id": "fifth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Service",
					"id": "fifth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fifth Item Requires Shipping",
					"id": "fifth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fifth Item Taxable",
					"id": "fifth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fifth Item Exists",
					"id": "fifth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Total Discount",
					"id": "fifth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fifth_item_properties",
					"name": "Fifth Item Properties"
				},
				{
					"name": "Billing address First Name",
					"id": "billing_address_first_name",
					"type": "String"
				},
				{
					"name": "Billing address Last Name",
					"id": "billing_address_last_name",
					"type": "String"
				},
				{
					"name": "Billing Address Name",
					"id": "billing_address_name",
					"type": "String"
				},
				{
					"name": "Billing address Line 1",
					"id": "billing_address_address1",
					"type": "String"
				},
				{
					"name": "Billing address Line 2",
					"id": "billing_address_address2",
					"type": "String"
				},
				{
					"name": "Billing address Phone Number",
					"id": "billing_address_phone",
					"type": "String"
				},
				{
					"name": "Billing address City",
					"id": "billing_address_city",
					"type": "String"
				},
				{
					"name": "Billing address Zip",
					"id": "billing_address_zip",
					"type": "String"
				},
				{
					"name": "Billing address Province",
					"id": "billing_address_province",
					"type": "String"
				},
				{
					"name": "Billing address Country",
					"id": "billing_address_country",
					"type": "String"
				},
				{
					"name": "Billing address Company",
					"id": "billing_address_company",
					"type": "String"
				},
				{
					"name": "Billing address Country Code",
					"id": "billing_address_country_code",
					"type": "String"
				},
				{
					"name": "Billing address Province Code",
					"id": "billing_address_province_code",
					"type": "String"
				},
				{
					"name": "Shipping address First Name",
					"id": "shipping_address_first_name",
					"type": "String"
				},
				{
					"name": "Shipping address Last Name",
					"id": "shipping_address_last_name",
					"type": "String"
				},
				{
					"name": "Shipping Address Name",
					"id": "shipping_address_name",
					"type": "String"
				},
				{
					"name": "Shipping address Line 1",
					"id": "shipping_address_address1",
					"type": "String"
				},
				{
					"name": "Shipping address Line 2",
					"id": "shipping_address_address2",
					"type": "String"
				},
				{
					"name": "Shipping address Phone Number",
					"id": "shipping_address_phone",
					"type": "String"
				},
				{
					"name": "Shipping address City",
					"id": "shipping_address_city",
					"type": "String"
				},
				{
					"name": "Shipping address Zip",
					"id": "shipping_address_zip",
					"type": "String"
				},
				{
					"name": "Shipping address Province",
					"id": "shipping_address_province",
					"type": "String"
				},
				{
					"name": "Shipping address Country",
					"id": "shipping_address_country",
					"type": "String"
				},
				{
					"name": "Shipping address Company",
					"id": "shipping_address_company",
					"type": "String"
				},
				{
					"name": "Shipping address Country Code",
					"id": "shipping_address_country_code",
					"type": "String"
				},
				{
					"name": "Shipping address Province Code",
					"id": "shipping_address_province_code",
					"type": "String"
				},
				{
					"id": "shipping_line_title",
					"name": "Order Shipping Line Title"
				},
				{
					"id": "shipping_line_price",
					"name": "Order Shipping Line Price"
				},
				{
					"id": "shipping_line_source",
					"name": "Order Shipping Line Source"
				},
				{
					"id": "shipping_line_phone",
					"name": "Order Shipping Line Phone"
				},
				{
					"id": "shipping_line_carrier_identifier",
					"name": "Order Shipping Line Carrier Identifier"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e525b",
			"name": "Search a Product",
			"id": "search-product",
			"description": "Search for a Product",
			"priority": 3,
			"entity": "product",
			"actionRequest": "function actionRequest(params, utils, callback) {\n\n  var retObj          = {status: \"ERROR\"};\n  var requiredPresent = false;\n  var url             = '/admin/products.json';\n  var shopUrl;\n  var qs;\n  var fetchedParams;\n  var parameters;\n  var productID;\n  var productName;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!(params || {}).userapp || !(params || {}).appinfo) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['error']['message']  = \"Missing the userapp or appinfo params\";\n    callback(retObj);\n    return;\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // extracting parameters\n    parameters = params.params;\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    productID   = (parameters && parameters['id']) ? parameters['id'] : null;\n    productName = (parameters && parameters['title']) ? parameters['title'] : null;\n\n    // if any one of the values is present then it is OK\n    if(productID || productName)\n        requiredPresent = true;\n    \n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['error']['message']  = \"Missing access token in the fetched auth params\"; \n        callback(retObj);\n        return;\n\n    } else if (!parameters || requiredPresent === false) {\n        // checking for parameters\n        retObj.status = 'SUCCESS'\n        retObj.data = {\n            response: {\n                found: 'NO'\n            }\n        }\n        callback(retObj);\n        return;\n\n    } else {\n\n        if(productID)\n            url         = `/admin/products/${productID}.json`;\n        else if (productName)\n            qs = {title: productName}; \n\n        // compiling the options for searching prodcut for the given title of product\n        options = {\n            method: 'GET',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + url,\n            json: true\n        }\n        \n        if (!productID && productName){\n            options['qs']   = qs;\n            retObj['step']  =   {};\n            retObj['step']['value']  =   productName.toLowerCase();\n        }\n\n        retObj['status']        = \"SUCCESS\";\n        retObj['data']          = { options: options };\n    } \n  }\n  // final callback\n  callback(retObj);\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n\n  var retObj                 = {status: \"ERROR\"};\n  var countPostfix           = '_count';\n  var id                     = null;\n  var newProduct             = {};\n  var productBody;\n  var errorMessage;\n  var errors;\n  var response;\n  var responseKeys;\n  var parsedBody;\n  var body;\n\n  // if response and body are not present in params\n  if (!(params || {}).response || !(params || {}).body) {\n    retObj['error'] = {};\n    retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n    retObj['error']['message'] = \"Invalid/Missing API response\";\n\n    callback(retObj);\n    return;\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, successful search\n    if (response['statusCode'] && response['statusCode'] == '200' && parsedBody) {\n\n        // Extracting the matched product\n        if(parsedBody['product']){\n            productBody = parsedBody['product'];\n        } else if (parsedBody['products'] && parsedBody['products'].length) {\n\n            if (parsedBody['products'].length == 1)\n                productBody = parsedBody['products'][0];\n            else if (parsedBody['products'].length > 1 && params['step'] && params['step']['value'])\n                productBody = parsedBody['products'].find( p => p.title.toLowerCase() === params['step']['value']);\n            else if (parsedBody['products'].length > 1 && !params['step'] || !params['step']['value']){\n\n                retObj['error']         = {};\n                retObj['error']['code'] = \"ERROR_MISSING_PARAM\",\n                retObj['error']['message'] = \"Missing step data\";\n                return callback(retObj);\n            }\n        } else {\n            productBody = {};\n        }\n\n        // extracting the keys of response data of customer\n        responseKeys    = Object.keys(productBody);\n        \n        if (responseKeys.length) {\n\n            newProduct['found'] =  true;\n\n            // iterating each key of the order related data json\n            responseKeys.forEach(function (key) {\n\n                if (key === 'variants' || key === 'options') {\n                    \n                    newProduct[key + countPostfix] = productBody[key].length || '';\n\n                } else if (key === 'created_at' || key === 'updated_at' || key === 'published_at') {\n                    // conversion of date to a standard form\n                    newProduct[key] = utils.libDate.parseJSDateTimeToStandardString(productBody[key]) || '';\n\n                } else if (key === 'images' && productBody[key] && productBody[key].length){\n\n                    newProduct['product_image_url'] = productBody[key][0] && productBody[key][0]['src'] || ''\n\n                } else if (key != 'image' && key != 'images') {\n                    // extracting all the other non nested keys\n                    newProduct[key] = productBody[key] || '';\n                }\n            }, this);\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data']   = { parsedValues: newProduct };\n\n        } else {\n            newProduct['found'] =  false;\n            retObj['status'] = \"SUCCESS\";\n            retObj['data']   = { parsedValues: newProduct };\n        }\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if(response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n            retObj.data = {\n                parsedValues: {\n                    found: 'No'\n                }\n            }\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    } \n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
			"params": [
				{
					"fixedValueSource": [],
					"name": "Product Title",
					"id": "title",
					"inputType": "input",
					"type": "String",
					"required": false,
					"description": "Search based on Product title (exact match)",
					"groupType": "OR_REQUIRED",
					"groupName": "Product"
				},
				{
					"fixedValueSource": [],
					"name": "Product Id",
					"id": "id",
					"inputType": "input",
					"type": "String",
					"required": false,
					"groupType": "OR_REQUIRED",
					"groupName": "Product"
				}
			],
			"responseFields": [
				{
					"name": "Match Found?",
					"id": "found",
					"type": "String"
				},
				{
					"name": "Product ID",
					"id": "id",
					"type": "String"
				},
				{
					"name": "Product Title",
					"id": "title",
					"type": "String"
				},
				{
					"name": "Vendor",
					"id": "vendor",
					"type": "String"
				},
				{
					"name": "Type of Product",
					"id": "product_type",
					"type": "String"
				},
				{
					"name": "Product Image URL",
					"id": "product_image_url",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Published At",
					"id": "published_at",
					"type": "String"
				},
				{
					"name": "Published scope",
					"id": "published_scope",
					"description": "Indicates whether the product is published to the Point of Sale channel",
					"type": "String"
				},
				{
					"name": "Number Of Variants",
					"id": "variants_count",
					"type": "String"
				},
				{
					"name": "Number of options",
					"id": "options_count",
					"type": "String"
				},
				{
					"name": "Product Handle",
					"id": "handle",
					"description": "Unique string for the Product automatically generated from its title",
					"type": "String"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e525a",
			"id": "search-variant",
			"name": "Search a Product Variant",
			"description": "Search Product Variants based on title",
			"important": true,
			"priority": 3,
			"entity": "product",
			"beta": true,
			"actionRequest": "function actionRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n  const options = {\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    json: true\n  }\n\n  if (!params.params.variant_id) {\n    if (params.params.title && params.params.product_id) {\n\n      options.url = `https://${shopUrl}/admin/products/${params.params.product_id}/variants.json`\n\n      options.qs = {\n        limit: 250\n      }\n\n      retObj.step = {\n        searchByTitle: true,\n        variant_title: params.params.title\n      }\n\n    } else {\n      retObj.status = 'SUCCESS'\n      retObj.data = {\n        response: {\n          found: 'NO'\n        }\n      }\n      return callback(retObj)\n    }\n  } else { //variant id is present\n    options.url = `https://${shopUrl}/admin/variants/${params.params.variant_id}.json`\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n    retObj.status = 'SUCCESS'\n    retObj.data = {\n      parsedValues: {\n        found: 'No'\n      }\n    }\n    if (params.step && params.step.searchByTitle) {\n      if (body.variants && body.variants.length) {\n        const variantTitle = params.step && params.step.variant_title || ''\n        const searchedVariant = body.variants.find(variant => variant.title === variantTitle)\n        if (searchedVariant) {\n          retObj.status = 'SUCCESS'\n          retObj.data = {\n            parsedValues: parseVariant(searchedVariant)\n          }\n        }\n      }\n    } else {\n      if (body && body.variant) {\n        retObj.status= 'SUCCESS'\n        retObj.data = {\n          parsedValues: parseVariant(body.variant)\n        }\n      }\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 404) {\n      retObj.status = 'SUCCESS'\n      retObj.data = {\n        parsedValues: {\n          found: 'No'\n        }\n      }\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n\n  function parseVariant(variant) {\n    const parsedVariant = {\n      found: 'Yes'\n    }\n\n    const ignoreFields = {\n      admin_graphql_api_id: true,\n      option2: true,\n      option3: true\n    }\n\n    const dateFields = {\n      created_at: true,\n      updated_at: true\n    }\n\n    Object.keys(variant)\n      .forEach(key => {\n        const data = variant[key]\n        if (!ignoreFields[key]) {\n          if (dateFields[key] && data) {\n            parsedVariant[key] = utils.libDate.parseJSDateTimeToStandardString(new Date(data))\n          } else {\n            parsedVariant[key] = data\n          }\n        }\n      })\n\n    return parsedVariant\n  }//end parseVariant\n\n}",
			"params": [
				{
					"fixedValueSource": [],
					"id": "found",
					"name": "Match Found?",
					"type": "String"
				},
				{
					"fixedValueSource": [],
					"id": "variant_id",
					"name": "Search by Variant Id",
					"inputType": "input",
					"type": "String",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "product_id",
					"name": "Product",
					"type": "String",
					"inputType": "select",
					"dynamicValueSourceRequest": "function dynamicValueSourceRequest(params, utils, callback) {\n\n    var productIdUrl  = '/admin/products.json?fields=id,title,limit=200';\n    var retObj        = {status: \"ERROR\"};\n    var shopUrl;\n    var userapp;\n    var options;\n    var fetchedParams;\n\n  // if appinfo or userapp are not present in params\n    if (!params || !params['appinfo'] || !params['userapp']) {\n        retObj['status'] = \"ERROR\";\n        retObj['error'] = {};\n        retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing\";\n\n    } else {\n        userapp = params['userapp'];\n        // fetch the auth params for given userapp\n        fetchedParams = userapp.fetchAuthParams(params['appinfo']);\n         // fetching the shop url\n        shopUrl =  userapp['params'].find(p => p.id === 'shop');\n\n        options = {\n            method: 'GET',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + productIdUrl,\n            json: true,\n        };\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = {\n            options: options\n        };\n    }\n    callback(retObj);\n}",
					"dynamicValueSourceParse": "function dynamicValueSourceParse(params, utils, callback) {\n\n    var retObj      = {status: \"ERROR\"};\n    var products;\n    var errors;\n    var errorMessage;\n\n    // if response or body are not present in params\n    if (!params || !params['response'] || !params['body']) {\n        retObj['error']            = {};\n        retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing.\";\n\n    } else {\n\n        let response = params.response\n\n        if (params['response']['statusCode'] == 200) {\n            // Extracting the products array\n            products = params['body']['products'];\n\n           // if any product returned from \n            if (products && products instanceof Array && products.length) {\n\n                var optionsArray = [];\n                // creating a option for each product\n                products.forEach(function(element){\n                    // if title and id exists for the product\n                    if(element['id'] && element['title'])\n                    optionsArray.push({\n                        name: element['title'],\n                        id  : element['id'] \n                    });\n                });\n                retObj['status'] = \"SUCCESS\";\n                retObj['data']   = optionsArray;\n            } else {\n                retObj.status = 'SUCCESS'\n                retObj.data = []\n            }\n        } else {\n            // when error data present, flattening the object\n            errors   =  params['body']['errors']; \n            if(errors){\n                errorMessage = '';\n                if(typeof errors == 'string')\n                    errorMessage  = errors;\n                else {\n                    Object.keys(errors).forEach(function(key){\n                        errorMessage += key + ': ';\n                        if(errors[key] && errors[key] instanceof Array)\n                            errorMessage += errors[key].join(',');\n                        else if(typeof errors[key] == 'string')\n                            errorMessage += errors[key];\n                        else \n                            errorMessage += errors[key];\n                        errorMessage += ', ';\n                    });\n                } \n            } \n            if (response['statusCode'] && response['statusCode'] == '401') {\n                // when oauth errors occurs because of wrong access token\n                retObj['error'] = {\n                    code    : 'ERROR_AUTH',\n                    message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n                };\n\n            } else if (response['statusCode'] && response['statusCode'] == '429') {\n                // when rate limit occurs \n                retObj['error'] = {\n                    code    : 'ERROR_RATE_LIMIT',\n                    message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n                };\n\n            } else if (response['statusCode']){\n                // for all the other errors\n                retObj['error'] = {\n                    code    : 'ERROR_UNKNOWN',\n                    message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n                };\n            }\n        }\n    }\n    callback(retObj);\n}",
					"required": false,
					"description": "If you are searching by variant title, please provide a product id",
					"searchAction": "search-product",
					"searchID": "id",
					"groupType": "COLLECTION",
					"groupName": "Search by Variant Title"
				},
				{
					"fixedValueSource": [],
					"id": "title",
					"name": "Variant Title",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Search by Variant Title"
				}
			],
			"responseFields": [
				{
					"id": "found",
					"name": "Found",
					"description": "has value Yes or No"
				},
				{
					"id": "id",
					"name": "Variant Id"
				},
				{
					"id": "product_id",
					"name": "Variant Product Id"
				},
				{
					"id": "title",
					"name": "Variant Title"
				},
				{
					"id": "price",
					"name": "Variant Price"
				},
				{
					"id": "sku",
					"name": "Variant SKU"
				},
				{
					"id": "position",
					"name": "Variant Position"
				},
				{
					"id": "inventory_policy",
					"name": "Allow customers to purchase this product when it's out of stock?",
					"description": "has value continue or deny"
				},
				{
					"id": "compare_at_price",
					"name": "Variant Compare At Price"
				},
				{
					"id": "fulfillment_service",
					"name": "Variant Fulfillment Service"
				},
				{
					"id": "inventory_management",
					"name": "Inventory Policy"
				},
				{
					"id": "option1",
					"name": "Variant Option 1"
				},
				{
					"id": "created_at",
					"name": "Variant Created At"
				},
				{
					"id": "updated_at",
					"name": "Variant Updated At"
				},
				{
					"id": "taxable",
					"name": "Variant Taxable?",
					"description": "has value true or false"
				},
				{
					"id": "barcode",
					"name": "Variant Barcode Value"
				},
				{
					"id": "grams",
					"name": "Variant Grams"
				},
				{
					"id": "image_id",
					"name": "Variant Image Id"
				},
				{
					"id": "inventory_quantity",
					"name": "Variant Inventory Quantity"
				},
				{
					"id": "weight",
					"name": "Variant Weight"
				},
				{
					"id": "weight_unit",
					"name": "Variant Weight Unit"
				},
				{
					"id": "inventory_item_id",
					"name": "Variant Inventory Item Id"
				},
				{
					"id": "old_inventory_quantity",
					"name": "Variant Old Inventory Quantity"
				},
				{
					"id": "requires_shipping",
					"name": "Variant Requies Shipping?",
					"description": "has value true or false"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e5259",
			"id": "tag-customer",
			"name": "Tag a Customer",
			"description": "Add Tags to an existing Customer",
			"important": true,
			"priority": 3,
			"beta": true,
			"entity": "product",
			"actionRequest": "function actionRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  if (!params.params || !params.params.customer_id || !params.params.tags) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'required params customer id or tags are missing',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const body = {\n    customer: {}\n  }\n\n  const url = `https://${shopUrl}/admin/customers/${params.params.customer_id}.json`\n  const options = {\n    url,\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    json: true\n  }\n\n  if (params.step && params.step.tagCustomer) {\n\n    const existingTags = params.step.tags\n    const inputTags = params.params.tags\n      .map(tag => tag.value)\n      .toString()\n\n    const newTags = `${existingTags},${inputTags}`\n\n    body.customer.tags = newTags\n\n    options.body = body\n    options.method = 'PUT'\n\n  } else {\n    options.method = 'GET'\n    options.qs = {\n      fields: 'tags'\n    }\n    retObj.step = {\n      fetchCustomer: true\n    }\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n    retObj.status = 'SUCCESS'\n    if (params.step && params.step.fetchCustomer) {\n      retObj.step = {\n        tagCustomer: true,\n        tags: body.customer && body.customer.tags || ''\n      }\n    } else {\n      retObj.data = {\n        parsedValues: {\n          customer_id: body.customer.id\n        }\n      }\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else if (response.statusCode === 404) {\n      retObj.error = {\n        message: 'customer to tag, not found'\n      }\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"params": [
				{
					"fixedValueSource": [],
					"id": "customer_id",
					"name": "Customer Id",
					"type": "String",
					"inputType": "input",
					"required": true,
					"searchAction": "search-customer",
					"searchID": "id"
				},
				{
					"fixedValueSource": [],
					"id": "tags",
					"name": "Tags",
					"type": "String",
					"inputType": "multiinput",
					"required": true
				}
			],
			"responseFields": [
				{
					"id": "customer_id",
					"name": "Tagged Customer Id"
				}
			]
		},
		{
			"dynamicInputFieldsDependsOn": [],
			"dynamicResponseFieldsDependsOn": [],
			"_id": "5e4e54f48608ad286b4e5258",
			"id": "update-variant",
			"name": "Update Product Variant",
			"description": "Updates an existing Product Variant",
			"important": true,
			"priority": 3,
			"beta": true,
			"entity": "product",
			"actionRequest": "function actionRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  if (!params.params || !params.params.id) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'required param variant id is missing',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  if (params.params.available && params.params.location_id) {\n    retObj.step = {\n      fetchInventoryId: true\n    }\n  }\n\n  params.params.inventory_management = 'shopify'\n\n  const variant = {}\n\n  Object.keys(params.params)\n    .forEach(key => {\n      if (key !== 'amount' && key !== 'location_id') {\n        variant[key] = params.params[key]\n      }\n    })\n\n  const options = {\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    json: true\n  }\n\n  if (params.step && params.step.setQuantity) {\n\n    options.url = `https://${shopUrl}/admin/inventory_levels/set.json`\n    options.body = {\n      \"location_id\": params.params.location_id,\n      \"inventory_item_id\": params.step.inventory_item_id,\n      \"available\": params.params.available\n    }\n    options.method = 'POST'\n    retObj.step = {\n      variant_id: params.step.variant_id\n    }\n\n  } else {\n\n    options.url = `https://${shopUrl}/admin/variants/${params.params.id}.json`\n    options.method = 'PUT'\n    options.body = {\n      variant\n    }\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"actionParse": "function actionParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 201 || response.statusCode === 200) {\n    retObj.status = 'SUCCESS'\n    if (body.variant) {\n      if (params.step && params.step.fetchInventoryId) {\n        retObj.step = {\n          setQuantity: true,\n          inventory_item_id: body.variant.inventory_item_id || '',\n          variant_id: body.variant.id\n        }\n      } else {\n        retObj.data = {\n          parsedValues: {\n            variant_id: body.variant.id\n          }\n        }\n      }\n    } else {\n        retObj.data = {\n          parsedValues: {\n            variant_id: params.step.variant_id\n          }\n        }\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 404) {\n      retObj.status = 'ERROR'\n      retObj.error = {\n        message: 'variant to update, not found'\n      }\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"params": [
				{
					"fixedValueSource": [],
					"id": "id",
					"name": "Variant",
					"type": "String",
					"inputType": "input",
					"required": true,
					"searchID": "id",
					"searchAction": "search-variant"
				},
				{
					"fixedValueSource": [],
					"id": "option1",
					"name": "Title",
					"type": "String",
					"inputType": "input",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "price",
					"name": "Price",
					"type": "String",
					"inputType": "input",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "compare_at_price",
					"name": "Compare at Price",
					"type": "String",
					"inputType": "input",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "sku",
					"name": "SKU",
					"type": "String",
					"inputType": "input",
					"required": false
				},
				{
					"fixedValueSource": [],
					"id": "available",
					"name": "Inventory Quantity",
					"type": "String",
					"inputType": "input",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Set Quantity"
				},
				{
					"fixedValueSource": [],
					"id": "location_id",
					"name": "Inventory Location",
					"type": "String",
					"description": "Please select a location to set inventory quantity",
					"inputType": "select",
					"dynamicValueSourceRequest": "function dynamicValueSourceRequest(params, utils, callback) {\n\n  var productIdUrl  = '/admin/locations.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var userapp;\n  var options;\n  var fetchedParams;\n\n// if appinfo or userapp are not present in params\n  if (!params || !params['appinfo'] || !params['userapp']) {\n      retObj['status'] = \"ERROR\";\n      retObj['error'] = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['error']['message'] = \"Error: Input parameters are missing\";\n\n  } else {\n      userapp = params['userapp'];\n      // fetch the auth params for given userapp\n      fetchedParams = userapp.fetchAuthParams(params['appinfo']);\n       // fetching the shop url\n      shopUrl =  userapp['params'].find(p => p.id === 'shop');\n\n      options = {\n          method: 'GET',\n          headers: {\n              'X-Shopify-Access-Token': fetchedParams['access_token'],\n              'Content-Type'          : 'application/json',\n          },\n          url: 'https://' + shopUrl.value + productIdUrl,\n          json: true,\n      };\n\n      retObj['status'] = \"SUCCESS\";\n      retObj['data'] = {\n          options: options\n      };\n  }\n  callback(retObj);\n}",
					"dynamicValueSourceParse": "function dynamicValueSourceParse(params, utils, callback) {\n\n  var retObj = { status: \"ERROR\" };\n  var locations;\n  var errors;\n  var errorMessage;\n\n  // if response or body are not present in params\n  if (!params || !params['response'] || !params['body']) {\n    retObj['error'] = {};\n    retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n    retObj['error']['message'] = \"Error: Input parameters are missing.\";\n\n  } else {\n\n    let response = params.response\n\n    if (params['response']['statusCode'] == 200) {\n      // Extracting the products array\n      locations = params['body']['locations'];\n\n      // if any product returned from \n      if (locations && locations instanceof Array && locations.length) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = locations\n          .map(location => ({\n            id: location.id,\n            name: location.name\n          })\n          )\n\n      } else {\n        retObj.status = 'SUCCESS'\n        retObj.data = []\n      }\n    } else {\n      // when error data present, flattening the object\n      errors = params['body']['errors'];\n      if (errors) {\n        errorMessage = '';\n        if (typeof errors == 'string')\n          errorMessage = errors;\n        else {\n          Object.keys(errors).forEach(function (key) {\n            errorMessage += key + ': ';\n            if (errors[key] && errors[key] instanceof Array)\n              errorMessage += errors[key].join(',');\n            else if (typeof errors[key] == 'string')\n              errorMessage += errors[key];\n            else\n              errorMessage += errors[key];\n            errorMessage += ', ';\n          });\n        }\n      }\n      if (response['statusCode'] && response['statusCode'] == '401') {\n        // when oauth errors occurs because of wrong access token\n        retObj['error'] = {\n          code: 'ERROR_AUTH',\n          message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n        };\n\n      } else if (response['statusCode'] && response['statusCode'] == '429') {\n        // when rate limit occurs \n        retObj['error'] = {\n          code: 'ERROR_RATE_LIMIT',\n          message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n        };\n\n      } else if (response['statusCode']) {\n        // for all the other errors\n        retObj['error'] = {\n          code: 'ERROR_UNKNOWN',\n          message: errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode']\n        };\n      }\n    }\n  }\n  callback(retObj);\n}",
					"required": false,
					"groupType": "COLLECTION",
					"groupName": "Set Quantity"
				},
				{
					"fixedValueSource": [
						{
							"id": "deny",
							"name": "Deny"
						},
						{
							"id": "continue",
							"name": "Allow"
						}
					],
					"id": "inventory_policy",
					"name": "Allow customers to purchase this product when it's out of stock",
					"type": "String",
					"inputType": "select",
					"required": false
				}
			],
			"responseFields": [
				{
					"id": "variant_id",
					"name": "Updated Product Variant Id",
					"type": "String"
				}
			]
		}
	],
	"appId": "shopify",
	"app_url": "https://apps.shopify.com/automate-io",
	"auth": {
		"type": "OAuth2",
		"authParams": {
			"site": "https://www.shopify.com",
			"clientID": "4c6cb4f2f59c0fec274bca8883700c42",
			"clientSecret": "409016ebed98a3c270711f339ffc8a5b",
			"redirect_uri": "https://api.automate.io/auth/shopify/callback",
			"tokenPath": "/admin/oauth/access_token",
			"authorizationPath": "/admin/oauth/authorize"
		},
		"authStrategy": "function authStrategy(hashedParams, hashedUtils, callback) {\n\n    var retObj      = {status: \"ERROR\"};\n    var scope       = 'read_orders,write_orders,read_customers,write_customers,read_products,write_products,read_content,write_content,read_fulfillments,write_inventory';\n    var authParams;\n    var oauth2;\n    var path;\n    var fetchedParams\n    var authorization_uri;\n\n    // if no oauth2 util present or appInfo\n    if (!(hashedUtils || {}).oauth2 && !(hashedParams || {}).appInfo) {\n      retObj.error = { code: 'ERROR_MISSING_PARAM', message: 'authStrategy: Missing simple-oauth2 object in the hashedUtils or apInfo in hashParams' }\n      callback(retObj)\n      return;\n\n    } else if (!(hashedParams['appInfo']['auth'] || {}).authParams) {\n      retObj.error = { code: 'ERROR_MISSING_PARAM', message: \"authStrategy: Missing authParams in the auth\" };\n      callback(retObj);\n      return;\n    }\n\n    // fetching the authParams and user input\n    authParams      = hashedParams['appInfo']['auth']['authParams'];\n    fetchedParams   = JSON.parse(hashedParams['params']);\n\n    // checking if any authParam is missing\n    if (!authParams['redirect_uri'] || !authParams['authorizationPath'] || !authParams['clientID']) {\n        retObj.error = {code: 'ERROR_MISSING_PARAM', message: \"authStrategy: Missing parameters in authParams\" };\n        callback(retObj);\n        return;\n\n    } else {\n        // creating a oauth2 object\n        let site = 'https://' + fetchedParams['shopName'] + '.myshopify.com'\n        if(fetchedParams['shop']){\n          site = `https://${fetchedParams['shop']}`\n        }\n        oauth2 = hashedUtils.oauth2({\n          clientID: authParams['clientID'] || fetchedParams['clientID'],\n          site: site,\n          authorizationPath: authParams['authorizationPath'] || fetchedParams['authorizationPath']\n        });\n\n        // getting authorizeURL\n        authorization_uri = oauth2.authCode.authorizeURL({\n          client_id   : authParams['clientID'] || fetchedParams['clientID'],\n          scope       : scope,\n          redirect_uri: authParams['redirect_uri'] || fetchedParams['redirect_uri']\n\n        });\n\n        // success return object to the callback\n        retObj.status = 'SUCCESS';\n        retObj.data = { authorization_uri: authorization_uri };\n        callback(retObj);\n    }\n}",
		"authCallBack": "function authCallback(hashedParams, hashedUtils, callback) {\n\n    var retObj  = {status: \"ERROR\"};\n    var params  = [];\n    var appInfo;\n    var oauth2;\n    var authParams;\n    var code;\n\n    // if queryobj not present in the hashedParam\n    \n    if (!((hashedParams || {})).queryObj || !(hashedUtils || {}).oauth2) {\n        retObj.error = {\n            code    : 'ERROR_MISSING_PARAM', \n            message : 'authCallback: Missing query parameters in the hashedParams or simple-oauth util' \n        };\n        callback(retObj);\n        return;\n\n    }\n\n    // fetching the queryObj\n    var queryObj = hashedParams.queryObj;\n    \n    // if code in queryObj is missing\n    if (!queryObj.code) {\n        retObj.error = { \n            code    : 'ERROR_MISSING_PARAM', \n            message : 'authCallback: Missing code in the queryObj'\n        };\n        callback(retObj);\n        return;\n    }\n\n    // fetching the app\n    authParams  =   hashedParams['appInfo']['auth']['authParams'];\n    oauth2 = hashedUtils.oauth2({\n        clientID    : authParams['clientID'],\n        clientSecret: authParams['clientSecret'],\n        site        : 'https://' + queryObj['shop'],\n        tokenPath   : authParams['tokenPath']\n    });\n\n    // fetching code\n    code = queryObj.code;\n\n    oauth2.authCode.getToken({\n        code         : code,\n        client_id    : authParams['clientID'],\n        client_secret: authParams['clientSecret'],\n    }, saveToken, this);\n\n    // to save the token and shop name\n    function saveToken(ERROR, result) {\n        if (ERROR) {\n            retObj.error = {\n                 code   : 'ERROR_AUTH',\n                 message: 'Access Token ERROR ' + ERROR \n            };\n            callback(retObj);\n            return;\n        } else {\n            let identifier = ''\n            if (queryObj['shop']) {\n                const splitArr = queryObj['shop'].split('.')\n                if (splitArr[0]) {\n                    identifier = splitArr[0]\n                }\n            }\n            if (result && result['access_token']) {\n                params.push({ 'id': 'access_token', value: result['access_token'] });\n                params.push({ 'id': 'shop' , value: queryObj['shop']});\n                params.push({ id: 'identifier', value: identifier })\n                retObj.status = 'SUCCESS';\n                retObj.data   = { oauth2Info: result, params: params };\n\n          \n                callback(retObj);\n                return;\n            } else {\n                retObj.error = { code: 'ERROR_AUTH', message: 'Cannot retrieve all the required tokens ' };\n                callback(retObj);\n                return;\n            }\n        }\n    }\n}",
		"authDeleteRequest": "function authDeleteRequest(params, utils, callback) {\n  const retObj = {}\n  if (!params || !params.userApp || !params.appInfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const fetchedParams = params.userApp.fetchAuthParams(params.appInfo)\n\n  if (!fetchedParams || !fetchedParams.access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = fetchedParams\n\n  const shopUrlObj = params.userApp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/api_permissions/current.json`\n\n  const options = {\n    url,\n    method: 'DELETE',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n      'Accept': 'application/json'\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
		"authDeleteParse": "function authDeleteParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n    retObj.status = 'SUCCESS'\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
		"authObjectRequest": "function authObjectRequest(params, utils, callback) {\n\n    var retObj          = {status: \"ERROR\"};\n    var url             = '/admin/api/2019-04/shop.json';\n    var options;\n    if (!params) {\n        retObj.status = 'ERROR'\n        retObj.error = {\n          message: 'params are missing',\n          code: \"ERROR_MISSING_PARAMS\"\n        }\n        return callback(retObj)\n      }\n    \n  \n      // fetch the auth params for given userapp\n      let authData = params['authCallbackData']\n\n      let access_token = authData.params && authData.params.find(p => p.id === 'access_token') ? authData.params.find(p => p.id === 'access_token') : null\n      let shopUrl = authData.params && authData.params.find(p => p.id === 'shop') ? authData.params.find(p => p.id === 'shop') : null\n      let identifier = authData.params && authData.params.find(p => p.id === 'identifier') ? authData.params.find(p => p.id === 'identifier') : null\n\n      var oauthParams = [access_token,shopUrl,identifier]\n        \n      access_token = access_token && access_token.value ? access_token.value : null\n      shopUrl = shopUrl && shopUrl.value ? shopUrl.value : null\n    \n      \n      // if the access token not available than return with error object\n      if (!access_token || !shopUrl) {\n          // checking for access token\n          retObj['error']             = {};\n          retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n          retObj['error']['message']  = \"Missing access token in the fetched auth params\"; \n          callback(retObj);\n          return;\n  \n      }  else {\n          // compiling the options for searching prodcut for the given title of product\n          options = {\n              method: 'GET',\n              headers: {\n                  'X-Shopify-Access-Token': access_token,\n                  'Content-Type'          : 'application/json',\n              },\n              url: 'https://' + shopUrl + url,\n              json: true\n          }\n\n          retObj.step = {oauthParams : oauthParams}\n          retObj['status']        = \"SUCCESS\";\n          retObj['data']          = { options: options };\n      } \n    callback(retObj);\n  }",
		"authObjectParse": "function authObjectParse(params, utils, callback) {\n    let retObj = {}\n    let response = params['response']\n    let authData = params['authCallbackData']\n    let oauthParams = []\n    let body\n  \n    // Validate User params\n    if (!response || !response.body) {\n  \n      retObj['status'] = 'ERROR'\n      retObj['error'] = {}\n      retObj['error']['code'] = 'ERROR_MISSING_PARAM'\n      retObj['error']['message'] = 'Error: Missing body.'\n  \n    } else {\n  \n      body = response.body\n      oauthParams = params.step ? params.step.oauthParams : []\n      if (body && body.shop) {\n        if (body && body.shop && body.shop.name && body.shop.email) {\n          retObj.status = 'SUCCESS'\n          retObj.data = {\n            oauth2Info: authData.oauth2Info,\n            params: oauthParams\n          }\n          retObj.user = {\n            name: body.shop.name ,\n            email: body.shop.email\n          }\n        } else {\n          retObj['status'] = 'ERROR'\n          retObj['message'] = 'Missing user name and email from body in authentication flow'\n          retObj['errorCode'] = 'ERROR_UNKOWN'\n        }\n  \n      } \n    }\n  \n    return callback(retObj)\n  }\n  ",
		"authRedirectURL": "/landing/shopify",
		"params": [
			{
				"fixedValueSource": [],
				"inputType": "input",
				"name": "Shop Name",
				"id": "shopName",
				"domain": ".myshopify.com",
				"protocol": "https://",
				"type": "Subdomain",
				"required": true,
				"description": "Name of your shop on shopify. Example  https://{shopname}.myshopify.com/",
				"input": true,
				"persist": true
			}
		],
		"response": [
			{
				"id": "access_token"
			},
			{
				"id": "shop"
			},
			{
				"id": "identifier"
			}
		]
	},
	"beta": false,
	"category": "ecommerce",
	"description": "Create your online store and sell online with Shopify. Manage inventory, market products online and receive payments.",
	"draft": false,
	"logo": "assets/images/logos/shopify.png",
	"name": "Shopify",
	"premium": true,
	"priority": 2,
	"triggers": [
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "Abandoned Cart",
			"id": "abandoned-cart",
			"description": "Triggers when the shopping cart is abandoned",
			"priority": 1,
			"entity": "invoice",
			"source": {
				"type": "poll",
				"initialPollRequest": "function initialPollRequest(hashedParams, utils, callback) {\n  \n  // storing the time milliseconds\n  var TimeStamp = Date.now();\n  var retObj    = {};\n\n  retObj['status']           = \"SUCCESS\";\n  retObj['data']             = {};\n  retObj['data']['pollData'] = {\n      status: \"SUCCESS\",\n      data: {\n        time: TimeStamp\n      }\n  };\n\n  callback(retObj);\n}",
				"initialPollParse": "function (){ }",
				"pollRequest": "function pollRequest(params, utils, callback) {\n\n    var retObj             = {status: \"ERROR\"};\n    var url                = \"/admin/checkouts.json\";\n    var currentTimeMS      = Date.now();\n    var millisecondsInHour = 3600000;\n    var minDate;\n    var maxDate;\n    var shopUrl;\n    var fetchedAuthParams;\n    var userInputHours;\n    var workflow;\n    var pollDate;\n    var time;\n    var options;\n\n    // checking if any input param is missing\n    if (!params || !params['appinfo'] || !params['userapp'] || !params['workflow']) {\n        retObj['error']             = {};\n        retObj['error']['code']     = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message']  = \"PollRequest: Input parameters are missing\";\n        callback(retObj);\n        return;\n    }\n\n    // Fetch Auth Params\n    fetchedAuthParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the workflow for pollData\n    workflow          = params['workflow'];\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the user input hours\n    if(workflow && workflow['trigger'] && workflow['trigger']['params'])\n        userInputHours = workflow['trigger']['params'].find(p =>p.id === 'age');\n\n    // if the auth params are missing, here access_token\n    if (!fetchedAuthParams || !fetchedAuthParams['access_token'] || !shopUrl || !shopUrl.value) {\n        retObj['error']             = {};\n        retObj['error']['code']     = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message']  = \"PollRequest: Missing the auth params\";\n\n    }else if (!workflow['trigger'] || !workflow['trigger']['pollData'] \n                                   || !workflow['trigger']['pollData']['data']['time']) {\n        // in case the workflow related pollData is missing\n        retObj['error']             = {};\n        retObj['error']['code']     = \"ERORR_MISSING_PARAM\";\n        retObj['error']['message']  = \"PollRequest: Missing the workflow poll data\";\n\n    } else if( !userInputHours || !userInputHours.value){\n\n        // in case the workflow params are missing\n        retObj['error']             = {};\n        retObj['error']['code']     = \"ERORR_MISSING_PARAM\";\n        retObj['error']['message']  = \"PollRequest: Missing the workflow trigger params\";\n\n    } else {\n\n        // when everything is fine, creating request data\n        time    = workflow['trigger']['pollData']['data']['time'];\n        // calculating the after time \n        minDate = new Date(time - userInputHours.value * millisecondsInHour).toISOString();\n        // calculating the before time\n        maxDate = new Date(currentTimeMS - userInputHours.value * millisecondsInHour).toISOString();\n    \n        // compiling the options\n        options =   {\n            method : 'GET',\n            url    : 'https://' + shopUrl.value + url,\n            json   : true,\n            headers:   {\n                'X-Shopify-Access-Token' : fetchedAuthParams['access_token'],\n                'Content-Type'           : 'application/json'\n            },\n            qs   : {\"created_at_min\": minDate, \"created_at_max\": maxDate}\n        }\n        retObj['status'] = \"SUCCESS\";\n        retObj['data']   = { options };\n        retObj['step']   = {\"value\" : currentTimeMS};\n    }\n    callback(retObj);\n}",
				"pollParse": "function pollParse(params, utils, callback) {\n\n    var abandonedCheckouts = [];\n    var retObj = { status: \"ERROR\" };\n    var skipFields = ['note_attributes', 'token', 'cart_token', 'default', 'shipping_lines', 'applied_discounts', 'tax_lines', 'discount_codes', 'tax_lines',];\n    var customerData = {};\n    var checkoutData = {};\n    var checkoutObj = {};\n    var lineItemPrefix;\n    var tempcheckoutObj;\n    var abandCheck;\n    var pollRequestTime;\n    var response;\n    var parsedBody;\n    var errorMessage;\n    var errors;\n\n    // if any required param is missing from the input\n    if (!params || !params['response'] || !params['body'] || !utils || !utils.libDate) {\n        retObj['error'] = {};\n        retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"PollParse: Missing response, body or libDate util\";\n        callback(retObj);\n        return;\n    }\n    else {\n        pollRequestTime = params['step'] && params['step']['value'] ? params['step']['value'] : Date.now();\n        response = params['response'];\n        parsedBody = params['body'];\n\n        // if the request is successful\n        if (response['statusCode'] && response['statusCode'] === 200) {\n\n            if (parsedBody['checkouts'].length) {\n                // when there are new entries\n\n                parsedBody['checkouts'].forEach(function (checkout, index) {\n                    tempcheckoutObj = {};\n\n                    Object.keys(checkout).forEach(function (field) {\n                        if (field === \"customer\") {\n\n                            Object.keys(checkout[field]).forEach(function (prop) {\n                                if (prop === \"default_address\") {\n                                    Object.keys(checkout[field][prop]).forEach(function (p) {\n                                        customerData[field + '_address_' + p] = checkout[field][prop][p] ? checkout[field][prop][p] : '';\n                                    }, this);\n                                } else {\n                                    if (prop === 'created_at' || prop === 'updated_at')\n                                        customerData[field + '_' + prop] = checkout[field][prop] ? utils.libDate.parseJSDateTimeToStandardString(checkout[field][prop]) : '';\n                                    else\n                                        customerData[field + '_' + prop] = checkout[field][prop] ? checkout[field][prop] : '';\n                                }\n                            }, this);\n\n                        } else if (field === \"line_items\") {\n\n                            //creating comma separated list of all line item names and ids\n\n                            let accumulated = null\n\n                            accumulated = checkout[field].reduce((acc, value) => {\n                                acc.line_item_ids.push(value.id ? value.id : '')\n                                acc.line_item_names.push(value.name ? value.name : '')\n                                acc.line_item_product_codes.push(value.product_id ? value.product_id : '')\n                                acc.line_item_titles.push(value.title ? value.title : '')\n                                acc.line_item_variant_ids.push(value.variant_id ? value.variant_id : '')\n                                acc.line_item_variant_titles.push(value.variant_title ? value.variant_title : '')\n                                acc.line_item_quantities.push(value.quantity ? value.quantity : '')\n                                acc.line_item_prices.push(value.price ? value.price : '')\n                                acc.line_item_skus.push(value.sku ? value.sku : '')\n                                acc.line_item_weights.push(value.grams ? value.grams : '')\n\n                                return acc\n                            }, {\n                                    line_item_ids: [],\n                                    line_item_names: [],\n                                    line_item_product_codes: [],\n                                    line_item_titles: [],\n                                    line_item_variant_ids: [],\n                                    line_item_variant_titles: [],\n                                    line_item_quantities: [],\n                                    line_item_prices: [],\n                                    line_item_skus: [],\n                                    line_item_weights: []\n                                }\n                            )\n\n                            Object.keys(accumulated).forEach(prop => {\n                                let fld = prop\n                                let data = accumulated[prop]\n\n                                if (data && data.length) {\n                                    tempcheckoutObj[fld] = data.toString()\n                                }\n                            })\n\n                            // var line_item_names = \"\";\n                            // var line_item_product_codes = \"\";\n\n                            // checkout[field].forEach(function(item){\n                            //     line_item_product_codes += item.product_id + \",\";\n                            //     line_item_names += item.name + \",\";\n                            // });\n\n                            // if (line_item_product_codes && line_item_names) {\n                            //     tempcheckoutObj['line_item_product_codes'] = line_item_product_codes.slice(0, line_item_product_codes.length - 1);\n                            //     tempcheckoutObj['line_item_names'] = line_item_names.slice(0, line_item_names.length - 1);    \n                            // }\n\n                            checkout[field].every(function (item, innerIndex) {\n                                lineItemPrefix = index === 0 ? 'first_' : index === 1 ? 'second_' : 'third_';\n\n                                // only fetching top 3 line items\n                                if (innerIndex === 2)\n                                    return false;\n\n                                Object.keys(item).forEach(function (el) {\n                                    if (skipFields.indexOf(el) < 0)\n                                        tempcheckoutObj[lineItemPrefix + 'line_Item_' + el] = item[el] ? item[el] : '';\n                                }, this);\n\n                            }, this);\n\n                        } else if (field === \"shipping_address\" || field === \"billing_address\") {\n\n                            Object.keys(checkout[field]).forEach(function (prop) {\n                                tempcheckoutObj[field + '_' + prop] = checkout[field][prop] ? checkout[field][prop] : '';\n                            }, this);\n\n                        } else if (skipFields.indexOf(field) < 0) {\n                            if (field === 'created_at' || field === 'updated_at')\n                                checkoutData[field] = checkout[field] ? utils.libDate.parseJSDateTimeToStandardString(checkout[field]) : '';\n                            else\n                                checkoutData[field] = checkout[field] ? checkout[field] : '';\n                        }\n                    }, this);\n\n                    // reordering the JSON data\n                    [checkoutData, customerData, tempcheckoutObj].forEach(function (jsonObj) {\n                        Object.keys(jsonObj).forEach(function (key) {\n                            checkoutObj[key] = jsonObj[key];\n                        }, this);\n                    }, this);\n\n                    abandCheck = {};\n                    abandCheck['response'] = { \"params\": checkoutObj };\n                    abandonedCheckouts.push({ \"newObject\": abandCheck, \"hash\": { \"id\": checkout.id } });\n\n                }, this);\n\n                retObj['status'] = \"SUCCESS\";\n                retObj['data'] = {\n                    pollData: {\n                        status: 'SUCCESS',\n                        data: {\n                            time: pollRequestTime ? pollRequestTime : null\n                        }\n                    },\n                    objects: abandonedCheckouts\n                };\n            }\n            else {\n                // in case of no new lead found\t\n                retObj['status'] = \"SUCCESS\";\n                retObj['data'] = {};\n                retObj['data']['objects'] = [];\n                retObj['data']['pollData'] = {\n                    status: \"SUCCESS\",\n                    data: {\n                        time: pollRequestTime ? pollRequestTime : null\n                    }\n                };\n            }\n\n        } else {\n            // when error data present, flattening the object\n            errors = params['body']['errors'];\n            if (errors) {\n                errorMessage = '';\n                if (typeof errors == 'string')\n                    errorMessage = errors;\n                else {\n                    Object.keys(errors).forEach(function (key) {\n                        errorMessage += key + ': ';\n                        if (errors[key] && errors[key] instanceof Array)\n                            errorMessage += errors[key].join(',');\n                        else if (typeof errors[key] == 'string')\n                            errorMessage += errors[key];\n                        else\n                            errorMessage += errors[key];\n                        errorMessage += ', ';\n                    });\n                }\n            }\n            if (response['statusCode'] && response['statusCode'] == '401') {\n                // when oauth errors occurs because of wrong access token\n                retObj['error'] = {\n                    code: 'ERROR_AUTH',\n                    message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n                };\n\n            } else if (response['statusCode'] && response['statusCode'] == '429') {\n                // when rate limit occurs \n                retObj['error'] = {\n                    code: 'ERROR_RATE_LIMIT',\n                    message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n                };\n\n            } else if (response['statusCode']) {\n                // for all the other errors\n                retObj['error'] = {\n                    code: 'ERROR_UNKNOWN',\n                    message: errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode']\n                };\n            }\n        }\n    }\n    callback(retObj);\n}"
			},
			"params": [
				{
					"fixedValueSource": [],
					"name": "Abandoned Checkout Age",
					"id": "age",
					"inputType": "input",
					"defaultValue": "2",
					"type": "String",
					"required": true,
					"description": "Age of checkout in hours to consider it as abandoned checkout"
				}
			],
			"responseFields": [
				{
					"name": "Checkout ID",
					"id": "id",
					"description": "Shopify id of the abandoned checkout",
					"type": "String"
				},
				{
					"name": "Customer Email Address",
					"id": "email",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Landing Site",
					"id": "landing_site",
					"type": "String"
				},
				{
					"name": "Subtotal Price",
					"id": "subtotal_price",
					"description": "Price of the order before shipping and taxes",
					"type": "String"
				},
				{
					"name": "Total Discount",
					"id": "total_discounts",
					"type": "String"
				},
				{
					"name": "Total Line Items Price",
					"id": "total_line_items_price",
					"type": "String"
				},
				{
					"name": "Total Price",
					"id": "total_price",
					"description": "The sum of prices of all the items in the order, taxes and discounts included",
					"type": "String"
				},
				{
					"name": "Total Tax",
					"id": "total_tax",
					"type": "String"
				},
				{
					"name": "Currency",
					"id": "currency",
					"type": "String"
				},
				{
					"name": "Total Weight",
					"id": "total_weight",
					"description": "The sum of all the weights of the line items in the order(grams)",
					"type": "String"
				},
				{
					"name": "Checkout Name",
					"id": "name",
					"type": "String"
				},
				{
					"name": "Abandoned Checkout URL",
					"id": "abandoned_checkout_url",
					"type": "String"
				},
				{
					"id": "cart_token",
					"name": "Abandoned Cart Token"
				},
				{
					"id": "gateway",
					"name": "Abandoned Cart Gateway"
				},
				{
					"id": "note",
					"name": "Abandoned Cart Note"
				},
				{
					"name": "Source Name",
					"id": "source_name",
					"type": "String"
				},
				{
					"name": "Customer ID",
					"id": "customer_id",
					"type": "String"
				},
				{
					"name": "Customer Email Address",
					"id": "customer_email",
					"type": "String"
				},
				{
					"name": "Customer Accepts Marketing",
					"id": "customer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Customer Created At",
					"id": "customer_created_at",
					"type": "String"
				},
				{
					"name": "Customer Updated At",
					"id": "customer_updated_at",
					"type": "String"
				},
				{
					"name": "Customer First Name",
					"id": "customer_first_name",
					"type": "String"
				},
				{
					"name": "Customer Last Name",
					"id": "customer_last_name",
					"type": "String"
				},
				{
					"name": "Customer Orders Count",
					"id": "customer_orders_count",
					"type": "String"
				},
				{
					"name": "Customer State",
					"id": "customer_state",
					"type": "String"
				},
				{
					"name": "Customer Total Spent",
					"id": "customer_total_spent",
					"description": "The total amount spent by customer",
					"type": "String"
				},
				{
					"name": "customer Last Order ID",
					"id": "customer_last_order_id",
					"type": "String"
				},
				{
					"name": "Customer Note",
					"id": "customer_note",
					"type": "String"
				},
				{
					"name": "Customer Verified Email",
					"id": "customer_verified_email",
					"type": "String"
				},
				{
					"name": "Customer Tax Exempt",
					"id": "customer_tax_exempt",
					"type": "String"
				},
				{
					"name": "Customer Phone",
					"id": "customer_phone",
					"type": "String"
				},
				{
					"name": "Customer Tags",
					"id": "customer_tags",
					"type": "String"
				},
				{
					"name": "Customer Last Order Name",
					"id": "customer_last_order_name",
					"type": "String"
				},
				{
					"name": "Customer Address ID",
					"id": "customer_address_id",
					"type": "String"
				},
				{
					"name": "Customer Address First Name",
					"id": "customer_address_first_name",
					"type": "String"
				},
				{
					"name": "Customer Address Last Name",
					"id": "customer_address_last_name",
					"type": "String"
				},
				{
					"name": "Customer Address Company",
					"id": "customer_address_company",
					"type": "String"
				},
				{
					"name": "Customer Address Line 1",
					"id": "customer_address_address1",
					"type": "String"
				},
				{
					"name": "Customer Address Line 2",
					"id": "customer_address_address2",
					"type": "String"
				},
				{
					"name": "Customer Last Name",
					"id": "customer_last_name",
					"type": "String"
				},
				{
					"name": "Customer Address City",
					"id": "customer_address_city",
					"type": "String"
				},
				{
					"name": "Customer Address Province",
					"id": "customer_address_province",
					"type": "String"
				},
				{
					"name": "Customer Address Country",
					"id": "customer_address_country",
					"type": "String"
				},
				{
					"name": "Customer Address Name",
					"id": "customer_address_name",
					"type": "String"
				},
				{
					"name": "Customer Address Province Code",
					"id": "customer_address_province_code",
					"type": "String"
				},
				{
					"name": "Customer Address Country Code",
					"id": "customer_address_country_code",
					"type": "String"
				},
				{
					"name": "Customer Address Country Name",
					"id": "customer_address_country_name",
					"type": "String"
				},
				{
					"name": "All Line Item Ids",
					"id": "line_item_ids",
					"type": "String",
					"description": "comma seperated list of line ids"
				},
				{
					"name": "All Line Item Product Codes",
					"id": "line_item_product_codes",
					"type": "String",
					"description": "comma seperated list of product codes"
				},
				{
					"name": "All Line Item Product Names",
					"id": "line_item_names",
					"type": "String",
					"description": "comma seperated list of product names"
				},
				{
					"name": "All Line Item Product Titles",
					"id": "line_item_titles",
					"type": "String",
					"description": "comma seperated list of product titles"
				},
				{
					"name": "All Line Item Product Variant Ids",
					"id": "line_item_variant_ids",
					"type": "String",
					"description": "comma seperated list of product variant ids"
				},
				{
					"name": "All Line Item Product Variant Titles",
					"id": "line_item_variant_titles",
					"type": "String",
					"description": "comma seperated list of product variant titles"
				},
				{
					"name": "All Line Item Quantities",
					"id": "line_item_quantities",
					"type": "String",
					"description": "comma seperated list of product quantities"
				},
				{
					"name": "All Line Item Prices",
					"id": "line_item_prices",
					"type": "String",
					"description": "comma seperated list of product unit prices"
				},
				{
					"name": "All Line Item Skus",
					"id": "line_item_skus",
					"type": "String",
					"description": "comma seperated list of product skus"
				},
				{
					"name": "All Line Item Product Weights",
					"id": "line_item_weights",
					"type": "String",
					"description": "comma seperated list of product weights"
				},
				{
					"name": "First Item Key",
					"id": "first_line_Item_key",
					"type": "String"
				},
				{
					"name": "First Item Destination Location ID",
					"id": "first_line_Item_destination_location_id",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Service",
					"id": "first_line_Item_fulfillment_service",
					"type": "String"
				},
				{
					"name": "First Item Line Price",
					"id": "first_line_Item_line_price",
					"type": "String"
				},
				{
					"name": "First Item Location ID",
					"id": "first_line_Item_origin_location_id",
					"type": "String"
				},
				{
					"name": "First Item Price",
					"id": "first_line_Item_price",
					"type": "String"
				},
				{
					"name": "First Item Product ID",
					"id": "first_line_Item_product_id",
					"type": "String"
				},
				{
					"name": "First Item Quantity",
					"id": "first_line_Item_quantity",
					"type": "String"
				},
				{
					"name": "First Item Requires Shipping",
					"id": "first_line_Item_requires_shipping",
					"type": "String"
				},
				{
					"name": "First Item Taxable",
					"id": "first_line_Item_taxable",
					"type": "String"
				},
				{
					"name": "First Item Title",
					"id": "first_line_Item_title",
					"type": "String"
				},
				{
					"name": "First Item Variant ID",
					"id": "first_line_Item_variant_id",
					"type": "String"
				},
				{
					"name": "First Item Variant Title",
					"id": "first_line_Item_variant_title",
					"type": "String"
				},
				{
					"name": "First Item Vendor",
					"id": "first_line_Item_vendor",
					"type": "String"
				},
				{
					"id": "first_item_sku",
					"name": "First Item SKU"
				},
				{
					"id": "first_item_grams",
					"name": "First Item Weight (grams)"
				},
				{
					"id": "first_item_gift_card",
					"name": "First Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Second Item Key",
					"id": "second_line_Item_key",
					"type": "String"
				},
				{
					"name": "Second Item Destination Location ID",
					"id": "second_line_Item_destination_location_id",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Service",
					"id": "second_line_Item_fulfillment_service",
					"type": "String"
				},
				{
					"name": "Second Item Line Price",
					"id": "second_line_Item_line_price",
					"type": "String"
				},
				{
					"name": "Second Item Location ID",
					"id": "second_line_Item_origin_location_id",
					"type": "String"
				},
				{
					"name": "Second Item Price",
					"id": "second_line_Item_price",
					"type": "String"
				},
				{
					"name": "Second Item Product ID",
					"id": "second_line_Item_product_id",
					"type": "String"
				},
				{
					"name": "Second Item Quantity",
					"id": "second_line_Item_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Requires Shipping",
					"id": "second_line_Item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Second Item Taxable",
					"id": "second_line_Item_taxable",
					"type": "String"
				},
				{
					"name": "Second Item Title",
					"id": "second_line_Item_title",
					"type": "String"
				},
				{
					"name": "Second Item Variant ID",
					"id": "second_line_Item_variant_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant Title",
					"id": "second_line_Item_variant_title",
					"type": "String"
				},
				{
					"name": "Second Item Vendor",
					"id": "second_line_Item_vendor",
					"type": "String"
				},
				{
					"id": "second_item_sku",
					"name": "Second Item SKU"
				},
				{
					"id": "second_item_grams",
					"name": "Second Item Weight (grams)"
				},
				{
					"id": "second_item_gift_card",
					"name": "Second Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Third Item Key",
					"id": "third_line_Item_key",
					"type": "String"
				},
				{
					"name": "Third Item Destination Location ID",
					"id": "third_line_Item_destination_location_id",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Service",
					"id": "third_line_Item_fulfillment_service",
					"type": "String"
				},
				{
					"name": "Third Item Line Price",
					"id": "third_line_Item_line_price",
					"type": "String"
				},
				{
					"name": "Third Item Location ID",
					"id": "third_line_Item_origin_location_id",
					"type": "String"
				},
				{
					"name": "Third Item Price",
					"id": "third_line_Item_price",
					"type": "String"
				},
				{
					"name": "Third Item Product ID",
					"id": "third_line_Item_product_id",
					"type": "String"
				},
				{
					"name": "Third Item Quantity",
					"id": "third_line_Item_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Requires Shipping",
					"id": "third_line_Item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Third Item Taxable",
					"id": "third_line_Item_taxable",
					"type": "String"
				},
				{
					"name": "Third Item Title",
					"id": "third_line_Item_title",
					"type": "String"
				},
				{
					"name": "Third Item Variant ID",
					"id": "third_line_Item_variant_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant Title",
					"id": "third_line_Item_variant_title",
					"type": "String"
				},
				{
					"name": "Third Item Vendor",
					"id": "third_line_Item_vendor",
					"type": "String"
				},
				{
					"id": "third_item_sku",
					"name": "Third Item SKU"
				},
				{
					"id": "third_item_grams",
					"name": "Third Item Weight (grams)"
				},
				{
					"id": "third_item_gift_card",
					"name": "Third Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Shipping address First Name",
					"id": "shipping_address_first_name",
					"type": "String"
				},
				{
					"name": "Shipping address Last Name",
					"id": "shipping_address_last_name",
					"type": "String"
				},
				{
					"name": "Shipping Address Name",
					"id": "shipping_address_name",
					"type": "String"
				},
				{
					"name": "Shipping address Line 1",
					"id": "shipping_address_address1",
					"type": "String"
				},
				{
					"name": "Shipping address Line 2",
					"id": "shipping_address_address2",
					"type": "String"
				},
				{
					"name": "Shipping address Phone Number",
					"id": "shipping_address_phone",
					"type": "String"
				},
				{
					"name": "Shipping address City",
					"id": "shipping_address_city",
					"type": "String"
				},
				{
					"name": "Shipping address Zip",
					"id": "shipping_address_zip",
					"type": "String"
				},
				{
					"name": "Shipping address Province",
					"id": "shipping_address_province",
					"type": "String"
				},
				{
					"name": "Shipping address Country",
					"id": "shipping_address_country",
					"type": "String"
				},
				{
					"name": "Shipping address Company",
					"id": "shipping_address_company",
					"type": "String"
				},
				{
					"name": "Shipping address Country Code",
					"id": "shipping_address_country_code",
					"type": "String"
				},
				{
					"name": "Shipping address Province Code",
					"id": "shipping_address_province_code",
					"type": "String"
				},
				{
					"name": "Billing address First Name",
					"id": "billing_address_first_name",
					"type": "String"
				},
				{
					"name": "Billing address Last Name",
					"id": "billing_address_last_name",
					"type": "String"
				},
				{
					"name": "Billing Address Name",
					"id": "billing_address_name",
					"type": "String"
				},
				{
					"name": "Billing address Line 1",
					"id": "billing_address_address1",
					"type": "String"
				},
				{
					"name": "Billing address Line 2",
					"id": "billing_address_address2",
					"type": "String"
				},
				{
					"name": "Billing address Phone Number",
					"id": "billing_address_phone",
					"type": "String"
				},
				{
					"name": "Billing address City",
					"id": "billing_address_city",
					"type": "String"
				},
				{
					"name": "Billing address Zip",
					"id": "billing_address_zip",
					"type": "String"
				},
				{
					"name": "Billing address Province",
					"id": "billing_address_province",
					"type": "String"
				},
				{
					"name": "Billing address Country",
					"id": "billing_address_country",
					"type": "String"
				},
				{
					"name": "Billing address Company",
					"id": "billing_address_company",
					"type": "String"
				},
				{
					"name": "Billing address Country Code",
					"id": "billing_address_country_code",
					"type": "String"
				},
				{
					"name": "Billing address Province Code",
					"id": "billing_address_province_code",
					"type": "String"
				}
			]
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"id": "new-blog-entry",
			"name": "New Blog Entry",
			"description": "Triggers when a new entry is added to a blog in your Shopify store",
			"important": true,
			"priority": 3,
			"entity": "message",
			"beta": true,
			"source": {
				"type": "poll",
				"initialPollRequest": "function initialPollRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/events.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      filter: 'Article',\n      verb: 'create',\n      limit: 1\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n  \n  return callback(retObj)\n}",
				"initialPollParse": "function initialPollParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n    retObj.status = 'SUCCESS',\n    retObj.data = {\n      pollData: {\n        status: 'SUCCESS',\n        data: {\n          lastEventId: 1\n        }\n      }\n    }\n    if (body && body.events && body.events.length) {\n      retObj.data.pollData.data.lastEventId = body.events[0].id\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
				"pollRequest": "function pollRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const workflowParams = params && params.workflow && params.workflow.trigger && params.workflow.trigger.params  || ''\n\n  const blogId = workflowParams.find(param => param.id === 'blog_id')\n\n  if (!blogId || !blogId.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'required param blog id is missing',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const lastEventId = params.workflow && params.workflow.trigger && params.workflow.trigger.pollData && params.workflow.trigger.pollData.data && params.workflow.trigger.pollData.data.lastEventId || ''\n\n  if (!lastEventId) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'poll data is missing from workflow',\n      code: 'ERROR_MISSING_PARAMS'\n    }\n    return callback(retObj)\n  }\n\n  const url = `https://${shopUrl}/admin/events.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      filter: 'Article',\n      verb: 'create',\n      limit: 30,\n      since_id: lastEventId\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n  retObj.step = {\n    blogId: blogId.value,\n    lastEventId\n  }\n\n  return callback(retObj)\n}",
				"pollParse": "function pollParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n    retObj.status = 'SUCCESS',\n    retObj.data = {\n      pollData: {\n        status: 'SUCCESS',\n        data: {\n          lastEventId: params.step.lastEventId\n        }\n      },\n      objects: []\n    }\n    if (body && body.events && body.events.length) {\n      const blogId = params.step && params.step.blogId\n      retObj.data.objects = body.events\n        .filter(event => event.arguments[1] == blogId)\n        .map(event => ({article_id: event.subject_id, blogId}))\n      if (retObj.data.objects.length === 0) {\n        retObj.data.pollData.forceSave = true\n      }\n      retObj.data.pollData.data.lastEventId = body.events[body.events.length - 1].id\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  \n  return callback(retObj)\n}",
				"objectQuery": true,
				"objectRequest": "function objectRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const articleObj = params.parsedData.data.objects || []\n\n  const options = articleObj\n    .map(article => ({\n      url: `https://${shopUrl}/admin/blogs/${article.blogId}/articles/${article.article_id}.json`,\n      method: 'GET',\n      headers: {\n        'X-Shopify-Access-Token': access_token,\n        'Content-Type': 'application/json',\n      },\n      json: true\n    }))\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n  \n  return callback(retObj)\n}",
				"objectParse": "function objectParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n    if (body && body.article) {\n      retObj.status = 'SUCCESS'\n      retObj.data = {\n        newObject: {\n          response: {\n            params: parseArticle(body.article)\n          }\n        },\n        hash: {\n          id: body.article.id\n        }\n      }\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else if(response['statusCode'] && response['statusCode'] == '404') {\n      retObj.error = {\n        message: 'blog-entry not found'\n      }\n  } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n\n  function parseArticle(article) {\n    const dateFields = {\n      created_at: true,\n      updated_at: true,\n      published_at: true\n    }\n\n    const parsedArticle = {}\n\n    Object.keys(article)\n      .forEach(key => {\n        const data = article[key]\n        if (dateFields[key] && data) {\n          parsedArticle[key] = utils.libDate.parseJSDateTimeToStandardString(new Date(data))\n        } else if (key === 'image') {\n          parsedArticle['blog_image_url'] = data && data.src || ''\n        } else if (key !== 'admin_graphql_api_id') {\n          parsedArticle[key] = data\n        }\n      })\n\n    return parsedArticle\n  }\n\n}"
			},
			"params": [
				{
					"fixedValueSource": [],
					"id": "blog_id",
					"name": "Blog",
					"type": "String",
					"inputType": "select",
					"required": true,
					"dynamicValueSourceRequest": "function dynamicValueSourceRequest(params, utils, callback) {\n\n    var blogUrl  = '/admin/blogs.json';\n    var retObj        = {status: \"ERROR\"};\n    var shopUrl;\n    var userapp;\n    var options;\n    var fetchedParams;\n\n  // if appinfo or userapp are not present in params\n    if (!params || !params['appinfo'] || !params['userapp']) {\n        retObj['status'] = \"ERROR\";\n        retObj['error'] = {};\n        retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing\";\n\n    } else {\n        userapp = params['userapp'];\n        // fetch the auth params for given userapp\n        fetchedParams = userapp.fetchAuthParams(params['appinfo']);\n         // fetching the shop url\n        shopUrl =  userapp['params'].find(p => p.id === 'shop');\n\n        options = {\n            method: 'GET',\n            headers: {\n                'X-Shopify-Access-Token': fetchedParams['access_token'],\n                'Content-Type'          : 'application/json',\n            },\n            url: 'https://' + shopUrl.value + blogUrl,\n            json: true,\n        };\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = {\n            options: options\n        };\n    }\n    callback(retObj);\n}",
					"dynamicValueSourceParse": "function dynamicValueSourceParse(params, utils, callback) {\n\n    var retObj      = {status: \"ERROR\"};\n    var blogs;\n    var errors;\n    var errorMessage;\n\n    // if response or body are not present in params\n    if (!params || !params['response'] || !params['body']) {\n        retObj['error']            = {};\n        retObj['error']['code']    = \"ERROR_MISSING_PARAM\";\n        retObj['error']['message'] = \"Error: Input parameters are missing.\";\n\n    } else {\n\n        let response = params.response\n\n        if (params['response']['statusCode'] == 200) {\n            // Extracting the products array\n            blogs = params['body']['blogs'];\n\n           // if any product returned from \n            if (blogs && blogs instanceof Array && blogs.length) {\n\n                var optionsArray = [];\n                // creating a option for each product\n                blogs.forEach(function(element){\n                    // if title and id exists for the product\n                    if(element['id'] && element['title'])\n                    optionsArray.push({\n                        name: element['title'],\n                        id  : element['id'] \n                    });\n                });\n                retObj['status'] = \"SUCCESS\";\n                retObj['data']   = optionsArray;\n            } else {\n                retObj.status = 'SUCCESS'\n                retObj.data = []\n            }\n        } else {\n            // when error data present, flattening the object\n            errors   =  params['body']['errors']; \n            if(errors){\n                errorMessage = '';\n                if(typeof errors == 'string')\n                    errorMessage  = errors;\n                else {\n                    Object.keys(errors).forEach(function(key){\n                        errorMessage += key + ': ';\n                        if(errors[key] && errors[key] instanceof Array)\n                            errorMessage += errors[key].join(',');\n                        else if(typeof errors[key] == 'string')\n                            errorMessage += errors[key];\n                        else \n                            errorMessage += errors[key];\n                        errorMessage += ', ';\n                    });\n                } \n            } \n            if (response['statusCode'] && response['statusCode'] == '401') {\n                // when oauth errors occurs because of wrong access token\n                retObj['error'] = {\n                    code    : 'ERROR_AUTH',\n                    message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n                };\n\n            } else if (response['statusCode'] && response['statusCode'] == '429') {\n                // when rate limit occurs \n                retObj['error'] = {\n                    code    : 'ERROR_RATE_LIMIT',\n                    message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n                };\n\n            } else if (response['statusCode']){\n                // for all the other errors\n                retObj['error'] = {\n                    code    : 'ERROR_UNKNOWN',\n                    message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n                };\n            }\n        }\n    }\n    callback(retObj);\n}"
				}
			],
			"responseFields": [
				{
					"id": "id",
					"name": "Entry Id"
				},
				{
					"id": "title",
					"name": "Blog Entry Title"
				},
				{
					"id": "body_html",
					"name": "Blog Entry Body"
				},
				{
					"id": "summary_html",
					"name": "Blog Entry Summary/Excerpt"
				},
				{
					"id": "template_suffix",
					"name": "Blog Entry Template Suffix"
				},
				{
					"id": "blog_id",
					"name": "Blog Entry Blog Id"
				},
				{
					"id": "author",
					"name": "Blog Entry Author Name"
				},
				{
					"id": "tags",
					"name": "Blog Entry Tags"
				},
				{
					"id": "user_id",
					"name": "Blog Entry Author User Id"
				},
				{
					"id": "blog_image_url",
					"name": "Featured Image URL"
				},
				{
					"id": "published_at",
					"name": "Blog Published At"
				},
				{
					"id": "handle",
					"name": "Blog Entry Handle"
				},
				{
					"id": "created_at",
					"name": "Blog Entry Created At"
				},
				{
					"id": "updated_at",
					"name": "Blog Entry Updated At"
				}
			]
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "New Customer",
			"id": "new-customer",
			"description": "Triggers when there is a new Customer",
			"priority": 1,
			"entity": "person",
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'customers/create',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && (response['statusCode'] == 201 || response['statusCode'] == 200)) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n      // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response) {\n      retObj['error']         = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['message']       = \"Invalid/Missing API response\";\n      return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful deletion of webhook\n   if (response['statusCode'] && response['statusCode'] == 200) {\n        // sending the succes return object\n        retObj['status'] = \"SUCCESS\";\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n        }else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n\n  var retObj                 = {status: \"ERROR\"};\n  var defaultAddressPrefix   = 'default_address_';\n  var otherAddressPrefix     = 'second_address_';\n  var newCustomer            = {};\n  var defaultAddress;\n  var otherAddress;\n  var responseKeys;\n  var parsedBody;\n \n  // if body is not present in params\n  if (!params || !params.body || !(utils || {}).libDate) {\n      retObj['message']     = \"Invalid/Missing API body or libDate util\";\n      return callback(retObj);\n  } else {\n\n    parsedBody  = params['body'];\n    // extracting the keys of response data of customer\n    responseKeys    = Object.keys(parsedBody);\n    \n    if(responseKeys.length){\n\n        // iterating each key of the customer related data json\n        responseKeys.forEach(function(key){\n            \n            if(key === 'addresses'){\n\n                // find and parse default address\n                defaultAddress = parsedBody[key].find(e => e.default == true);\n                if(defaultAddress){\n                    Object.keys(defaultAddress).forEach(function(field){\n                        if (field === 'created_at' || field === 'updated_at'){\n                            newCustomer[defaultAddressPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(defaultAddress[field]) || '';\n                        } else\n                            newCustomer[defaultAddressPrefix + field] = defaultAddress[field] || '';\n                    }, this);\n                }\n               \n                // find and parse secondary or non default address\n                otherAddress = parsedBody[key].find(e => e.default != true);\n                if(otherAddress) {\n                    Object.keys(otherAddress).forEach(function(field){\n                        if (field === 'created_at' || field === 'updated_at'){\n                            newCustomer[defaultAddressPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(otherAddress[field]) || '';\n                        } else\n                            newCustomer[otherAddressPrefix + field] = otherAddress[field] || '';\n                    }, this);\n                }\n\n            } else if (key != 'default_address') {\n                // if normal details other than address \n                if(key === 'created_at' || key === 'updated_at')\n                    newCustomer[key]    =   utils.libDate.parseJSDateTimeToStandardString(parsedBody[key]) || '';\n                else\n                    newCustomer[key]    =   parsedBody[key] || '';\n            }\n        \n        }, this);\n\n        //newCustomer['customer_id']  = parsedBody['id'];\n        retObj['status']   = \"SUCCESS\";\n        retObj['data']     = { \"response\": newCustomer }; \n\n    } else {\n        retObj['error']         = {};\n        retObj['error']['code'] = \"ERROR_PARSE\";\n        retObj['message']       = \"Trigger data not as expected from shopify webhook\"\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}"
			},
			"responseFields": [
				{
					"name": "Customer ID",
					"id": "id",
					"description": "Shopify id of the customer",
					"type": "String"
				},
				{
					"name": "First Name",
					"id": "first_name",
					"type": "String"
				},
				{
					"name": "Last Name",
					"id": "last_name",
					"type": "String"
				},
				{
					"name": "Email Address",
					"id": "email",
					"description": "Email address of customer",
					"type": "String"
				},
				{
					"name": "Tags",
					"id": "tags",
					"type": "String"
				},
				{
					"name": "Note",
					"id": "note",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Account State",
					"id": "state",
					"description": "State of the customer account in shop",
					"type": "String"
				},
				{
					"name": "Total spending",
					"id": "total_spent",
					"description": "The total money that the customer has spent at the shop",
					"type": "String"
				},
				{
					"name": "Verified Email",
					"id": "verified_email",
					"type": "String"
				},
				{
					"id": "accepts_marketing",
					"name": "Customer Accepts Marketing?",
					"description": "has value true or false"
				},
				{
					"id": "orders_count",
					"name": "Customer Orders Count"
				},
				{
					"id": "state",
					"name": "Customer State?",
					"description": "has value enabled or disabled"
				},
				{
					"id": "last_order_id",
					"name": "Customer Last Order Id"
				},
				{
					"id": "last_order_name",
					"name": "Customer Last Order Name"
				},
				{
					"id": "multipass_identifier",
					"name": "Customer Multipass Identifier"
				},
				{
					"id": "tax_exempt",
					"name": "Customer Tax Exempt?",
					"description": "has value true or false"
				},
				{
					"id": "phone",
					"name": "Customer Phone"
				},
				{
					"name": "Default Address ID",
					"id": "default_address_id",
					"type": "String"
				},
				{
					"name": "Default Address First Name",
					"id": "default_address_first_name",
					"type": "String"
				},
				{
					"name": "Default Address Last Name",
					"id": "default_address_last_name",
					"type": "String"
				},
				{
					"name": "Default Address Name",
					"id": "default_address_name",
					"type": "String"
				},
				{
					"name": "Default Address line 1",
					"id": "default_address_address1",
					"type": "String"
				},
				{
					"name": "Default Address line 2",
					"id": "default_address_address2",
					"type": "String"
				},
				{
					"name": "Default Address Company",
					"id": "default_address_company",
					"type": "String"
				},
				{
					"name": "Default Address City",
					"id": "default_address_city",
					"type": "String"
				},
				{
					"name": "Default Address Phone",
					"id": "default_address_phone",
					"type": "String"
				},
				{
					"name": "Default Address Province",
					"id": "default_address_province",
					"type": "String"
				},
				{
					"name": "Default Address Country",
					"id": "default_address_country",
					"type": "String"
				},
				{
					"name": "Default Address Province Code",
					"id": "default_address_zip",
					"type": "String"
				},
				{
					"name": "Default Address Country Code",
					"id": "default_address_country_code",
					"type": "String"
				},
				{
					"name": "Default Address Country Name",
					"id": "default_address_country_name",
					"type": "String"
				},
				{
					"name": "Second Address ID",
					"id": "second_address_id",
					"type": "String"
				},
				{
					"name": "Second Address First Name",
					"id": "second_address_first_name",
					"type": "String"
				},
				{
					"name": "Second Address Last Name",
					"id": "second_address_last_name",
					"type": "String"
				},
				{
					"name": "Second Address Name",
					"id": "second_address_name",
					"type": "String"
				},
				{
					"name": "Second Address line 1",
					"id": "second_address_address1",
					"type": "String"
				},
				{
					"name": "Second Address line 2",
					"id": "second_address_address2",
					"type": "String"
				},
				{
					"name": "Second Address Company",
					"id": "second_address_company",
					"type": "String"
				},
				{
					"name": "Second Address City",
					"id": "second_address_city",
					"type": "String"
				},
				{
					"name": "Second Address Phone",
					"id": "second_address_phone",
					"type": "String"
				},
				{
					"name": "Second Address Province",
					"id": "second_address_province",
					"type": "String"
				},
				{
					"name": "Second Address Country",
					"id": "second_address_country",
					"type": "String"
				},
				{
					"name": "Second Address Province Code",
					"id": "default_address_zip",
					"type": "String"
				},
				{
					"name": "Second Address Country Code",
					"id": "second_address_country_code",
					"type": "String"
				},
				{
					"name": "Second Address Country Name",
					"id": "second_address_country_name",
					"type": "String"
				}
			],
			"params": []
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "New Fulfillment Event",
			"id": "new-fulfillment-event",
			"description": "Triggers when there is a new fullfilment event",
			"priority": 1,
			"entity": "invoice",
			"beta": true,
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'fulfillments/create',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && response['statusCode'] == 201) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response) {\n      retObj['error']         = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['message']       = \"Invalid/Missing API response\";\n      return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful deletion of webhook\n   if (response['statusCode'] && response['statusCode'] == 200) {\n        // sending the succes return object\n        retObj['status'] = \"SUCCESS\";\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n\n    var retObj = { status: \"ERROR\" };\n    var responseKeys;\n    var parsedBody;\n\n    // if body is not present in params\n    if (!params || !params.body || !(utils || {}).libDate) {\n        retObj['message'] = \"Invalid/Missing API body or libDate util\";\n        return callback(retObj);\n    } else {\n        parsedBody = params['body'];\n        // extracting the keys of response data of order\n        responseKeys = Object.keys(parsedBody);\n\n        if (responseKeys.length) {\n\n            const parsedEvent = {}\n\n            const dateFields = {\n                created_at: true,\n                updated_at: true,\n                happened_at: true\n            }\n\n            responseKeys\n                .forEach(key => {\n                    const data = parsedBody[key]\n                    if (dateFields[key] && data) {\n                        parsedEvent[key] = utils.libDate.parseJSDateTimeToStandardString(new Date(data))\n                    } else if (key === 'line_items' && data && data.length) {\n                        const line_items = data.slice(0, 5)\n                        line_items\n                            .forEach((item, index) => {\n                                Object.keys(item)\n                                    .forEach(key => {\n                                        const data = item[key]\n                                        if (key === 'discount_allocations' && data && data.length) {\n                                            const discount = data[0]\n                                            parsedEvent[`line_item_${ index + 1 }_discount`] = discount.amount || ''\n                                        } else if (key === 'tax_lines' && data && data.length) {\n                                            const tax_line = data[0]\n                                            parsedEvent[`line_item_${ index + 1 }_title`] = tax_line.title\n                                            parsedEvent[`line_item_${ index + 1 }_price`] = tax_line.price\n                                            parsedEvent[`line_item_${ index + 1 }_rate`] = tax_line.rate\n                                        } else if (key !== 'discount_allocations' && key !== 'properties' && key !== 'tax_lines'){\n                                            parsedEvent[`line_item_${ index + 1 }_${key}`] = data\n                                        }\n                                    })\n                            })\n                    } else {\n                        if (Array.isArray(data)) {\n                            parsedEvent[key] = data.toString()\n                        } else {\n                            parsedEvent[key] = data\n                        }\n                    }\n                })\n            \n            retObj.status = 'SUCCESS'\n            retObj.data = {\n                response: parsedEvent\n            }\n            \n        } else {\n            retObj['error'] = {};\n            retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n            retObj['message'] = \"Trigger data not as expected from shopify webhook\"\n        }\n    }\n    // finally calling the callback function with retObj\n    return callback(retObj);\n}"
			},
			"responseFields": [
				{
					"id": "id",
					"name": "Fulfillment Event Id"
				},
				{
					"id": "fulfillment_id",
					"name": "Fulfillment Event Fulfillment Id"
				},
				{
					"id": "name",
					"name": "Fulfillment Event Name"
				},
				{
					"id": "order_id",
					"name": "Fullfillment Event Order Id"
				},
				{
					"id": "status",
					"name": "Fulfillment Event Status"
				},
				{
					"id": "message",
					"name": "Fulfillment Event Message"
				},
				{
					"id": "happened_at",
					"name": "Fullfillment Event Happened At"
				},
				{
					"id": "address_1",
					"name": "Fulfillment Event Address Line 1"
				},
				{
					"id": "address_2",
					"name": "Fulfillment Event Address Line 2"
				},
				{
					"id": "city",
					"name": "Fulfillment Event Address City"
				},
				{
					"id": "province",
					"name": "Fulfillment Event Address Province"
				},
				{
					"id": "country",
					"name": "Fulfillment Event Address Country"
				},
				{
					"id": "zip",
					"name": "Fulfillment Event Address Zip"
				},
				{
					"id": "lattitude",
					"name": "Fulfillment Event Lattitude"
				},
				{
					"id": "longitude",
					"name": "Fulfillment Event Longitude"
				},
				{
					"id": "shop_id",
					"name": "Fullfillment Event Shop Id"
				},
				{
					"id": "created_at",
					"name": "Fulfillment Event Created At"
				},
				{
					"id": "updated_at",
					"name": "Fulfillment Event Updated At"
				},
				{
					"id": "service",
					"name": "Fullfillment Event Service"
				},
				{
					"id": "tracking_company",
					"name": "Fullfillment Event Tracking Company"
				},
				{
					"id": "shipment_status",
					"name": "Fulfillment Event Shipment Status"
				},
				{
					"id": "location_id",
					"name": "Fulfillment Event Location Id"
				},
				{
					"id": "email",
					"name": "Fulfillment Event Email"
				},
				{
					"id": "destination",
					"name": "Fulfillment Event Destination"
				},
				{
					"id": "tracking_number",
					"name": "Fulfillment Event Tracking Number"
				},
				{
					"id": "tracking_numbers",
					"name": "Fulfillment Event Tracking Numbers",
					"description": "comma seperated list of all tracking numbers"
				},
				{
					"id": "tracking_url",
					"name": "Fulfillment Event Tracking URL"
				},
				{
					"id": "tracking_urls",
					"name": "Fulfillment Event Tracking URLs",
					"description": "comma seperated list of all tracking URLs"
				},
				{
					"id": "line_item_1_id",
					"name": "Line Item 1 Id"
				},
				{
					"id": "line_item_1_variant_id",
					"name": "Line Item 1 Variant Id"
				},
				{
					"id": "line_item_1_title",
					"name": "Line Item 1 Title"
				},
				{
					"id": "line_item_1_quantity",
					"name": "Line Item 1 Quantity"
				},
				{
					"id": "line_item_1_price",
					"name": "Line Item 1 Price"
				},
				{
					"id": "line_item_1_sku",
					"name": "Line Item 1 Sku"
				},
				{
					"id": "line_item_1_variant_title",
					"name": "Line Item 1 Variant Title"
				},
				{
					"id": "line_item_1_vendor",
					"name": "Line Item 1 Vendor"
				},
				{
					"id": "line_item_1_fulfillment_service",
					"name": "Line Item 1 Fulfillment Service"
				},
				{
					"id": "line_item_1_product_id",
					"name": "Line Item 1 Product Id"
				},
				{
					"id": "line_item_1_requires_shipping",
					"name": "Line Item 1 Requires Shipping"
				},
				{
					"id": "line_item_1_taxable",
					"name": "Line Item 1 Taxable"
				},
				{
					"id": "line_item_1_gift_card",
					"name": "Line Item 1 Gift Card"
				},
				{
					"id": "line_item_1_name",
					"name": "Line Item 1 Name"
				},
				{
					"id": "line_item_1_variant_inventory_management",
					"name": "Line Item 1 Variant Inventory Management"
				},
				{
					"id": "line_item_1_product_exists",
					"name": "Line Item 1 Product Exists"
				},
				{
					"id": "line_item_1_fulfillable_quantity",
					"name": "Line Item 1 Fulfillable Quantity"
				},
				{
					"id": "line_item_1_grams",
					"name": "Line Item 1 Grams"
				},
				{
					"id": "line_item_1_total_discount",
					"name": "Line Item 1 Total Discount"
				},
				{
					"id": "line_item_1_fulfillment_status",
					"name": "Line Item 1 Fulfillment Status"
				},
				{
					"id": "line_item_1_rate",
					"name": "Line Item 1 Rate"
				},
				{
					"id": "line_item_2_id",
					"name": "Line Item 2 Id"
				},
				{
					"id": "line_item_2_variant_id",
					"name": "Line Item 2 Variant Id"
				},
				{
					"id": "line_item_2_title",
					"name": "Line Item 2 Title"
				},
				{
					"id": "line_item_2_quantity",
					"name": "Line Item 2 Quantity"
				},
				{
					"id": "line_item_2_price",
					"name": "Line Item 2 Price"
				},
				{
					"id": "line_item_2_sku",
					"name": "Line Item 2 Sku"
				},
				{
					"id": "line_item_2_variant_title",
					"name": "Line Item 2 Variant Title"
				},
				{
					"id": "line_item_2_vendor",
					"name": "Line Item 2 Vendor"
				},
				{
					"id": "line_item_2_fulfillment_service",
					"name": "Line Item 2 Fulfillment Service"
				},
				{
					"id": "line_item_2_product_id",
					"name": "Line Item 2 Product Id"
				},
				{
					"id": "line_item_2_requires_shipping",
					"name": "Line Item 2 Requires Shipping"
				},
				{
					"id": "line_item_2_taxable",
					"name": "Line Item 2 Taxable"
				},
				{
					"id": "line_item_2_gift_card",
					"name": "Line Item 2 Gift Card"
				},
				{
					"id": "line_item_2_name",
					"name": "Line Item 2 Name"
				},
				{
					"id": "line_item_2_variant_inventory_management",
					"name": "Line Item 2 Variant Inventory Management"
				},
				{
					"id": "line_item_2_product_exists",
					"name": "Line Item 2 Product Exists"
				},
				{
					"id": "line_item_2_fulfillable_quantity",
					"name": "Line Item 2 Fulfillable Quantity"
				},
				{
					"id": "line_item_2_grams",
					"name": "Line Item 2 Grams"
				},
				{
					"id": "line_item_2_total_discount",
					"name": "Line Item 2 Total Discount"
				},
				{
					"id": "line_item_2_fulfillment_status",
					"name": "Line Item 2 Fulfillment Status"
				},
				{
					"id": "line_item_2_rate",
					"name": "Line Item 2 Rate"
				},
				{
					"id": "line_item_3_id",
					"name": "Line Item 3 Id"
				},
				{
					"id": "line_item_3_variant_id",
					"name": "Line Item 3 Variant Id"
				},
				{
					"id": "line_item_3_title",
					"name": "Line Item 3 Title"
				},
				{
					"id": "line_item_3_quantity",
					"name": "Line Item 3 Quantity"
				},
				{
					"id": "line_item_3_price",
					"name": "Line Item 3 Price"
				},
				{
					"id": "line_item_3_sku",
					"name": "Line Item 3 Sku"
				},
				{
					"id": "line_item_3_variant_title",
					"name": "Line Item 3 Variant Title"
				},
				{
					"id": "line_item_3_vendor",
					"name": "Line Item 3 Vendor"
				},
				{
					"id": "line_item_3_fulfillment_service",
					"name": "Line Item 3 Fulfillment Service"
				},
				{
					"id": "line_item_3_product_id",
					"name": "Line Item 3 Product Id"
				},
				{
					"id": "line_item_3_requires_shipping",
					"name": "Line Item 3 Requires Shipping"
				},
				{
					"id": "line_item_3_taxable",
					"name": "Line Item 3 Taxable"
				},
				{
					"id": "line_item_3_gift_card",
					"name": "Line Item 3 Gift Card"
				},
				{
					"id": "line_item_3_name",
					"name": "Line Item 3 Name"
				},
				{
					"id": "line_item_3_variant_inventory_management",
					"name": "Line Item 3 Variant Inventory Management"
				},
				{
					"id": "line_item_3_product_exists",
					"name": "Line Item 3 Product Exists"
				},
				{
					"id": "line_item_3_fulfillable_quantity",
					"name": "Line Item 3 Fulfillable Quantity"
				},
				{
					"id": "line_item_3_grams",
					"name": "Line Item 3 Grams"
				},
				{
					"id": "line_item_3_total_discount",
					"name": "Line Item 3 Total Discount"
				},
				{
					"id": "line_item_3_fulfillment_status",
					"name": "Line Item 3 Fulfillment Status"
				},
				{
					"id": "line_item_3_rate",
					"name": "Line Item 3 Rate"
				},
				{
					"id": "line_item_4_id",
					"name": "Line Item 4 Id"
				},
				{
					"id": "line_item_4_variant_id",
					"name": "Line Item 4 Variant Id"
				},
				{
					"id": "line_item_4_title",
					"name": "Line Item 4 Title"
				},
				{
					"id": "line_item_4_quantity",
					"name": "Line Item 4 Quantity"
				},
				{
					"id": "line_item_4_price",
					"name": "Line Item 4 Price"
				},
				{
					"id": "line_item_4_sku",
					"name": "Line Item 4 Sku"
				},
				{
					"id": "line_item_4_variant_title",
					"name": "Line Item 4 Variant Title"
				},
				{
					"id": "line_item_4_vendor",
					"name": "Line Item 4 Vendor"
				},
				{
					"id": "line_item_4_fulfillment_service",
					"name": "Line Item 4 Fulfillment Service"
				},
				{
					"id": "line_item_4_product_id",
					"name": "Line Item 4 Product Id"
				},
				{
					"id": "line_item_4_requires_shipping",
					"name": "Line Item 4 Requires Shipping"
				},
				{
					"id": "line_item_4_taxable",
					"name": "Line Item 4 Taxable"
				},
				{
					"id": "line_item_4_gift_card",
					"name": "Line Item 4 Gift Card"
				},
				{
					"id": "line_item_4_name",
					"name": "Line Item 4 Name"
				},
				{
					"id": "line_item_4_variant_inventory_management",
					"name": "Line Item 4 Variant Inventory Management"
				},
				{
					"id": "line_item_4_product_exists",
					"name": "Line Item 4 Product Exists"
				},
				{
					"id": "line_item_4_fulfillable_quantity",
					"name": "Line Item 4 Fulfillable Quantity"
				},
				{
					"id": "line_item_4_grams",
					"name": "Line Item 4 Grams"
				},
				{
					"id": "line_item_4_total_discount",
					"name": "Line Item 4 Total Discount"
				},
				{
					"id": "line_item_4_fulfillment_status",
					"name": "Line Item 4 Fulfillment Status"
				},
				{
					"id": "line_item_4_rate",
					"name": "Line Item 4 Rate"
				},
				{
					"id": "line_item_5_id",
					"name": "Line Item 5 Id"
				},
				{
					"id": "line_item_5_variant_id",
					"name": "Line Item 5 Variant Id"
				},
				{
					"id": "line_item_5_title",
					"name": "Line Item 5 Title"
				},
				{
					"id": "line_item_5_quantity",
					"name": "Line Item 5 Quantity"
				},
				{
					"id": "line_item_5_price",
					"name": "Line Item 5 Price"
				},
				{
					"id": "line_item_5_sku",
					"name": "Line Item 5 Sku"
				},
				{
					"id": "line_item_5_variant_title",
					"name": "Line Item 5 Variant Title"
				},
				{
					"id": "line_item_5_vendor",
					"name": "Line Item 5 Vendor"
				},
				{
					"id": "line_item_5_fulfillment_service",
					"name": "Line Item 5 Fulfillment Service"
				},
				{
					"id": "line_item_5_product_id",
					"name": "Line Item 5 Product Id"
				},
				{
					"id": "line_item_5_requires_shipping",
					"name": "Line Item 5 Requires Shipping"
				},
				{
					"id": "line_item_5_taxable",
					"name": "Line Item 5 Taxable"
				},
				{
					"id": "line_item_5_gift_card",
					"name": "Line Item 5 Gift Card"
				},
				{
					"id": "line_item_5_name",
					"name": "Line Item 5 Name"
				},
				{
					"id": "line_item_5_variant_inventory_management",
					"name": "Line Item 5 Variant Inventory Management"
				},
				{
					"id": "line_item_5_product_exists",
					"name": "Line Item 5 Product Exists"
				},
				{
					"id": "line_item_5_fulfillable_quantity",
					"name": "Line Item 5 Fulfillable Quantity"
				},
				{
					"id": "line_item_5_grams",
					"name": "Line Item 5 Grams"
				},
				{
					"id": "line_item_5_total_discount",
					"name": "Line Item 5 Total Discount"
				},
				{
					"id": "line_item_5_fulfillment_status",
					"name": "Line Item 5 Fulfillment Status"
				},
				{
					"id": "line_item_5_rate",
					"name": "Line Item 5 Rate"
				}
			],
			"params": []
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "New Order",
			"id": "new-order",
			"description": "Triggers when there is a new Order",
			"priority": 1,
			"entity": "invoice",
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'orders/create',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && response['statusCode'] == 201) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response) {\n      retObj['error']         = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['message']       = \"Invalid/Missing API response\";\n      return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful deletion of webhook\n   if (response['statusCode'] && response['statusCode'] == 200) {\n        // sending the succes return object\n        retObj['status'] = \"SUCCESS\";\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n\n    var BillingAddressPrefix = 'billing_address_';\n    var shippingAddressPrefix = 'shipping_address_';\n    var customerPrefix = 'customer_'\n    var SkipFields = ['gateway', 'test'];\n    var retObj = { status: \"ERROR\" };\n    var customerData = {};\n    var orderData = {};\n    var maxItemScan = 5;\n    var newOrder = {};\n    var newOrderObj = {};\n    var responseKeys;\n    var parsedBody;\n\n    // if body is not present in params\n    if (!params || !params.body || !(utils || {}).libDate) {\n        retObj['message'] = \"Invalid/Missing API body or libDate util\";\n        return callback(retObj);\n    } else {\n        parsedBody = params['body'];\n        // extracting the keys of response data of order\n        responseKeys = Object.keys(parsedBody);\n\n        if (responseKeys.length) {\n\n            // iterating each key of the order related data json\n            responseKeys.forEach(function (key) {\n\n                if (key === 'line_items') {\n\n                    //creating comma separated list of all line item names and ids\n\n                    let accumulated = null\n\n                    accumulated = parsedBody[key].reduce((acc, value) => {\n                        acc.line_item_ids.push(value.id ? value.id : '')\n                        acc.line_item_names.push(value.name ? value.name : '')\n                        acc.line_item_product_codes.push(value.product_id ? value.product_id : '')\n                        acc.line_item_titles.push(value.title ? value.title : '')\n                        acc.line_item_variant_ids.push(value.variant_id ? value.variant_id : '')\n                        acc.line_item_variant_titles.push(value.variant_title ? value.variant_title : '')\n                        acc.line_item_quantities.push(value.quantity ? value.quantity : '')\n                        acc.line_item_prices.push(value.price ? value.price : '')\n                        acc.line_item_skus.push(value.sku ? value.sku : '')\n                        acc.line_item_weights.push(value.grams ? value.grams : '')\n\n                        return acc\n                    }, {\n                            line_item_ids: [],\n                            line_item_names: [],\n                            line_item_product_codes: [],\n                            line_item_titles: [],\n                            line_item_variant_ids: [],\n                            line_item_variant_titles: [],\n                            line_item_quantities: [],\n                            line_item_prices: [],\n                            line_item_skus: [],\n                            line_item_weights: []\n                        }\n                    )\n\n                    Object.keys(accumulated).forEach(prop => {\n                        let fld = prop\n                        let data = accumulated[prop]\n\n                        if (data && data.length) {\n                            newOrder[fld] = data.toString()\n                        }\n                    })\n\n                    parsedBody[key].some(function (element, index) {\n                        // deciding the prefix for items\n                        const prefix = ['first', 'second', 'third', 'fourth', 'fifth']\n\n                        Object.keys(element).forEach(function (field) {\n                            if (field != 'properties' && field != 'tax_lines')\n                                newOrder[`${prefix[index]}_item_${field}`] = element[field] || '';\n                        }, this);\n\n                        // returning after maximum scanning of 3 items of orders\n                        return maxItemScan === index + 1;\n                    }, this);\n\n                } else if (key === 'billing_address' || key === 'shipping_address' || key === 'customer') {\n                    // extracting the basic info of customer \n                    if (key === 'customer') {\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n\n                            if (field === 'created_at' || field === 'updated_at')\n                                customerData[customerPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key][field]) || '';\n                            else if (field != 'default_address')\n                                customerData[customerPrefix + field] = parsedBody[key][field] || '';\n\n                        }, this);\n                    } else {\n                        // extracting the billing and shipping address of order\n                        var prefix = (key === 'billing_address') ? BillingAddressPrefix : shippingAddressPrefix;\n\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n                            newOrder[prefix + field] = parsedBody[key][field] || '';\n                        }, this);\n                    }\n\n                } else if (key === 'shipping_lines') {\n                    let shipping_lines = parsedBody[key]\n                    let selectFields = {\n                        title: true,\n                        price: true,\n                        source: true,\n                        phone: true,\n                        carrier_identifier: true\n                    }\n\n                    if (shipping_lines && shipping_lines.length) {\n\n                        Object.keys(shipping_lines[0]).forEach(field => {\n                            let data = shipping_lines[0][field]\n\n                            if (selectFields[field] && data) {\n                                orderData[`shipping_line_${field}`] = data\n                            }\n\n                        })\n                    }\n\n                } else if (key != 'refunds' && key != 'fulfillments' && key != 'tax_lines'\n                    && key != 'discount_codes' && key != 'note_attributes' && key != 'payment_gateway_names') {\n\n                    // standard format of date\n                    if (key === 'created_at' || key === 'updated_at' || key === 'processed_at')\n                        orderData[key] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key]) || '';\n                    else\n                        orderData[key] = parsedBody[key] || '';\n                    // extracting all the other non nested keys\n                }\n            }, this);\n\n            //parsing custom fields\n            const noteAttributes = parsedBody.note_attributes\n\n            if (noteAttributes && Array.isArray(noteAttributes) && noteAttributes.length) {\n                noteAttributes\n                    .forEach(attr => {\n                        if (attr.name && attr.value) {\n                            const key = `additional_details_${utils.libText.encodeKey(attr.name)}`\n                            newOrderObj[key] = attr.value\n                        } \n                    })\n            }\n\n            const lineItems = parsedBody.line_items.slice(0, 5)\n\n            if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n                \n                const indexMapping = ['first', 'second', 'third', 'fourth', 'fifth']\n                lineItems\n                    .forEach((item, index) => {\n                        const properties = item.properties\n                        if (properties && Array.isArray(properties) && properties.length) {\n                            properties.forEach(prop => {\n                                if (prop.name && prop.value) {\n                                    newOrderObj[`${indexMapping[index]}_item_property_${utils.libText.encodeKey(prop.name)}`] = prop.value\n                                }\n                            })\n                        }\n                    })\n            }\n\n            const discountCodes = parsedBody.discount_codes\n\n            if (discountCodes && Array.isArray(discountCodes) && discountCodes.length) {\n                newOrderObj.discount_codes = discountCodes\n                    .map(dc => dc.code)\n                    .toString()\n            }\n\n            const landingSite = parsedBody.landing_site\n\n            if (landingSite) {\n                let utmParams = {}\n                const splitUrl = landingSite.split('?')\n                if (splitUrl[1]) {\n                    utmParams = splitUrl[1]\n                        .split('&')\n                        .reduce((acc, next) => {\n                            const splitParams = next.split('=')\n                            if (splitParams && splitParams.length === 2) {\n                                acc[splitParams[0]] = splitParams[1]\n                            }\n                            return acc\n                        }, {})\n                }\n                if(Object.keys(utmParams).length) {\n                    Object.keys(utmParams)\n                        .forEach(key => {\n                            newOrderObj[`campaign_${key}`] = utmParams[key]\n                        })\n                }\n            }\n\n            // reordering the JSON data\n            [orderData, customerData, newOrder].forEach(function (jsonObj) {\n                Object.keys(jsonObj).forEach(function (key) {\n                    newOrderObj[key] = jsonObj[key];\n                }, this);\n            }, this);\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { \"response\": newOrderObj };\n\n        } else {\n            retObj['error'] = {};\n            retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n            retObj['message'] = \"Trigger data not as expected from shopify webhook\"\n        }\n    }\n    // finally calling the callback function with retObj\n    callback(retObj);\n}"
			},
			"dynamicResponseFields": true,
			"dynamicResponseFieldsRequest": "function dynamicResponseFieldsRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/orders.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      limit: 20,\n      status: 'any',\n      fields: 'line_items,note_attributes,name'\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"dynamicResponseFieldsParse": "function dynamicResponseFieldsParse(params, utils, callback) {\n  const retObj = {}\n  const capitalize = word => word[0].toUpperCase() + word.slice(1, word.length).toLowerCase()\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n\n    retObj.status = 'SUCCESS'\n    retObj.data = []\n\n    if (body && body.orders && body.orders.length) {\n      const responseObjArray = []\n      const noteAtrrObj = {}\n      const propObj = {}\n\n      body.orders\n        .forEach(order => {\n          //note atrributes\n          const note_attributes = order.note_attributes\n          if (note_attributes && Array.isArray(note_attributes) && note_attributes.length) {\n            note_attributes\n              .forEach(attr => {\n                if (attr.name) {\n                  noteAtrrObj[attr.name] = attr.value || ''\n                }\n              })\n          }\n          //end note attributes\n\n          //line item properties\n          const lineItems = order.line_items\n          if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n            lineItems\n              .forEach(line => {\n                const props = line.properties\n                if (props && Array.isArray(props) && props.length) {\n                  props.forEach(prop => {\n                    if (prop.name) {\n                      propObj[prop.name] = prop.value || ''\n                    }\n                  })\n                }\n              })\n          }\n        })\n\n      Object.keys(noteAtrrObj)\n        .forEach(key => {\n          responseObjArray.push({\n            id: `additional_details_${utils.libText.encodeKey(key)}`,\n            name: `Additional Details ${key}`\n          })\n        })\n\n      if (Object.keys(propObj).length) {\n        ['first', 'second', 'third', 'fourth', 'fifth'].forEach(lineNum => {\n          Object.keys(propObj)\n            .forEach(key => {\n              responseObjArray.push({\n                id: `${lineNum}_item_property_${utils.libText.encodeKey(key)}`,\n                name: `${capitalize(lineNum)} Item Property ${key}`\n              })\n            })\n        })\n      }\n\n      retObj.data = responseObjArray\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"responseFields": [
				{
					"name": "Order ID",
					"id": "id",
					"description": "Shopify id of the order",
					"type": "String"
				},
				{
					"name": "Order Name",
					"id": "name",
					"type": "String"
				},
				{
					"name": "Email Address",
					"id": "email",
					"description": "Email address of customer",
					"type": "String"
				},
				{
					"name": "Closed At",
					"id": "closed_at",
					"description": "The date and time when the order was closed",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Shop Number",
					"id": "number",
					"description": "Unique identifier of the shop",
					"type": "String"
				},
				{
					"name": "Note",
					"id": "note",
					"type": "String"
				},
				{
					"name": "Token",
					"id": "token",
					"description": "Unique identifier for a particular order",
					"type": "String"
				},
				{
					"id": "discount_codes",
					"name": "Discount Codes Applied",
					"description": "comma seperated list of all discount codes applied"
				},
				{
					"name": "Total Price",
					"id": "total_price",
					"description": "The sum of prices of all the items in the order, taxes and discounts included",
					"type": "String"
				},
				{
					"name": "Subtotal Price",
					"id": "subtotal_price",
					"description": "Price of the order before shipping and taxes",
					"type": "String"
				},
				{
					"name": "Total Weight",
					"id": "total_weight",
					"description": "The sum of all the weights of the line items in the order(grams)",
					"type": "String"
				},
				{
					"name": "Tax Included",
					"id": "taxes_included",
					"description": "whether or not taxes are included in the order subtotal",
					"type": "String"
				},
				{
					"name": "Total Tax",
					"id": "total_tax",
					"type": "String"
				},
				{
					"name": "Currency",
					"id": "currency",
					"type": "String"
				},
				{
					"name": "Financial Status",
					"id": "financial_status",
					"type": "String"
				},
				{
					"name": "Confirmation Status",
					"id": "confirmed",
					"type": "String"
				},
				{
					"name": "Total Discounts",
					"id": "total_discounts",
					"type": "String"
				},
				{
					"name": "Total Line Item Price",
					"id": "total_line_items_price",
					"description": "The sum of all the prices of all the items in the order",
					"type": "String"
				},
				{
					"name": "Cart Token",
					"id": "cart_token",
					"description": "Unique token of cart attached to order",
					"type": "String"
				},
				{
					"name": "Buyer Accepts Marketing",
					"id": "buyer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Referring Site",
					"id": "referring_site",
					"description": "The website that the customer clicked on to come to the shop",
					"type": "String"
				},
				{
					"name": "Landing Site",
					"id": "landing_site",
					"description": "The URL for the page where the buyer landed when entering the shop",
					"type": "String"
				},
				{
					"id": "campaign_utm_source",
					"name": "Affiliate Link UTM Source"
				},
				{
					"id": "campaign_utm_medium",
					"name": "Affiliate Link UTM Medium"
				},
				{
					"id": "campaign_utm_campaign",
					"name": "Affiliate Link UTM Campaign Name"
				},
				{
					"id": "campaign_utm_content",
					"name": "Affiliate Link UTM Content"
				},
				{
					"name": "Total Price In USD",
					"id": "total_price_usd",
					"type": "String"
				},
				{
					"name": "User ID",
					"id": "user_id",
					"description": "The unique numerical identifier for the user logged into the terminal at the time the order was processed at POS",
					"type": "String"
				},
				{
					"name": "Location ID",
					"id": "location_id",
					"description": "The unique numeric identifier for the physical location of POS at which the order is created",
					"type": "String"
				},
				{
					"name": "Processing Date And Time",
					"id": "processed_at",
					"type": "String"
				},
				{
					"name": "Browser IP Address",
					"id": "browser_ip",
					"description": "IP address of the browser used by customer at the time of placing pf order",
					"type": "String"
				},
				{
					"name": "Order Number",
					"id": "order_number",
					"description": "Unique order number to be used by shop owners and customers",
					"type": "String"
				},
				{
					"name": "Processing Method",
					"id": "processing_method",
					"description": "Valid methods are: checkout, direct, manual, offsite or express",
					"type": "String"
				},
				{
					"id": "checkout_id",
					"name": "Order Checkout Id"
				},
				{
					"id": "checkout_token",
					"name": "Order Checkout Token"
				},
				{
					"id": "phone",
					"name": "Order Phone"
				},
				{
					"id": "customer_locale",
					"name": "Order Customer Locale"
				},
				{
					"id": "gateway",
					"name": "Order Payment Gateway"
				},
				{
					"name": "Order Fulfillment Status",
					"id": "fulfillment_status",
					"type": "String"
				},
				{
					"name": "Source Name",
					"id": "source_name",
					"description": "Source of the creation of order, example: shopify_draft_order, web etc",
					"type": "String"
				},
				{
					"name": "Tags",
					"id": "tags",
					"type": "String"
				},
				{
					"name": "Contact Email Address",
					"id": "contact_email",
					"type": "String"
				},
				{
					"name": "Order Status URL",
					"id": "order_status_url",
					"description": "The url pointing to the checkout accessible from the web",
					"type": "String"
				},
				{
					"name": "Customer ID",
					"id": "customer_id",
					"type": "String"
				},
				{
					"name": "Customer First Name",
					"id": "customer_first_name",
					"type": "String"
				},
				{
					"name": "Customer Last Name",
					"id": "customer_last_name",
					"type": "String"
				},
				{
					"name": "Customer Email Address",
					"id": "customer_email",
					"type": "String"
				},
				{
					"name": "Customer Phone Number",
					"id": "customer_phone",
					"type": "String"
				},
				{
					"name": "Customer Accepts Marketing",
					"id": "customer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Customer Creation Date And Time",
					"id": "customer_created_at",
					"type": "String"
				},
				{
					"name": "Customer Updation Date And Time",
					"id": "customer_updated_at",
					"type": "String"
				},
				{
					"name": "Customer Order Count",
					"id": "customer_orders_count",
					"type": "String"
				},
				{
					"name": "Customer Account State",
					"id": "customer_state",
					"type": "String"
				},
				{
					"name": "Customer Total Spendings",
					"id": "customer_total_spent",
					"type": "String"
				},
				{
					"name": "Customer Last Order ID",
					"id": "customer_last_order_id",
					"type": "String"
				},
				{
					"name": "Customer Note",
					"id": "customer_note",
					"type": "String"
				},
				{
					"name": "Customer Email Verified",
					"id": "customer_verified_email",
					"type": "String"
				},
				{
					"name": "Customer Tax Exempted",
					"id": "customer_tax_exempt",
					"type": "String"
				},
				{
					"name": "Customer Tags",
					"id": "customer_tags",
					"type": "String"
				},
				{
					"name": "Customer Last Order Name",
					"id": "customer_last_order_name",
					"type": "String"
				},
				{
					"name": "All Line Item Ids",
					"id": "line_item_ids",
					"type": "String",
					"description": "comma seperated list of line ids"
				},
				{
					"name": "All Line Item Product Codes",
					"id": "line_item_product_codes",
					"type": "String",
					"description": "comma seperated list of product codes"
				},
				{
					"name": "All Line Item Product Names",
					"id": "line_item_names",
					"type": "String",
					"description": "comma seperated list of product names"
				},
				{
					"name": "All Line Item Product Titles",
					"id": "line_item_titles",
					"type": "String",
					"description": "comma seperated list of product titles"
				},
				{
					"name": "All Line Item Product Variant Ids",
					"id": "line_item_variant_ids",
					"type": "String",
					"description": "comma seperated list of product variant ids"
				},
				{
					"name": "All Line Item Product Variant Titles",
					"id": "line_item_variant_titles",
					"type": "String",
					"description": "comma seperated list of product variant titles"
				},
				{
					"name": "All Line Item Quantities",
					"id": "line_item_quantities",
					"type": "String",
					"description": "comma seperated list of product quantities"
				},
				{
					"name": "All Line Item Prices",
					"id": "line_item_prices",
					"type": "String",
					"description": "comma seperated list of product unit prices"
				},
				{
					"name": "All Line Item Skus",
					"id": "line_item_skus",
					"type": "String",
					"description": "comma seperated list of product skus"
				},
				{
					"name": "All Line Item Product Weights",
					"id": "line_item_weights",
					"type": "String",
					"description": "comma seperated list of product weights"
				},
				{
					"name": "First Item ID",
					"id": "first_item_id",
					"type": "String"
				},
				{
					"name": "First Item Name",
					"id": "first_item_name",
					"type": "String"
				},
				{
					"name": "First Item Product ID",
					"id": "first_item_product_id",
					"type": "String"
				},
				{
					"name": "First Item Variant ID",
					"id": "first_item_variant_id",
					"type": "String"
				},
				{
					"name": "First Item Variant Title",
					"id": "first_item_variant_title",
					"type": "String"
				},
				{
					"name": "First Item Title",
					"id": "first_item_title",
					"type": "String"
				},
				{
					"name": "First Item Quantity",
					"id": "first_item_quantity",
					"type": "String"
				},
				{
					"name": "First Item Unit Price",
					"id": "first_item_price",
					"type": "String"
				},
				{
					"id": "first_item_sku",
					"name": "First Item SKU"
				},
				{
					"id": "first_item_grams",
					"name": "First Item Weight (grams)"
				},
				{
					"id": "first_item_gift_card",
					"name": "First Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "First Item Vendor",
					"id": "first_item_vendor",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Service",
					"id": "first_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "First Item Requires Shipping",
					"id": "first_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "First Item Taxable",
					"id": "first_item_taxable",
					"type": "String"
				},
				{
					"name": "First Item Exists",
					"id": "first_item_product_exists",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "First Item Total Discount",
					"id": "first_item_total_discount",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item ID",
					"id": "second_item_id",
					"type": "String"
				},
				{
					"name": "Second Item Name",
					"id": "second_item_name",
					"type": "String"
				},
				{
					"name": "Second Item Product ID",
					"id": "second_item_product_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant ID",
					"id": "second_item_variant_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant Title",
					"id": "second_item_variant_title",
					"type": "String"
				},
				{
					"name": "Second Item Title",
					"id": "second_item_title",
					"type": "String"
				},
				{
					"name": "Second Item Quantity",
					"id": "second_item_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Unit Price",
					"id": "second_item_price",
					"type": "String"
				},
				{
					"id": "second_item_sku",
					"name": "Second Item SKU"
				},
				{
					"id": "second_item_grams",
					"name": "Second Item Weight (grams)"
				},
				{
					"id": "second_item_gift_card",
					"name": "Second Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Second Item Vendor",
					"id": "second_item_vendor",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Service",
					"id": "second_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Second Item Requires Shipping",
					"id": "second_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Second Item Taxable",
					"id": "second_item_taxable",
					"type": "String"
				},
				{
					"name": "Second Item Exists",
					"id": "second_item_product_exists",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Total Discount",
					"id": "second_item_total_discount",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item ID",
					"id": "third_item_id",
					"type": "String"
				},
				{
					"name": "Third Item Name",
					"id": "third_item_name",
					"type": "String"
				},
				{
					"name": "Third Item Product ID",
					"id": "third_item_product_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant ID",
					"id": "third_item_variant_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant Title",
					"id": "third_item_variant_title",
					"type": "String"
				},
				{
					"name": "Third Item Title",
					"id": "third_item_title",
					"type": "String"
				},
				{
					"name": "Third Item Quantity",
					"id": "third_item_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Unit Price",
					"id": "third_item_price",
					"type": "String"
				},
				{
					"id": "third_item_sku",
					"name": "Third Item SKU"
				},
				{
					"id": "third_item_grams",
					"name": "Third Item Weight (grams)"
				},
				{
					"id": "third_item_gift_card",
					"name": "Third Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Third Item Vendor",
					"id": "third_item_vendor",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Service",
					"id": "third_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Third Item Requires Shipping",
					"id": "third_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Third Item Taxable",
					"id": "third_item_taxable",
					"type": "String"
				},
				{
					"name": "Third Item Exists",
					"id": "third_item_product_exists",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Total Discount",
					"id": "third_item_total_discount",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "third_item_properties",
					"name": "Third Item Properties"
				},
				{
					"name": "Fourth Item ID",
					"id": "fourth_item_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Name",
					"id": "fourth_item_name",
					"type": "String"
				},
				{
					"name": "Fourth Item Product ID",
					"id": "fourth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant ID",
					"id": "fourth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant Title",
					"id": "fourth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Title",
					"id": "fourth_item_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Quantity",
					"id": "fourth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Unit Price",
					"id": "fourth_item_price",
					"type": "String"
				},
				{
					"id": "fourth_item_sku",
					"name": "Fourth Item SKU"
				},
				{
					"id": "fourth_item_grams",
					"name": "Fourth Item Weight (grams)"
				},
				{
					"id": "fourth_item_gift_card",
					"name": "Fourth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fourth Item Vendor",
					"id": "fourth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Service",
					"id": "fourth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fourth Item Requires Shipping",
					"id": "fourth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fourth Item Taxable",
					"id": "fourth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fourth Item Exists",
					"id": "fourth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Total Discount",
					"id": "fourth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fourth_item_properties",
					"name": "Fourth Item Properties"
				},
				{
					"name": "Fifth Item ID",
					"id": "fifth_item_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Name",
					"id": "fifth_item_name",
					"type": "String"
				},
				{
					"name": "Fifth Item Product ID",
					"id": "fifth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant ID",
					"id": "fifth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant Title",
					"id": "fifth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Title",
					"id": "fifth_item_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Quantity",
					"id": "fifth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Unit Price",
					"id": "fifth_item_price",
					"type": "String"
				},
				{
					"id": "fifth_item_sku",
					"name": "Fifth Item SKU"
				},
				{
					"id": "fifth_item_grams",
					"name": "Fifth Item Weight (grams)"
				},
				{
					"id": "fifth_item_gift_card",
					"name": "Fifth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fifth Item Vendor",
					"id": "fifth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Service",
					"id": "fifth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fifth Item Requires Shipping",
					"id": "fifth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fifth Item Taxable",
					"id": "fifth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fifth Item Exists",
					"id": "fifth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Total Discount",
					"id": "fifth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fifth_item_properties",
					"name": "Fifth Item Properties"
				},
				{
					"name": "Billing address First Name",
					"id": "billing_address_first_name",
					"type": "String"
				},
				{
					"name": "Billing address Last Name",
					"id": "billing_address_last_name",
					"type": "String"
				},
				{
					"name": "Billing Address Name",
					"id": "billing_address_name",
					"type": "String"
				},
				{
					"name": "Billing address Line 1",
					"id": "billing_address_address1",
					"type": "String"
				},
				{
					"name": "Billing address Line 2",
					"id": "billing_address_address2",
					"type": "String"
				},
				{
					"name": "Billing address Phone Number",
					"id": "billing_address_phone",
					"type": "String"
				},
				{
					"name": "Billing address City",
					"id": "billing_address_city",
					"type": "String"
				},
				{
					"name": "Billing address Zip",
					"id": "billing_address_zip",
					"type": "String"
				},
				{
					"name": "Billing address Province",
					"id": "billing_address_province",
					"type": "String"
				},
				{
					"name": "Billing address Country",
					"id": "billing_address_country",
					"type": "String"
				},
				{
					"name": "Billing address Company",
					"id": "billing_address_company",
					"type": "String"
				},
				{
					"name": "Billing address Country Code",
					"id": "billing_address_country_code",
					"type": "String"
				},
				{
					"name": "Billing address Province Code",
					"id": "billing_address_province_code",
					"type": "String"
				},
				{
					"name": "Shipping address First Name",
					"id": "shipping_address_first_name",
					"type": "String"
				},
				{
					"name": "Shipping address Last Name",
					"id": "shipping_address_last_name",
					"type": "String"
				},
				{
					"name": "Shipping Address Name",
					"id": "shipping_address_name",
					"type": "String"
				},
				{
					"name": "Shipping address Line 1",
					"id": "shipping_address_address1",
					"type": "String"
				},
				{
					"name": "Shipping address Line 2",
					"id": "shipping_address_address2",
					"type": "String"
				},
				{
					"name": "Shipping address Phone Number",
					"id": "shipping_address_phone",
					"type": "String"
				},
				{
					"name": "Shipping address City",
					"id": "shipping_address_city",
					"type": "String"
				},
				{
					"name": "Shipping address Zip",
					"id": "shipping_address_zip",
					"type": "String"
				},
				{
					"name": "Shipping address Province",
					"id": "shipping_address_province",
					"type": "String"
				},
				{
					"name": "Shipping address Country",
					"id": "shipping_address_country",
					"type": "String"
				},
				{
					"name": "Shipping address Company",
					"id": "shipping_address_company",
					"type": "String"
				},
				{
					"name": "Shipping address Country Code",
					"id": "shipping_address_country_code",
					"type": "String"
				},
				{
					"name": "Shipping address Province Code",
					"id": "shipping_address_province_code",
					"type": "String"
				},
				{
					"id": "shipping_line_title",
					"name": "Order Shipping Line Title"
				},
				{
					"id": "shipping_line_price",
					"name": "Order Shipping Line Price"
				},
				{
					"id": "shipping_line_source",
					"name": "Order Shipping Line Source"
				},
				{
					"id": "shipping_line_phone",
					"name": "Order Shipping Line Phone"
				},
				{
					"id": "shipping_line_carrier_identifier",
					"name": "Order Shipping Line Carrier Identifier"
				}
			],
			"params": []
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "Order Cancellation",
			"id": "new-order-cancellation",
			"description": "Triggers when an Order is Cancelled",
			"priority": 2,
			"entity": "invoice",
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'orders/cancelled',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && response['statusCode'] == 201) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n            // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response) {\n      retObj['error']         = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['message']       = \"Invalid/Missing API response\";\n      return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful deletion of webhook\n   if (response['statusCode'] && response['statusCode'] == 200) {\n        // sending the succes return object\n        retObj['status'] = \"SUCCESS\";\n\n    } else {\n            // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n\n    var BillingAddressPrefix = 'billing_address_';\n    var shippingAddressPrefix = 'shipping_address_';\n    var customerPrefix = 'customer_'\n    var SkipFields = ['gateway', 'test'];\n    var retObj = { status: \"ERROR\" };\n    var customerData = {};\n    var orderData = {};\n    var newCancelledOrderObj = {};\n    var maxItemScan = 5;\n    var newCancelledOrder = {};\n    var responseKeys;\n    var parsedBody;\n\n    // if body is not present in params\n    if (!params || !params.body || !(utils || {}).libDate) {\n        retObj['message'] = \"Invalid/Missing API body or libDate util\";\n        return callback(retObj);\n    } else {\n        parsedBody = params['body'];\n        // extracting the keys of response data of order\n        responseKeys = Object.keys(parsedBody);\n\n        if (responseKeys.length) {\n\n            // iterating each key of the order related data json\n            responseKeys.forEach(function (key) {\n\n                if (key === 'line_items') {\n\n                    //creating comma separated list of all line item names and ids\n\n                    let accumulated = null\n\n                    accumulated = parsedBody[key].reduce((acc, value) => {\n                        acc.line_item_ids.push(value.id ? value.id : '')\n                        acc.line_item_names.push(value.name ? value.name : '')\n                        acc.line_item_product_codes.push(value.product_id ? value.product_id : '')\n                        acc.line_item_titles.push(value.title ? value.title : '')\n                        acc.line_item_variant_ids.push(value.variant_id ? value.variant_id : '')\n                        acc.line_item_variant_titles.push(value.variant_title ? value.variant_title : '')\n                        acc.line_item_quantities.push(value.quantity ? value.quantity : '')\n                        acc.line_item_prices.push(value.price ? value.price : '')\n                        acc.line_item_skus.push(value.sku ? value.sku : '')\n                        acc.line_item_weights.push(value.grams ? value.grams : '')\n\n                        return acc\n                    }, {\n                            line_item_ids: [],\n                            line_item_names: [],\n                            line_item_product_codes: [],\n                            line_item_titles: [],\n                            line_item_variant_ids: [],\n                            line_item_variant_titles: [],\n                            line_item_quantities: [],\n                            line_item_prices: [],\n                            line_item_skus: [],\n                            line_item_weights: []\n                        }\n                    )\n\n                    Object.keys(accumulated).forEach(prop => {\n                        let fld = prop\n                        let data = accumulated[prop]\n\n                        if (data && data.length) {\n                            newCancelledOrder[fld] = data.toString()\n                        }\n                    })\n\n                    parsedBody[key].some(function (element, index) {\n                        // deciding the prefix for items\n                        const prefix = ['first', 'second', 'third', 'fourth', 'fifth']\n\n                        Object.keys(element).forEach(function (field) {\n                            if (field != 'properties' && field != 'tax_lines')\n                                newCancelledOrder[`${prefix[index]}_item_${field}`] = element[field] || '';\n                        }, this);\n\n                        // returning after maximum scanning of 3 items of orders\n                        return maxItemScan === index + 1;\n                    }, this);\n\n                } else if (key === 'billing_address' || key === 'shipping_address' || key === 'customer') {\n                    // extracting the basic info of customer \n                    if (key === 'customer') {\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n\n                            if (field === 'created_at' || field === 'updated_at')\n                                customerData[customerPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key][field]) || '';\n                            else if (field != 'default_address')\n                                customerData[customerPrefix + field] = parsedBody[key][field] || '';\n\n                        }, this);\n                    } else {\n                        // extracting the billing and shipping address of order\n                        var prefix = (key === 'billing_address') ? BillingAddressPrefix : shippingAddressPrefix;\n\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n                            newCancelledOrder[prefix + field] = parsedBody[key][field] || '';\n                        }, this);\n                    }\n\n                } else if (key === 'shipping_lines') {\n                    let shipping_lines = parsedBody[key]\n                    let selectFields = {\n                        title: true,\n                        price: true,\n                        source: true,\n                        phone: true,\n                        carrier_identifier: true\n                    }\n\n                    if (shipping_lines && shipping_lines.length) {\n\n                        Object.keys(shipping_lines[0]).forEach(field => {\n                            let data = shipping_lines[0][field]\n\n                            if (selectFields[field] && data) {\n                                orderData[`shipping_line_${field}`] = data\n                            }\n\n                        })\n                    }\n\n                } else if (key != 'refunds' && key != 'fulfillments' && key != 'tax_lines'\n                    && key != 'discount_codes' && key != 'note_attributes' && key != 'payment_gateway_names') {\n\n                    // standard format of date\n                    if (key === 'created_at' || key === 'updated_at' || key === 'processed_at' || key === 'cancelled_at')\n                        orderData[key] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key]) || '';\n                    else\n                        orderData[key] = parsedBody[key] || '';\n                    // extracting all the other non nested keys\n                }\n            }, this);\n\n            //parsing custom fields\n            const noteAttributes = parsedBody.note_attributes\n\n            if (noteAttributes && Array.isArray(noteAttributes) && noteAttributes.length) {\n                noteAttributes\n                    .forEach(attr => {\n                        if (attr.name && attr.value) {\n                            const key = `additional_details_${utils.libText.encodeKey(attr.name)}`\n                            newCancelledOrderObj[key] = attr.value\n                        } \n                    })\n            }\n\n            const lineItems = parsedBody.line_items.slice(0, 5)\n\n            if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n                \n                const indexMapping = ['first', 'second', 'third', 'fourth', 'fifth']\n                lineItems\n                    .forEach((item, index) => {\n                        const properties = item.properties\n                        if (properties && Array.isArray(properties) && properties.length) {\n                            properties.forEach(prop => {\n                                if (prop.name && prop.value) {\n                                    newCancelledOrderObj[`${indexMapping[index]}_item_property_${utils.libText.encodeKey(prop.name)}`] = prop.value\n                                }\n                            })\n                        }\n                    })\n            }\n\n            const discountCodes = parsedBody.discount_codes\n\n            if (discountCodes && Array.isArray(discountCodes) && discountCodes.length) {\n                newCancelledOrderObj.discount_codes = discountCodes\n                    .map(dc => dc.code)\n                    .toString()\n            }\n\n            const landingSite = parsedBody.landing_site\n\n            if (landingSite) {\n                let utmParams = {}\n                const splitUrl = landingSite.split('?')\n                if (splitUrl[1]) {\n                    utmParams = splitUrl[1]\n                        .split('&')\n                        .reduce((acc, next) => {\n                            const splitParams = next.split('=')\n                            if (splitParams && splitParams.length === 2) {\n                                acc[splitParams[0]] = splitParams[1]\n                            }\n                            return acc\n                        }, {})\n                }\n                if(Object.keys(utmParams).length) {\n                    Object.keys(utmParams)\n                        .forEach(key => {\n                            newCancelledOrderObj[`campaign_${key}`] = utmParams[key]\n                        })\n                }\n            }\n\n            // reordering the JSON data\n            [orderData, customerData, newCancelledOrder].forEach(function (jsonObj) {\n                Object.keys(jsonObj).forEach(function (key) {\n                    newCancelledOrderObj[key] = jsonObj[key];\n                }, this);\n            }, this);\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { \"response\": newCancelledOrderObj };\n\n        } else {\n            retObj['error'] = {};\n            retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n            retObj['message'] = \"Trigger data not as expected from shopify webhook\"\n        }\n    }\n    // finally calling the callback function with retObj\n    callback(retObj);\n}"
			},
			"dynamicResponseFields": true,
			"dynamicResponseFieldsRequest": "function dynamicResponseFieldsRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/orders.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      limit: 20,\n      status: 'any',\n      fields: 'line_items,note_attributes,name'\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"dynamicResponseFieldsParse": "function dynamicResponseFieldsParse(params, utils, callback) {\n  const retObj = {}\n  const capitalize = word => word[0].toUpperCase() + word.slice(1, word.length).toLowerCase()\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n\n    retObj.status = 'SUCCESS'\n    retObj.data = []\n\n    if (body && body.orders && body.orders.length) {\n      const responseObjArray = []\n      const noteAtrrObj = {}\n      const propObj = {}\n\n      body.orders\n        .forEach(order => {\n          //note atrributes\n          const note_attributes = order.note_attributes\n          if (note_attributes && Array.isArray(note_attributes) && note_attributes.length) {\n            note_attributes\n              .forEach(attr => {\n                if (attr.name) {\n                  noteAtrrObj[attr.name] = attr.value || ''\n                }\n              })\n          }\n          //end note attributes\n\n          //line item properties\n          const lineItems = order.line_items\n          if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n            lineItems\n              .forEach(line => {\n                const props = line.properties\n                if (props && Array.isArray(props) && props.length) {\n                  props.forEach(prop => {\n                    if (prop.name) {\n                      propObj[prop.name] = prop.value || ''\n                    }\n                  })\n                }\n              })\n          }\n        })\n\n      Object.keys(noteAtrrObj)\n        .forEach(key => {\n          responseObjArray.push({\n            id: `additional_details_${utils.libText.encodeKey(key)}`,\n            name: `Additional Details ${key}`\n          })\n        })\n\n      if (Object.keys(propObj).length) {\n        ['first', 'second', 'third', 'fourth', 'fifth'].forEach(lineNum => {\n          Object.keys(propObj)\n            .forEach(key => {\n              responseObjArray.push({\n                id: `${lineNum}_item_property_${utils.libText.encodeKey(key)}`,\n                name: `${capitalize(lineNum)} Item Property ${key}`\n              })\n            })\n        })\n      }\n\n      retObj.data = responseObjArray\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"responseFields": [
				{
					"name": "Order ID",
					"id": "id",
					"description": "Shopify id of the order",
					"type": "String"
				},
				{
					"name": "Order Name",
					"id": "name",
					"type": "String"
				},
				{
					"name": "Email Address",
					"id": "email",
					"description": "Email address of customer",
					"type": "String"
				},
				{
					"name": "Cancellation Reason",
					"id": "cancel_reason",
					"type": "String"
				},
				{
					"name": "Cancelled At",
					"id": "cancelled_at",
					"type": "String"
				},
				{
					"name": "Closed At",
					"id": "closed_at",
					"description": "The date and time when the order was closed",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Shop Number",
					"id": "number",
					"description": "Unique identifier of the shop",
					"type": "String"
				},
				{
					"name": "Note",
					"id": "note",
					"type": "String"
				},
				{
					"name": "Token",
					"id": "token",
					"description": "Unique identifier for a particular order",
					"type": "String"
				},
				{
					"id": "discount_codes",
					"name": "Discount Codes Applied",
					"description": "comma seperated list of all discount codes applied"
				},
				{
					"name": "Total Price",
					"id": "total_price",
					"description": "The sum of prices of all the items in the order, taxes and discounts included",
					"type": "String"
				},
				{
					"name": "Subtotal Price",
					"id": "subtotal_price",
					"description": "Price of the order before shipping and taxes",
					"type": "String"
				},
				{
					"name": "Total Weight",
					"id": "total_weight",
					"description": "The sum of all the weights of the line items in the order(grams)",
					"type": "String"
				},
				{
					"name": "Tax Included",
					"id": "taxes_included",
					"description": "whether or not taxes are included in the order subtotal",
					"type": "String"
				},
				{
					"name": "Total Tax",
					"id": "total_tax",
					"type": "String"
				},
				{
					"name": "Currency",
					"id": "currency",
					"type": "String"
				},
				{
					"name": "Financial Status",
					"id": "financial_status",
					"type": "String"
				},
				{
					"name": "Confirmation Status",
					"id": "confirmed",
					"type": "String"
				},
				{
					"name": "Total Discounts",
					"id": "total_discounts",
					"type": "String"
				},
				{
					"name": "Total Line Item Price",
					"id": "total_line_items_price",
					"description": "The sum of all the prices of all the items in the order",
					"type": "String"
				},
				{
					"name": "Cart Token",
					"id": "cart_token",
					"description": "Unique token of cart attached to order",
					"type": "String"
				},
				{
					"name": "Buyer Accepts Marketing",
					"id": "buyer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Referring Site",
					"id": "referring_site",
					"description": "The website that the customer clicked on to come to the shop",
					"type": "String"
				},
				{
					"name": "Landing Site",
					"id": "landing_site",
					"description": "The URL for the page where the buyer landed when entering the shop",
					"type": "String"
				},
				{
					"id": "campaign_utm_source",
					"name": "Affiliate Link UTM Source"
				},
				{
					"id": "campaign_utm_medium",
					"name": "Affiliate Link UTM Medium"
				},
				{
					"id": "campaign_utm_campaign",
					"name": "Affiliate Link UTM Campaign Name"
				},
				{
					"id": "campaign_utm_content",
					"name": "Affiliate Link UTM Content"
				},
				{
					"name": "Total Price In USD",
					"id": "total_price_usd",
					"type": "String"
				},
				{
					"name": "User ID",
					"id": "user_id",
					"description": "The unique numerical identifier for the user logged into the terminal at the time the order was processed at POS",
					"type": "String"
				},
				{
					"name": "Location ID",
					"id": "location_id",
					"description": "The unique numeric identifier for the physical location of POS at which the order is created",
					"type": "String"
				},
				{
					"name": "Processing Date And Time",
					"id": "processed_at",
					"type": "String"
				},
				{
					"name": "Browser IP Address",
					"id": "browser_ip",
					"description": "IP address of the browser used by customer at the time of placing pf order",
					"type": "String"
				},
				{
					"name": "Order Number",
					"id": "order_number",
					"description": "Unique order number to be used by shop owners and customers",
					"type": "String"
				},
				{
					"name": "Processing Method",
					"id": "processing_method",
					"description": "Valid methods are: checkout, direct, manual, offsite or express",
					"type": "String"
				},
				{
					"id": "checkout_id",
					"name": "Order Checkout Id"
				},
				{
					"id": "checkout_token",
					"name": "Order Checkout Token"
				},
				{
					"id": "phone",
					"name": "Order Phone"
				},
				{
					"id": "customer_locale",
					"name": "Order Customer Locale"
				},
				{
					"id": "gateway",
					"name": "Order Payment Gateway"
				},
				{
					"name": "Order Fulfillment Status",
					"id": "fulfillment_status",
					"type": "String"
				},
				{
					"name": "Source Name",
					"id": "source_name",
					"description": "Source of the creation of order, example: shopify_draft_order, web etc",
					"type": "String"
				},
				{
					"name": "Tags",
					"id": "tags",
					"type": "String"
				},
				{
					"name": "Contact Email Address",
					"id": "contact_email",
					"type": "String"
				},
				{
					"name": "Order Status URL",
					"id": "order_status_url",
					"description": "The url pointing to the checkout accessible from the web",
					"type": "String"
				},
				{
					"name": "Customer ID",
					"id": "customer_id",
					"type": "String"
				},
				{
					"name": "Customer First Name",
					"id": "customer_first_name",
					"type": "String"
				},
				{
					"name": "Customer Last Name",
					"id": "customer_last_name",
					"type": "String"
				},
				{
					"name": "Customer Email Address",
					"id": "customer_email",
					"type": "String"
				},
				{
					"name": "Customer Phone Number",
					"id": "customer_phone",
					"type": "String"
				},
				{
					"name": "Customer Accepts Marketing",
					"id": "customer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Customer Creation Date And Time",
					"id": "customer_created_at",
					"type": "String"
				},
				{
					"name": "Customer Updation Date And Time",
					"id": "customer_updated_at",
					"type": "String"
				},
				{
					"name": "Customer Order Count",
					"id": "customer_orders_count",
					"type": "String"
				},
				{
					"name": "Customer Account State",
					"id": "customer_state",
					"type": "String"
				},
				{
					"name": "Customer Total Spendings",
					"id": "customer_total_spent",
					"type": "String"
				},
				{
					"name": "Customer Last Order ID",
					"id": "customer_last_order_id",
					"type": "String"
				},
				{
					"name": "Customer Note",
					"id": "customer_note",
					"type": "String"
				},
				{
					"name": "Customer Email Verified",
					"id": "customer_verified_email",
					"type": "String"
				},
				{
					"name": "Customer Tax Exempted",
					"id": "customer_tax_exempt",
					"type": "String"
				},
				{
					"name": "Customer Tags",
					"id": "customer_tags",
					"type": "String"
				},
				{
					"name": "Customer Last Order Name",
					"id": "customer_last_order_name",
					"type": "String"
				},
				{
					"name": "All Line Item Ids",
					"id": "line_item_ids",
					"type": "String",
					"description": "comma seperated list of line ids"
				},
				{
					"name": "All Line Item Product Codes",
					"id": "line_item_product_codes",
					"type": "String",
					"description": "comma seperated list of product codes"
				},
				{
					"name": "All Line Item Product Names",
					"id": "line_item_names",
					"type": "String",
					"description": "comma seperated list of product names"
				},
				{
					"name": "All Line Item Product Titles",
					"id": "line_item_titles",
					"type": "String",
					"description": "comma seperated list of product titles"
				},
				{
					"name": "All Line Item Product Variant Ids",
					"id": "line_item_variant_ids",
					"type": "String",
					"description": "comma seperated list of product variant ids"
				},
				{
					"name": "All Line Item Product Variant Titles",
					"id": "line_item_variant_titles",
					"type": "String",
					"description": "comma seperated list of product variant titles"
				},
				{
					"name": "All Line Item Quantities",
					"id": "line_item_quantities",
					"type": "String",
					"description": "comma seperated list of product quantities"
				},
				{
					"name": "All Line Item Prices",
					"id": "line_item_prices",
					"type": "String",
					"description": "comma seperated list of product unit prices"
				},
				{
					"name": "All Line Item Skus",
					"id": "line_item_skus",
					"type": "String",
					"description": "comma seperated list of product skus"
				},
				{
					"name": "All Line Item Product Weights",
					"id": "line_item_weights",
					"type": "String",
					"description": "comma seperated list of product weights"
				},
				{
					"name": "First Item ID",
					"id": "first_item_id",
					"type": "String"
				},
				{
					"name": "First Item Name",
					"id": "first_item_name",
					"type": "String"
				},
				{
					"name": "First Item Product ID",
					"id": "first_item_product_id",
					"type": "String"
				},
				{
					"name": "First Item Variant ID",
					"id": "first_item_variant_id",
					"type": "String"
				},
				{
					"name": "First Item Variant Title",
					"id": "first_item_variant_title",
					"type": "String"
				},
				{
					"name": "First Item Title",
					"id": "first_item_title",
					"type": "String"
				},
				{
					"name": "First Item Quantity",
					"id": "first_item_quantity",
					"type": "String"
				},
				{
					"name": "First Item Unit Price",
					"id": "first_item_price",
					"type": "String"
				},
				{
					"id": "first_item_sku",
					"name": "First Item SKU"
				},
				{
					"id": "first_item_grams",
					"name": "First Item Weight (grams)"
				},
				{
					"id": "first_item_gift_card",
					"name": "First Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "First Item Vendor",
					"id": "first_item_vendor",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Service",
					"id": "first_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "First Item Requires Shipping",
					"id": "first_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "First Item Taxable",
					"id": "first_item_taxable",
					"type": "String"
				},
				{
					"name": "First Item Exists",
					"id": "first_item_product_exists",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "First Item Total Discount",
					"id": "first_item_total_discount",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item ID",
					"id": "second_item_id",
					"type": "String"
				},
				{
					"name": "Second Item Name",
					"id": "second_item_name",
					"type": "String"
				},
				{
					"name": "Second Item Product ID",
					"id": "second_item_product_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant ID",
					"id": "second_item_variant_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant Title",
					"id": "second_item_variant_title",
					"type": "String"
				},
				{
					"name": "Second Item Title",
					"id": "second_item_title",
					"type": "String"
				},
				{
					"name": "Second Item Quantity",
					"id": "second_item_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Unit Price",
					"id": "second_item_price",
					"type": "String"
				},
				{
					"id": "second_item_sku",
					"name": "Second Item SKU"
				},
				{
					"id": "second_item_grams",
					"name": "Second Item Weight (grams)"
				},
				{
					"id": "second_item_gift_card",
					"name": "Second Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Second Item Vendor",
					"id": "second_item_vendor",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Service",
					"id": "second_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Second Item Requires Shipping",
					"id": "second_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Second Item Taxable",
					"id": "second_item_taxable",
					"type": "String"
				},
				{
					"name": "Second Item Exists",
					"id": "second_item_product_exists",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Total Discount",
					"id": "second_item_total_discount",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item ID",
					"id": "third_item_id",
					"type": "String"
				},
				{
					"name": "Third Item Name",
					"id": "third_item_name",
					"type": "String"
				},
				{
					"name": "Third Item Product ID",
					"id": "third_item_product_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant ID",
					"id": "third_item_variant_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant Title",
					"id": "third_item_variant_title",
					"type": "String"
				},
				{
					"name": "Third Item Title",
					"id": "third_item_title",
					"type": "String"
				},
				{
					"name": "Third Item Quantity",
					"id": "third_item_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Unit Price",
					"id": "third_item_price",
					"type": "String"
				},
				{
					"id": "third_item_sku",
					"name": "Third Item SKU"
				},
				{
					"id": "third_item_grams",
					"name": "Third Item Weight (grams)"
				},
				{
					"id": "third_item_gift_card",
					"name": "Third Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Third Item Vendor",
					"id": "third_item_vendor",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Service",
					"id": "third_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Third Item Requires Shipping",
					"id": "third_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Third Item Taxable",
					"id": "third_item_taxable",
					"type": "String"
				},
				{
					"name": "Third Item Exists",
					"id": "third_item_product_exists",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Total Discount",
					"id": "third_item_total_discount",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "third_item_properties",
					"name": "Third Item Properties"
				},
				{
					"name": "Fourth Item ID",
					"id": "fourth_item_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Name",
					"id": "fourth_item_name",
					"type": "String"
				},
				{
					"name": "Fourth Item Product ID",
					"id": "fourth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant ID",
					"id": "fourth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant Title",
					"id": "fourth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Title",
					"id": "fourth_item_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Quantity",
					"id": "fourth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Unit Price",
					"id": "fourth_item_price",
					"type": "String"
				},
				{
					"id": "fourth_item_sku",
					"name": "Fourth Item SKU"
				},
				{
					"id": "fourth_item_grams",
					"name": "Fourth Item Weight (grams)"
				},
				{
					"id": "fourth_item_gift_card",
					"name": "Fourth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fourth Item Vendor",
					"id": "fourth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Service",
					"id": "fourth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fourth Item Requires Shipping",
					"id": "fourth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fourth Item Taxable",
					"id": "fourth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fourth Item Exists",
					"id": "fourth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Total Discount",
					"id": "fourth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fourth_item_properties",
					"name": "Fourth Item Properties"
				},
				{
					"name": "Fifth Item ID",
					"id": "fifth_item_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Name",
					"id": "fifth_item_name",
					"type": "String"
				},
				{
					"name": "Fifth Item Product ID",
					"id": "fifth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant ID",
					"id": "fifth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant Title",
					"id": "fifth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Title",
					"id": "fifth_item_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Quantity",
					"id": "fifth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Unit Price",
					"id": "fifth_item_price",
					"type": "String"
				},
				{
					"id": "fifth_item_sku",
					"name": "Fifth Item SKU"
				},
				{
					"id": "fifth_item_grams",
					"name": "Fifth Item Weight (grams)"
				},
				{
					"id": "fifth_item_gift_card",
					"name": "Fifth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fifth Item Vendor",
					"id": "fifth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Service",
					"id": "fifth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fifth Item Requires Shipping",
					"id": "fifth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fifth Item Taxable",
					"id": "fifth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fifth Item Exists",
					"id": "fifth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Total Discount",
					"id": "fifth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fifth_item_properties",
					"name": "Fifth Item Properties"
				},
				{
					"name": "Billing address First Name",
					"id": "billing_address_first_name",
					"type": "String"
				},
				{
					"name": "Billing address Last Name",
					"id": "billing_address_last_name",
					"type": "String"
				},
				{
					"name": "Billing Address Name",
					"id": "billing_address_name",
					"type": "String"
				},
				{
					"name": "Billing address Line 1",
					"id": "billing_address_address1",
					"type": "String"
				},
				{
					"name": "Billing address Line 2",
					"id": "billing_address_address2",
					"type": "String"
				},
				{
					"name": "Billing address Phone Number",
					"id": "billing_address_phone",
					"type": "String"
				},
				{
					"name": "Billing address City",
					"id": "billing_address_city",
					"type": "String"
				},
				{
					"name": "Billing address Zip",
					"id": "billing_address_zip",
					"type": "String"
				},
				{
					"name": "Billing address Province",
					"id": "billing_address_province",
					"type": "String"
				},
				{
					"name": "Billing address Country",
					"id": "billing_address_country",
					"type": "String"
				},
				{
					"name": "Billing address Company",
					"id": "billing_address_company",
					"type": "String"
				},
				{
					"name": "Billing address Country Code",
					"id": "billing_address_country_code",
					"type": "String"
				},
				{
					"name": "Billing address Province Code",
					"id": "billing_address_province_code",
					"type": "String"
				},
				{
					"name": "Shipping address First Name",
					"id": "shipping_address_first_name",
					"type": "String"
				},
				{
					"name": "Shipping address Last Name",
					"id": "shipping_address_last_name",
					"type": "String"
				},
				{
					"name": "Shipping Address Name",
					"id": "shipping_address_name",
					"type": "String"
				},
				{
					"name": "Shipping address Line 1",
					"id": "shipping_address_address1",
					"type": "String"
				},
				{
					"name": "Shipping address Line 2",
					"id": "shipping_address_address2",
					"type": "String"
				},
				{
					"name": "Shipping address Phone Number",
					"id": "shipping_address_phone",
					"type": "String"
				},
				{
					"name": "Shipping address City",
					"id": "shipping_address_city",
					"type": "String"
				},
				{
					"name": "Shipping address Zip",
					"id": "shipping_address_zip",
					"type": "String"
				},
				{
					"name": "Shipping address Province",
					"id": "shipping_address_province",
					"type": "String"
				},
				{
					"name": "Shipping address Country",
					"id": "shipping_address_country",
					"type": "String"
				},
				{
					"name": "Shipping address Company",
					"id": "shipping_address_company",
					"type": "String"
				},
				{
					"name": "Shipping address Country Code",
					"id": "shipping_address_country_code",
					"type": "String"
				},
				{
					"name": "Shipping address Province Code",
					"id": "shipping_address_province_code",
					"type": "String"
				},
				{
					"id": "shipping_line_title",
					"name": "Order Shipping Line Title"
				},
				{
					"id": "shipping_line_price",
					"name": "Order Shipping Line Price"
				},
				{
					"id": "shipping_line_source",
					"name": "Order Shipping Line Source"
				},
				{
					"id": "shipping_line_phone",
					"name": "Order Shipping Line Phone"
				},
				{
					"id": "shipping_line_carrier_identifier",
					"name": "Order Shipping Line Carrier Identifier"
				}
			],
			"params": []
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "New Order Line Item",
			"id": "new-order-line-item",
			"description": "Triggers when there is a Order, for each line item. If there is an order with 5 line items, the Bot will run 5 times, each time with details of one line item",
			"priority": 3,
			"entity": "invoice",
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'orders/create',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && response['statusCode'] == 201) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n    var retObj = { status: \"ERROR\" };\n    var response;\n    var parsedBody;\n    var errors;\n    var errorMessage;\n    var body;\n\n    // if response and body are not present in params\n    if (!params || !params.response) {\n        retObj['error'] = {};\n        retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n        retObj['message'] = \"Invalid/Missing API response\";\n        return callback(retObj);\n    } else {\n\n        response = params['response'];\n        parsedBody = params['body'];\n\n        // if the response contains status code 200, for successful deletion of webhook\n        if (response['statusCode'] && response['statusCode'] == 200) {\n            // sending the succes return object\n            retObj['status'] = \"SUCCESS\";\n\n        } else {\n            // when error data present, flattening the object\n            errors = params['body']['errors'];\n            if (errors) {\n                errorMessage = '';\n                if (typeof errors == 'string')\n                    errorMessage = errors;\n                else {\n                    Object.keys(errors).forEach(function (key) {\n                        errorMessage += key + ': ';\n                        if (errors[key] && errors[key] instanceof Array)\n                            errorMessage += errors[key].join(',');\n                        else if (typeof errors[key] == 'string')\n                            errorMessage += errors[key];\n                        else\n                            errorMessage += errors[key];\n                        errorMessage += ', ';\n                    });\n                }\n            }\n            if (response['statusCode'] && response['statusCode'] == '401') {\n                // when oauth errors occurs because of wrong access token\n                retObj['error'] = {\n                    code: 'ERROR_AUTH',\n                    message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n                };\n\n            } else if (response['statusCode'] && response['statusCode'] == '404') {\n                retObj.status = 'SUCCESS'\n            } else if (response['statusCode'] && response['statusCode'] == '429') {\n                // when rate limit occurs \n                retObj['error'] = {\n                    code: 'ERROR_RATE_LIMIT',\n                    message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n                };\n\n            } else if (response['statusCode']) {\n                // for all the other errors\n                retObj['error'] = {\n                    code: 'ERROR_UNKNOWN',\n                    message: errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode']\n                };\n            }\n        }\n    }\n    // finally calling the callback function with retObj\n    callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n    const retObj = {}\n\n    if (!params || !params.body) {\n        retObj.status = 'ERROR'\n        retObj.error = {\n            message: 'body is missing from params',\n            code: 'ERROR_MISSING_PARAMS'\n        }\n        return callback(retObj)\n    }\n\n    const invoice = Object.assign({}, params.body)\n    let parsedLines = null\n\n    const parsedInvoiceFields = parseInvoice(invoice)\n\n    if (invoice.line_items && invoice.line_items instanceof Array && invoice.line_items.length) {\n        parsedLines = invoice.line_items.map(line => Object.assign({}, parsedInvoiceFields, parseLine(line)))\n    }\n\n    retObj.status = 'SUCCESS'\n    retObj.data = {\n        response: parsedLines\n    }\n\n    return callback(retObj) // end webhookTriggerParse\n\n    //utility functions\n    function parseLine(line) {\n        let parsedLine = {}\n\n        let fields = {\n            id: true,\n            name: true,\n            product_id: true,\n            title: true,\n            variant_id: true,\n            variant_title: true,\n            quantity: true,\n            price: true,\n            sku: true\n        }\n\n        Object.keys(line).map(key => {\n            let data = line[key]\n\n            if (fields[key] && data) {\n                parsedLine[`line_item_${key}`] = data\n            } else if (key === 'properties' && Array.isArray(data) && data.length) {\n                data\n                    .forEach(prop => {\n                        if (prop.name && prop.value) {\n                            parsedLine[`line_item_property_${utils.libText.encodeKey(prop.name)}`] = prop.value\n                        }\n                    })\n            }\n        })\n\n        return parsedLine\n    }//end parseLine\n\n    function parseInvoice(invoice) {\n        let parsedInvoice = {}\n\n        //this is where magic happens\n\n        let invoiceFields = {\n            id: true,\n            name: true,\n            email: true,\n            number: true,\n            total_tax: true,\n            total_price: true,\n            currency: true,\n            user_id: true\n        }\n\n        let dateFields = {\n            closed_at: true,\n            created_at: true,\n            updated_at: true,\n            processed_at: true,\n        }\n\n        utils._.each(invoice, (data, key) => {\n            if (key === 'customer' && data) {\n                let customerFields = {\n                    id: true,\n                    first_name: true,\n                    last_name: true,\n                    email: true\n                }\n                utils._.each(data, (cdata, ckey) => {\n                    if (customerFields[ckey] && cdata) {\n                        parsedInvoice[`customer_${ckey}`] = cdata\n                    }\n                })\n            }\n            else if (invoiceFields[key] && data) {\n                parsedInvoice[key] = data\n            }\n            else if (dateFields[key] && data) {\n                parsedInvoice[key] = utils.libDate.parseJSDateTimeToStandardString(new Date(data))\n            }\n        })\n\n        //magic end\n\n        return parsedInvoice\n    }//end parseInvoice\n}"
			},
			"dynamicResponseFields": true,
			"dynamicResponseFieldsRequest": "function dynamicResponseFieldsRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/orders.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      limit: 20,\n      status: 'any',\n      fields: 'line_items,note_attributes,name'\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"dynamicResponseFieldsParse": "function dynamicResponseFieldsParse(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n\n    retObj.status = 'SUCCESS'\n    retObj.data = []\n\n    if (body && body.orders && body.orders.length) {\n      const responseObjArray = []\n      const noteAtrrObj = {}\n      const propObj = {}\n\n      body.orders\n        .forEach(order => {\n          //line item properties\n          const lineItems = order.line_items\n          if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n            lineItems\n              .forEach(line => {\n                const props = line.properties\n                if (props && Array.isArray(props) && props.length) {\n                  props.forEach(prop => {\n                    if (prop.name) {\n                      propObj[prop.name] = prop.value || ''\n                    }\n                  })\n                }\n              })\n          }\n        })\n\n      if (Object.keys(propObj).length) {\n        Object.keys(propObj)\n            .forEach(key => {\n              responseObjArray.push({\n                id: `line_item_property_${utils.libText.encodeKey(key)}`,\n                name: `Line Item Property ${key}`\n              })\n            })\n      }\n\n      retObj.data = responseObjArray\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"responseFields": [
				{
					"id": "line_item_id",
					"name": "Line Item Id"
				},
				{
					"id": "line_item_product_id",
					"name": "Line Item Product Id"
				},
				{
					"id": "line_item_title",
					"name": "Line Item Title"
				},
				{
					"id": "line_item_variant_id",
					"name": "Line Item Variant Id"
				},
				{
					"id": "line_item_variant_title",
					"name": "Line Item Variant Title"
				},
				{
					"id": "line_item_name",
					"name": "LIne Item Name"
				},
				{
					"id": "line_item_price",
					"name": "Line Item Unit Price"
				},
				{
					"id": "line_item_quantity",
					"name": "Line Item Quantity"
				},
				{
					"id": "line_item_sku",
					"name": "Line Item SKU"
				},
				{
					"id": "id",
					"name": "Line Item Order Id"
				},
				{
					"id": "name",
					"name": "Line Item Order Name"
				},
				{
					"id": "email",
					"name": "Line Item Order Email"
				},
				{
					"id": "created_at",
					"name": "Line Item Order Created At"
				},
				{
					"id": "updated_at",
					"name": "Line Item Order Updated At"
				},
				{
					"id": "processed_at",
					"name": "Line Item Order Processed At"
				},
				{
					"id": "closed_at",
					"name": "Line Item Order Closed At"
				},
				{
					"id": "number",
					"name": "Line Item Order Shop Number"
				},
				{
					"id": "total_tax",
					"name": "Line Item Order Total Tax"
				},
				{
					"id": "total_price",
					"name": "Line Item Order Total Price"
				},
				{
					"id": "currency",
					"name": "Line Item Order Currency"
				},
				{
					"id": "user_id",
					"name": "Line Item Order User Id"
				},
				{
					"id": "customer_id",
					"name": "Line Item Order Customer Id"
				},
				{
					"id": "customer_first_name",
					"name": "Line Item Order Customer First Name"
				},
				{
					"id": "customer_last_name",
					"name": "Line Item Order Customer Last Name"
				},
				{
					"id": "customer_email",
					"name": "Line Item Order Customer Email"
				}
			],
			"params": []
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "New Paid Order",
			"id": "new-paid-order",
			"description": "Triggers when an Order is Paid",
			"priority": 2,
			"entity": "invoice",
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'orders/paid',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && response['statusCode'] == 201) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response) {\n      retObj['error']         = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['message']       = \"Invalid/Missing API response\";\n      return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful deletion of webhook\n   if (response['statusCode'] && response['statusCode'] == 200) {\n        // sending the succes return object\n        retObj['status'] = \"SUCCESS\";\n\n    } else {\n            // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n\n    var BillingAddressPrefix = 'billing_address_';\n    var shippingAddressPrefix = 'shipping_address_';\n    var customerPrefix = 'customer_'\n    var SkipFields = ['gateway', 'test'];\n    var retObj = { status: \"ERROR\" };\n    var maxItemScan = 5;\n    var customerData = {};\n    var orderData = {};\n    var newPaidOrder = {};\n    var newPaidOrderObj = {};\n    var responseKeys;\n    var parsedBody;\n\n    // if body is not present in params\n    if (!params || !params.body || !(utils || {}).libDate) {\n        retObj['message'] = \"Invalid/Missing API body or libDate util\";\n        return callback(retObj);\n    } else {\n        parsedBody = params['body'];\n        // extracting the keys of response data of order\n        responseKeys = Object.keys(parsedBody);\n\n        if (responseKeys.length) {\n            // iterating each key of the order related data json\n            responseKeys.forEach(function (key) {\n\n                if (key === 'line_items') {\n\n                    //creating comma separated list of all line item names and ids\n\n                    let accumulated = null\n\n                    accumulated = parsedBody[key].reduce((acc, value) => {\n                        acc.line_item_ids.push(value.id ? value.id : '')\n                        acc.line_item_names.push(value.name ? value.name : '')\n                        acc.line_item_product_codes.push(value.product_id ? value.product_id : '')\n                        acc.line_item_titles.push(value.title ? value.title : '')\n                        acc.line_item_variant_ids.push(value.variant_id ? value.variant_id : '')\n                        acc.line_item_variant_titles.push(value.variant_title ? value.variant_title : '')\n                        acc.line_item_quantities.push(value.quantity ? value.quantity : '')\n                        acc.line_item_prices.push(value.price ? value.price : '')\n                        acc.line_item_skus.push(value.sku ? value.sku : '')\n                        acc.line_item_weights.push(value.grams ? value.grams : '')\n\n                        return acc\n                    }, {\n                            line_item_ids: [],\n                            line_item_names: [],\n                            line_item_product_codes: [],\n                            line_item_titles: [],\n                            line_item_variant_ids: [],\n                            line_item_variant_titles: [],\n                            line_item_quantities: [],\n                            line_item_prices: [],\n                            line_item_skus: [],\n                            line_item_weights: []\n                        }\n                    )\n\n                    Object.keys(accumulated).forEach(prop => {\n                        let fld = prop\n                        let data = accumulated[prop]\n\n                        if (data && data.length) {\n                            newPaidOrder[fld] = data.toString()\n                        }\n                    })\n\n                    parsedBody[key].some(function (element, index) {\n                        // deciding the prefix for items\n                        const prefix = ['first', 'second', 'third', 'fourth', 'fifth']\n\n                        Object.keys(element).forEach(function (field) {\n                            if (field != 'properties' && field != 'tax_lines')\n                                newPaidOrder[`${prefix[index]}_item_${field}`] = element[field] || '';\n                        }, this);\n\n                        // returning after maximum scanning of 3 items of orders\n                        return maxItemScan === index + 1;\n                    }, this);\n\n                } else if (key === 'billing_address' || key === 'shipping_address' || key === 'customer') {\n                    // extracting the basic info of customer \n                    if (key === 'customer') {\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n\n                            if (field === 'created_at' || field === 'updated_at')\n                                customerData[customerPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key][field]) || '';\n                            else if (field != 'default_address')\n                                customerData[customerPrefix + field] = parsedBody[key][field] || '';\n\n                        }, this);\n                    } else {\n                        // extracting the billing and shipping address of order\n                        var prefix = (key === 'billing_address') ? BillingAddressPrefix : shippingAddressPrefix;\n\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n                            newPaidOrder[prefix + field] = parsedBody[key][field] || '';\n                        }, this);\n                    }\n\n                } else if (key === 'shipping_lines') {\n                    let shipping_lines = parsedBody[key]\n                    let selectFields = {\n                        title: true,\n                        price: true,\n                        source: true,\n                        phone: true,\n                        carrier_identifier: true\n                    }\n\n                    if (shipping_lines && shipping_lines.length) {\n\n                        Object.keys(shipping_lines[0]).forEach(field => {\n                            let data = shipping_lines[0][field]\n\n                            if (selectFields[field] && data) {\n                                orderData[`shipping_line_${field}`] = data\n                            }\n\n                        })\n                    }\n\n                } else if (key != 'refunds' && key != 'fulfillments' && key != 'tax_lines'\n                    && key != 'discount_codes' && key != 'note_attributes' && key != 'payment_gateway_names') {\n\n                    // standard format of date\n                    if (key === 'created_at' || key === 'updated_at' || key === 'processed_at')\n                        orderData[key] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key]) || '';\n                    else\n                        orderData[key] = parsedBody[key] || '';\n                    // extracting all the other non nested keys\n                }\n            }, this);\n\n            //parsing custom fields\n            const noteAttributes = parsedBody.note_attributes\n\n            if (noteAttributes && Array.isArray(noteAttributes) && noteAttributes.length) {\n                noteAttributes\n                    .forEach(attr => {\n                        if (attr.name && attr.value) {\n                            const key = `additional_details_${utils.libText.encodeKey(attr.name)}`\n                            newPaidOrderObj[key] = attr.value\n                        } \n                    })\n            }\n\n            const lineItems = parsedBody.line_items.slice(0, 5)\n\n            if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n                \n                const indexMapping = ['first', 'second', 'third', 'fourth', 'fifth']\n                lineItems\n                    .forEach((item, index) => {\n                        const properties = item.properties\n                        if (properties && Array.isArray(properties) && properties.length) {\n                            properties.forEach(prop => {\n                                if (prop.name && prop.value) {\n                                    newPaidOrderObj[`${indexMapping[index]}_item_property_${utils.libText.encodeKey(prop.name)}`] = prop.value\n                                }\n                            })\n                        }\n                    })\n            }\n\n            const discountCodes = parsedBody.discount_codes\n\n            if (discountCodes && Array.isArray(discountCodes) && discountCodes.length) {\n                newPaidOrderObj.discount_codes = discountCodes\n                    .map(dc => dc.code)\n                    .toString()\n            }\n\n            const landingSite = parsedBody.landing_site\n\n            if (landingSite) {\n                let utmParams = {}\n                const splitUrl = landingSite.split('?')\n                if (splitUrl[1]) {\n                    utmParams = splitUrl[1]\n                        .split('&')\n                        .reduce((acc, next) => {\n                            const splitParams = next.split('=')\n                            if (splitParams && splitParams.length === 2) {\n                                acc[splitParams[0]] = splitParams[1]\n                            }\n                            return acc\n                        }, {})\n                }\n                if(Object.keys(utmParams).length) {\n                    Object.keys(utmParams)\n                        .forEach(key => {\n                            newPaidOrderObj[`campaign_${key}`] = utmParams[key]\n                        })\n                }\n            }\n\n            // reordering the JSON data\n            [orderData, customerData, newPaidOrder].forEach(function (jsonObj) {\n                Object.keys(jsonObj).forEach(function (key) {\n                    newPaidOrderObj[key] = jsonObj[key];\n                }, this);\n            }, this);\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { \"response\": newPaidOrderObj };\n\n        } else {\n            retObj['error'] = {};\n            retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n            retObj['message'] = \"Trigger data not as expected from shopify webhook\"\n        }\n    }\n    // finally calling the callback function with retObj\n    callback(retObj);\n}"
			},
			"dynamicResponseFields": true,
			"dynamicResponseFieldsRequest": "function dynamicResponseFieldsRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/orders.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      limit: 20,\n      status: 'any',\n      fields: 'line_items,note_attributes,name'\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"dynamicResponseFieldsParse": "function dynamicResponseFieldsParse(params, utils, callback) {\n  const retObj = {}\n  const capitalize = word => word[0].toUpperCase() + word.slice(1, word.length).toLowerCase()\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n\n    retObj.status = 'SUCCESS'\n    retObj.data = []\n\n    if (body && body.orders && body.orders.length) {\n      const responseObjArray = []\n      const noteAtrrObj = {}\n      const propObj = {}\n\n      body.orders\n        .forEach(order => {\n          //note atrributes\n          const note_attributes = order.note_attributes\n          if (note_attributes && Array.isArray(note_attributes) && note_attributes.length) {\n            note_attributes\n              .forEach(attr => {\n                if (attr.name) {\n                  noteAtrrObj[attr.name] = attr.value || ''\n                }\n              })\n          }\n          //end note attributes\n\n          //line item properties\n          const lineItems = order.line_items\n          if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n            lineItems\n              .forEach(line => {\n                const props = line.properties\n                if (props && Array.isArray(props) && props.length) {\n                  props.forEach(prop => {\n                    if (prop.name) {\n                      propObj[prop.name] = prop.value || ''\n                    }\n                  })\n                }\n              })\n          }\n        })\n\n      Object.keys(noteAtrrObj)\n        .forEach(key => {\n          responseObjArray.push({\n            id: `additional_details_${utils.libText.encodeKey(key)}`,\n            name: `Additional Details ${key}`\n          })\n        })\n\n      if (Object.keys(propObj).length) {\n        ['first', 'second', 'third', 'fourth', 'fifth'].forEach(lineNum => {\n          Object.keys(propObj)\n            .forEach(key => {\n              responseObjArray.push({\n                id: `${lineNum}_item_property_${utils.libText.encodeKey(key)}`,\n                name: `${capitalize(lineNum)} Item Property ${key}`\n              })\n            })\n        })\n      }\n\n      retObj.data = responseObjArray\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"responseFields": [
				{
					"name": "Order ID",
					"id": "id",
					"description": "Shopify id of the order",
					"type": "String"
				},
				{
					"name": "Order Name",
					"id": "name",
					"type": "String"
				},
				{
					"name": "Email Address",
					"id": "email",
					"description": "Email address of customer",
					"type": "String"
				},
				{
					"name": "Closed At",
					"id": "closed_at",
					"description": "The date and time when the order was closed",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Shop Number",
					"id": "number",
					"description": "Unique identifier of the shop",
					"type": "String"
				},
				{
					"name": "Note",
					"id": "note",
					"type": "String"
				},
				{
					"name": "Token",
					"id": "token",
					"description": "Unique identifier for a particular order",
					"type": "String"
				},
				{
					"id": "discount_codes",
					"name": "Discount Codes Applied",
					"description": "comma seperated list of all discount codes applied"
				},
				{
					"name": "Total Price",
					"id": "total_price",
					"description": "The sum of prices of all the items in the order, taxes and discounts included",
					"type": "String"
				},
				{
					"name": "Subtotal Price",
					"id": "subtotal_price",
					"description": "Price of the order before shipping and taxes",
					"type": "String"
				},
				{
					"name": "Total Weight",
					"id": "total_weight",
					"description": "The sum of all the weights of the line items in the order(grams)",
					"type": "String"
				},
				{
					"name": "Tax Included",
					"id": "taxes_included",
					"description": "whether or not taxes are included in the order subtotal",
					"type": "String"
				},
				{
					"name": "Total Tax",
					"id": "total_tax",
					"type": "String"
				},
				{
					"name": "Currency",
					"id": "currency",
					"type": "String"
				},
				{
					"name": "Financial Status",
					"id": "financial_status",
					"type": "String"
				},
				{
					"name": "Confirmation Status",
					"id": "confirmed",
					"type": "String"
				},
				{
					"name": "Total Discounts",
					"id": "total_discounts",
					"type": "String"
				},
				{
					"name": "Total Line Item Price",
					"id": "total_line_items_price",
					"description": "The sum of all the prices of all the items in the order",
					"type": "String"
				},
				{
					"name": "Cart Token",
					"id": "cart_token",
					"description": "Unique token of cart attached to order",
					"type": "String"
				},
				{
					"name": "Buyer Accepts Marketing",
					"id": "buyer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Referring Site",
					"id": "referring_site",
					"description": "The website that the customer clicked on to come to the shop",
					"type": "String"
				},
				{
					"name": "Landing Site",
					"id": "landing_site",
					"description": "The URL for the page where the buyer landed when entering the shop",
					"type": "String"
				},
				{
					"id": "campaign_utm_source",
					"name": "Affiliate Link UTM Source"
				},
				{
					"id": "campaign_utm_medium",
					"name": "Affiliate Link UTM Medium"
				},
				{
					"id": "campaign_utm_campaign",
					"name": "Affiliate Link UTM Campaign Name"
				},
				{
					"id": "campaign_utm_content",
					"name": "Affiliate Link UTM Content"
				},
				{
					"name": "Total Price In USD",
					"id": "total_price_usd",
					"type": "String"
				},
				{
					"name": "User ID",
					"id": "user_id",
					"description": "The unique numerical identifier for the user logged into the terminal at the time the order was processed at POS",
					"type": "String"
				},
				{
					"name": "Location ID",
					"id": "location_id",
					"description": "The unique numeric identifier for the physical location of POS at which the order is created",
					"type": "String"
				},
				{
					"name": "Processing Date And Time",
					"id": "processed_at",
					"type": "String"
				},
				{
					"name": "Browser IP Address",
					"id": "browser_ip",
					"description": "IP address of the browser used by customer at the time of placing pf order",
					"type": "String"
				},
				{
					"name": "Order Number",
					"id": "order_number",
					"description": "Unique order number to be used by shop owners and customers",
					"type": "String"
				},
				{
					"name": "Processing Method",
					"id": "processing_method",
					"description": "Valid methods are: checkout, direct, manual, offsite or express",
					"type": "String"
				},
				{
					"id": "checkout_id",
					"name": "Order Checkout Id"
				},
				{
					"id": "checkout_token",
					"name": "Order Checkout Token"
				},
				{
					"id": "phone",
					"name": "Order Phone"
				},
				{
					"id": "customer_locale",
					"name": "Order Customer Locale"
				},
				{
					"id": "gateway",
					"name": "Order Payment Gateway"
				},
				{
					"name": "Order Fulfillment Status",
					"id": "fulfillment_status",
					"type": "String"
				},
				{
					"name": "Source Name",
					"id": "source_name",
					"description": "Source of the creation of order, example: shopify_draft_order, web etc",
					"type": "String"
				},
				{
					"name": "Tags",
					"id": "tags",
					"type": "String"
				},
				{
					"name": "Contact Email Address",
					"id": "contact_email",
					"type": "String"
				},
				{
					"name": "Order Status URL",
					"id": "order_status_url",
					"description": "The url pointing to the checkout accessible from the web",
					"type": "String"
				},
				{
					"name": "Customer ID",
					"id": "customer_id",
					"type": "String"
				},
				{
					"name": "Customer First Name",
					"id": "customer_first_name",
					"type": "String"
				},
				{
					"name": "Customer Last Name",
					"id": "customer_last_name",
					"type": "String"
				},
				{
					"name": "Customer Email Address",
					"id": "customer_email",
					"type": "String"
				},
				{
					"name": "Customer Phone Number",
					"id": "customer_phone",
					"type": "String"
				},
				{
					"name": "Customer Accepts Marketing",
					"id": "customer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Customer Creation Date And Time",
					"id": "customer_created_at",
					"type": "String"
				},
				{
					"name": "Customer Updation Date And Time",
					"id": "customer_updated_at",
					"type": "String"
				},
				{
					"name": "Customer Order Count",
					"id": "customer_orders_count",
					"type": "String"
				},
				{
					"name": "Customer Account State",
					"id": "customer_state",
					"type": "String"
				},
				{
					"name": "Customer Total Spendings",
					"id": "customer_total_spent",
					"type": "String"
				},
				{
					"name": "Customer Last Order ID",
					"id": "customer_last_order_id",
					"type": "String"
				},
				{
					"name": "Customer Note",
					"id": "customer_note",
					"type": "String"
				},
				{
					"name": "Customer Email Verified",
					"id": "customer_verified_email",
					"type": "String"
				},
				{
					"name": "Customer Tax Exempted",
					"id": "customer_tax_exempt",
					"type": "String"
				},
				{
					"name": "Customer Tags",
					"id": "customer_tags",
					"type": "String"
				},
				{
					"name": "Customer Last Order Name",
					"id": "customer_last_order_name",
					"type": "String"
				},
				{
					"name": "All Line Item Ids",
					"id": "line_item_ids",
					"type": "String",
					"description": "comma seperated list of line ids"
				},
				{
					"name": "All Line Item Product Codes",
					"id": "line_item_product_codes",
					"type": "String",
					"description": "comma seperated list of product codes"
				},
				{
					"name": "All Line Item Product Names",
					"id": "line_item_names",
					"type": "String",
					"description": "comma seperated list of product names"
				},
				{
					"name": "All Line Item Product Titles",
					"id": "line_item_titles",
					"type": "String",
					"description": "comma seperated list of product titles"
				},
				{
					"name": "All Line Item Product Variant Ids",
					"id": "line_item_variant_ids",
					"type": "String",
					"description": "comma seperated list of product variant ids"
				},
				{
					"name": "All Line Item Product Variant Titles",
					"id": "line_item_variant_titles",
					"type": "String",
					"description": "comma seperated list of product variant titles"
				},
				{
					"name": "All Line Item Quantities",
					"id": "line_item_quantities",
					"type": "String",
					"description": "comma seperated list of product quantities"
				},
				{
					"name": "All Line Item Prices",
					"id": "line_item_prices",
					"type": "String",
					"description": "comma seperated list of product unit prices"
				},
				{
					"name": "All Line Item Skus",
					"id": "line_item_skus",
					"type": "String",
					"description": "comma seperated list of product skus"
				},
				{
					"name": "All Line Item Product Weights",
					"id": "line_item_weights",
					"type": "String",
					"description": "comma seperated list of product weights"
				},
				{
					"name": "First Item ID",
					"id": "first_item_id",
					"type": "String"
				},
				{
					"name": "First Item Name",
					"id": "first_item_name",
					"type": "String"
				},
				{
					"name": "First Item Product ID",
					"id": "first_item_product_id",
					"type": "String"
				},
				{
					"name": "First Item Variant ID",
					"id": "first_item_variant_id",
					"type": "String"
				},
				{
					"name": "First Item Variant Title",
					"id": "first_item_variant_title",
					"type": "String"
				},
				{
					"name": "First Item Title",
					"id": "first_item_title",
					"type": "String"
				},
				{
					"name": "First Item Quantity",
					"id": "first_item_quantity",
					"type": "String"
				},
				{
					"name": "First Item Unit Price",
					"id": "first_item_price",
					"type": "String"
				},
				{
					"id": "first_item_sku",
					"name": "First Item SKU"
				},
				{
					"id": "first_item_grams",
					"name": "First Item Weight (grams)"
				},
				{
					"id": "first_item_gift_card",
					"name": "First Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "First Item Vendor",
					"id": "first_item_vendor",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Service",
					"id": "first_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "First Item Requires Shipping",
					"id": "first_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "First Item Taxable",
					"id": "first_item_taxable",
					"type": "String"
				},
				{
					"name": "First Item Exists",
					"id": "first_item_product_exists",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "First Item Total Discount",
					"id": "first_item_total_discount",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item ID",
					"id": "second_item_id",
					"type": "String"
				},
				{
					"name": "Second Item Name",
					"id": "second_item_name",
					"type": "String"
				},
				{
					"name": "Second Item Product ID",
					"id": "second_item_product_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant ID",
					"id": "second_item_variant_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant Title",
					"id": "second_item_variant_title",
					"type": "String"
				},
				{
					"name": "Second Item Title",
					"id": "second_item_title",
					"type": "String"
				},
				{
					"name": "Second Item Quantity",
					"id": "second_item_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Unit Price",
					"id": "second_item_price",
					"type": "String"
				},
				{
					"id": "second_item_sku",
					"name": "Second Item SKU"
				},
				{
					"id": "second_item_grams",
					"name": "Second Item Weight (grams)"
				},
				{
					"id": "second_item_gift_card",
					"name": "Second Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Second Item Vendor",
					"id": "second_item_vendor",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Service",
					"id": "second_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Second Item Requires Shipping",
					"id": "second_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Second Item Taxable",
					"id": "second_item_taxable",
					"type": "String"
				},
				{
					"name": "Second Item Exists",
					"id": "second_item_product_exists",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Total Discount",
					"id": "second_item_total_discount",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item ID",
					"id": "third_item_id",
					"type": "String"
				},
				{
					"name": "Third Item Name",
					"id": "third_item_name",
					"type": "String"
				},
				{
					"name": "Third Item Product ID",
					"id": "third_item_product_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant ID",
					"id": "third_item_variant_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant Title",
					"id": "third_item_variant_title",
					"type": "String"
				},
				{
					"name": "Third Item Title",
					"id": "third_item_title",
					"type": "String"
				},
				{
					"name": "Third Item Quantity",
					"id": "third_item_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Unit Price",
					"id": "third_item_price",
					"type": "String"
				},
				{
					"id": "third_item_sku",
					"name": "Third Item SKU"
				},
				{
					"id": "third_item_grams",
					"name": "Third Item Weight (grams)"
				},
				{
					"id": "third_item_gift_card",
					"name": "Third Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Third Item Vendor",
					"id": "third_item_vendor",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Service",
					"id": "third_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Third Item Requires Shipping",
					"id": "third_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Third Item Taxable",
					"id": "third_item_taxable",
					"type": "String"
				},
				{
					"name": "Third Item Exists",
					"id": "third_item_product_exists",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Total Discount",
					"id": "third_item_total_discount",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "third_item_properties",
					"name": "Third Item Properties"
				},
				{
					"name": "Fourth Item ID",
					"id": "fourth_item_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Name",
					"id": "fourth_item_name",
					"type": "String"
				},
				{
					"name": "Fourth Item Product ID",
					"id": "fourth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant ID",
					"id": "fourth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant Title",
					"id": "fourth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Title",
					"id": "fourth_item_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Quantity",
					"id": "fourth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Unit Price",
					"id": "fourth_item_price",
					"type": "String"
				},
				{
					"id": "fourth_item_sku",
					"name": "Fourth Item SKU"
				},
				{
					"id": "fourth_item_grams",
					"name": "Fourth Item Weight (grams)"
				},
				{
					"id": "fourth_item_gift_card",
					"name": "Fourth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fourth Item Vendor",
					"id": "fourth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Service",
					"id": "fourth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fourth Item Requires Shipping",
					"id": "fourth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fourth Item Taxable",
					"id": "fourth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fourth Item Exists",
					"id": "fourth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Total Discount",
					"id": "fourth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fourth_item_properties",
					"name": "Fourth Item Properties"
				},
				{
					"name": "Fifth Item ID",
					"id": "fifth_item_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Name",
					"id": "fifth_item_name",
					"type": "String"
				},
				{
					"name": "Fifth Item Product ID",
					"id": "fifth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant ID",
					"id": "fifth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant Title",
					"id": "fifth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Title",
					"id": "fifth_item_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Quantity",
					"id": "fifth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Unit Price",
					"id": "fifth_item_price",
					"type": "String"
				},
				{
					"id": "fifth_item_sku",
					"name": "Fifth Item SKU"
				},
				{
					"id": "fifth_item_grams",
					"name": "Fifth Item Weight (grams)"
				},
				{
					"id": "fifth_item_gift_card",
					"name": "Fifth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fifth Item Vendor",
					"id": "fifth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Service",
					"id": "fifth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fifth Item Requires Shipping",
					"id": "fifth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fifth Item Taxable",
					"id": "fifth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fifth Item Exists",
					"id": "fifth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Total Discount",
					"id": "fifth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fifth_item_properties",
					"name": "Fifth Item Properties"
				},
				{
					"name": "Billing address First Name",
					"id": "billing_address_first_name",
					"type": "String"
				},
				{
					"name": "Billing address Last Name",
					"id": "billing_address_last_name",
					"type": "String"
				},
				{
					"name": "Billing Address Name",
					"id": "billing_address_name",
					"type": "String"
				},
				{
					"name": "Billing address Line 1",
					"id": "billing_address_address1",
					"type": "String"
				},
				{
					"name": "Billing address Line 2",
					"id": "billing_address_address2",
					"type": "String"
				},
				{
					"name": "Billing address Phone Number",
					"id": "billing_address_phone",
					"type": "String"
				},
				{
					"name": "Billing address City",
					"id": "billing_address_city",
					"type": "String"
				},
				{
					"name": "Billing address Zip",
					"id": "billing_address_zip",
					"type": "String"
				},
				{
					"name": "Billing address Province",
					"id": "billing_address_province",
					"type": "String"
				},
				{
					"name": "Billing address Country",
					"id": "billing_address_country",
					"type": "String"
				},
				{
					"name": "Billing address Company",
					"id": "billing_address_company",
					"type": "String"
				},
				{
					"name": "Billing address Country Code",
					"id": "billing_address_country_code",
					"type": "String"
				},
				{
					"name": "Billing address Province Code",
					"id": "billing_address_province_code",
					"type": "String"
				},
				{
					"name": "Shipping address First Name",
					"id": "shipping_address_first_name",
					"type": "String"
				},
				{
					"name": "Shipping address Last Name",
					"id": "shipping_address_last_name",
					"type": "String"
				},
				{
					"name": "Shipping Address Name",
					"id": "shipping_address_name",
					"type": "String"
				},
				{
					"name": "Shipping address Line 1",
					"id": "shipping_address_address1",
					"type": "String"
				},
				{
					"name": "Shipping address Line 2",
					"id": "shipping_address_address2",
					"type": "String"
				},
				{
					"name": "Shipping address Phone Number",
					"id": "shipping_address_phone",
					"type": "String"
				},
				{
					"name": "Shipping address City",
					"id": "shipping_address_city",
					"type": "String"
				},
				{
					"name": "Shipping address Zip",
					"id": "shipping_address_zip",
					"type": "String"
				},
				{
					"name": "Shipping address Province",
					"id": "shipping_address_province",
					"type": "String"
				},
				{
					"name": "Shipping address Country",
					"id": "shipping_address_country",
					"type": "String"
				},
				{
					"name": "Shipping address Company",
					"id": "shipping_address_company",
					"type": "String"
				},
				{
					"name": "Shipping address Country Code",
					"id": "shipping_address_country_code",
					"type": "String"
				},
				{
					"name": "Shipping address Province Code",
					"id": "shipping_address_province_code",
					"type": "String"
				},
				{
					"id": "shipping_line_title",
					"name": "Order Shipping Line Title"
				},
				{
					"id": "shipping_line_price",
					"name": "Order Shipping Line Price"
				},
				{
					"id": "shipping_line_source",
					"name": "Order Shipping Line Source"
				},
				{
					"id": "shipping_line_phone",
					"name": "Order Shipping Line Phone"
				},
				{
					"id": "shipping_line_carrier_identifier",
					"name": "Order Shipping Line Carrier Identifier"
				}
			],
			"params": []
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "New Product",
			"id": "new-product",
			"description": "Triggers when a new Product is added",
			"priority": 3,
			"entity": "product",
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'products/create',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && response['statusCode'] == 201) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n            // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for deleting webhook url\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response) {\n      retObj['error']         = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['message']       = \"Invalid/Missing API response\";\n      return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful deletion of webhook\n   if (response['statusCode'] && response['statusCode'] == 200) {\n        // sending the succes return object\n        retObj['status'] = \"SUCCESS\";\n\n    } else {\n            // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n\n    var countPostfix    = '_count';\n    var retObj          = { status: \"ERROR\" };\n    var maxImageItemScan= 2;\n    var newProduct      = {};\n    var imageKey;\n    var responseKeys;\n    var parsedBody;\n\n    // if body is not present in params\n    if (!params || !params.body || !(utils || {}).libDate) {\n        retObj['message'] = \"Invalid/Missing API body or libDate util\";\n        return callback(retObj);\n    } else {\n        parsedBody = params['body'];\n        // extracting the keys of response data of order\n        responseKeys = Object.keys(parsedBody);\n\n        if (responseKeys.length) {\n\n            // iterating each key of the order related data json\n            responseKeys.forEach(function (key) {\n\n                if (key === 'variants' || key === 'options') {\n                    \n                    newProduct[key + countPostfix] = parsedBody[key].length;\n\n                } else if (key === 'created_at' || key === 'updated_at' || key === 'published_at') {\n                    // conversion of date to a standard form\n                    newProduct[key] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key]) || '';\n\n                } else if (key === 'images' && parsedBody[key] && parsedBody[key].length){\n\n                    newProduct['product_image_url'] = parsedBody[key][0] && parsedBody[key][0]['src'] || ''\n\n                } else if (key != 'image' && key != 'images') {\n                    // extracting all the other non nested keys\n                    newProduct[key] = parsedBody[key] || '';\n                }\n            }, this);\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { \"response\": newProduct };\n\n        } else {\n            retObj['error'] = {};\n            retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n            retObj['message'] = \"Trigger data not as expected from shopify webhook\"\n        }\n    }\n    // finally calling the callback function with retObj\n    callback(retObj);\n}"
			},
			"responseFields": [
				{
					"name": "Product ID",
					"id": "id",
					"type": "String"
				},
				{
					"name": "Product Title",
					"id": "title",
					"type": "String"
				},
				{
					"name": "Description",
					"id": "body_html",
					"type": "String"
				},
				{
					"name": "Vendor",
					"id": "vendor",
					"type": "String"
				},
				{
					"name": "Type of Product",
					"id": "product_type",
					"type": "String"
				},
				{
					"name": "Product Image URL",
					"id": "product_image_url",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Published At",
					"id": "published_at",
					"type": "String"
				},
				{
					"name": "Published scope",
					"id": "published_scope",
					"description": "Indicates whether the product is published to the Point of Sale channel",
					"type": "String"
				},
				{
					"name": "Number Of Variants",
					"id": "variants_count",
					"type": "String"
				},
				{
					"name": "Number of options",
					"id": "options_count",
					"type": "String"
				},
				{
					"name": "Product Handle",
					"id": "handle",
					"description": "Unique string for the Product automatically generated from its title",
					"type": "String"
				}
			],
			"params": []
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "New Variant",
			"id": "new-variant",
			"description": "Triggers when a new Variant is added",
			"priority": 7,
			"entity": "product",
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'products/update',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && response['statusCode'] == 201) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n            // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for deleting webhook url\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response) {\n      retObj['error']         = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['message']       = \"Invalid/Missing API response\";\n      return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful deletion of webhook\n   if (response['statusCode'] && response['statusCode'] == 200) {\n        // sending the succes return object\n        retObj['status'] = \"SUCCESS\";\n\n    } else {\n            // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n\n    var countPostfix    = '_count';\n    var productPrefix   = 'product_';\n    var variantPrefix   = 'variant_';\n    var retObj          = { status: \"ERROR\" };\n    var maxImageItemScan= 2;\n    var productDetails  = {};\n    var tempNewVariants = [];\n    var newVariants     = [];\n    var variant;\n    var prodUpdateTime;\n    var variantsArray;\n    var newVariant;\n    var imageKey;\n    var responseKeys;\n    var parsedBody;\n\n    // if body is not present in params\n    if (!params || !params.body || !(utils || {}).libDate) {\n        retObj['message'] = \"Invalid/Missing API body or libDate util\";\n        return callback(retObj);\n    } else {\n        parsedBody = params['body'];\n        // Extract the prod update time\n        prodUpdateTime = new Date(parsedBody['updated_at']);\n\n        if (parsedBody['variants'] && parsedBody['variants'].length) {\n            variantsArray = parsedBody['variants'];\n\n            // identifying the new variants\n            variantsArray.forEach(function(variant){\n\n                if (variant['created_at'] && variant['updated_at'] && new Date(variant['created_at']).getTime() === prodUpdateTime.getTime() \n                    && new Date(variant['updated_at']).getTime() === prodUpdateTime.getTime()) {\n                        \n                        // as it is a new variant\n                        tempNewVariants.push(variant);\n                }\n            }, this);\n        }\n\n        // if no new data/variant\n        if (tempNewVariants.length === 0) {\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { \"response\": {} };\n            return callback(retObj);\n        }\n\n        // extracting the product details\n        responseKeys = Object.keys(parsedBody);\n\n        if (responseKeys.length) {\n\n            // iterating each key of the order related data json\n            responseKeys.forEach(function (key) {\n\n                if (key === 'variants' || key === 'options') {\n                    \n                    productDetails[productPrefix + key + countPostfix] = parsedBody[key].length;\n\n                } else if (key === 'created_at' || key === 'updated_at' || key === 'published_at') {\n                    // conversion of date to a standard form\n                    productDetails[productPrefix + key] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key]) || '';\n\n                } else if (key === 'images' && parsedBody[key] && parsedBody[key].length){\n\n                    productDetails['product_image_url'] = parsedBody[key][0] && parsedBody[key][0]['src'] || ''\n\n                } else if (key != 'image' && key != 'images' && key != 'template_suffix'){\n                    // extracting all the other non nested keys\n                    productDetails[productPrefix + key] = parsedBody[key] || '';\n                }\n            }, this);\n        } \n\n        // now couple the product and variant data one by one to achieve final new variants array\n        tempNewVariants.forEach(function(variantObj){\n            \n            variant = {};\n            // cloning the productDetails object for each variant \n            variant = (JSON.parse(JSON.stringify(productDetails)));\n\n            Object.keys(variantObj).forEach(function(key){\n                if (key === \"created_at\" || key === \"updated_at\") \n                    variant[variantPrefix + key] = variantObj[key] ? utils.libDate.parseJSDateTimeToStandardString(variantObj[key]) : '';\n                else if ( key != 'product_id')\n                    variant[variantPrefix + key] = variantObj[key] ? variantObj[key] : '';\n            }, this);\n\n            // now add to the return array\n            newVariants.push(variant);\n\n        });\n        \n        retObj['status'] = \"SUCCESS\";\n        retObj['data']   = { \"response\": newVariants };\n\n    }\n    // finally calling the callback function with retObj\n    callback(retObj);\n}"
			},
			"responseFields": [
				{
					"name": "Product ID",
					"id": "product_id",
					"type": "String"
				},
				{
					"name": "Product Title",
					"id": "product_title",
					"type": "String"
				},
				{
					"name": "Product Description",
					"id": "product_body_html",
					"type": "String"
				},
				{
					"name": "Product Vendor",
					"id": "product_vendor",
					"type": "String"
				},
				{
					"name": "Type of Product",
					"id": "product_product_type",
					"type": "String"
				},
				{
					"name": "Product Created At",
					"id": "product_created_at",
					"type": "String"
				},
				{
					"name": "Product Updated At",
					"id": "product_updated_at",
					"type": "String"
				},
				{
					"name": "Product Published At",
					"id": "product_published_at",
					"type": "String"
				},
				{
					"name": "Product Image URL",
					"id": "product_image_url",
					"type": "String"
				},
				{
					"name": "Product Published scope",
					"id": "product_published_scope",
					"description": "Indicates whether the product is published to the Point of Sale channel",
					"type": "String"
				},
				{
					"name": "Number Of Product Variants",
					"id": "product_variants_count",
					"type": "String"
				},
				{
					"name": "Number of Product options",
					"id": "product_options_count",
					"type": "String"
				},
				{
					"name": "Product Handle",
					"id": "product_handle",
					"description": "Unique string for the Product automatically generated from its title",
					"type": "String"
				},
				{
					"name": "Variant ID",
					"id": "variant_id",
					"type": "String"
				},
				{
					"name": "Variant Title",
					"id": "variant_title",
					"type": "String"
				},
				{
					"name": "Variant Price",
					"id": "variant_price",
					"type": "String"
				},
				{
					"name": "Variant SKU",
					"id": "variant_sku",
					"description": "A unique identifier for the product in the shop",
					"type": "String"
				},
				{
					"name": "Variant Position",
					"id": "variant_position",
					"description": "The order of the product variant in the list of product variants",
					"type": "String"
				},
				{
					"name": "Variant Weight (grams)",
					"id": "variant_grams",
					"type": "String"
				},
				{
					"name": "Variant Inventory Policy",
					"id": "variant_inventory_policy",
					"description": "Specifies whether or not customers are allowed to place an order for a product variant when it's out of stock.",
					"type": "String"
				},
				{
					"name": "Variant Compare At Price",
					"id": "variant_compare_at_price",
					"description": "The competitors prices for the same item",
					"type": "String"
				},
				{
					"name": "Variant Fulfillment Service",
					"id": "variant_fulfillment_service",
					"description": "Service which is doing the fulfillment. Possible values are manual or the handle of a FulfillmentService",
					"type": "String"
				},
				{
					"name": "Variant Inventory Management",
					"id": "variant_inventory_management",
					"description": "Specifies whether or not Shopify tracks the number of items in stock for this product variant",
					"type": "String"
				},
				{
					"name": "Variant Option1",
					"id": "variant_option1",
					"description": "Custom property 1, used to define product variants",
					"type": "String"
				},
				{
					"name": "Variant Option2",
					"id": "variant_option2",
					"description": "Custom property 2, used to define product variants",
					"type": "String"
				},
				{
					"name": "Variant Option3",
					"id": "variant_option3",
					"description": "Custom property 3, used to define product variants",
					"type": "String"
				},
				{
					"name": "Variant Created At",
					"id": "variant_created_at",
					"type": "String"
				},
				{
					"name": "Variant Updated At",
					"id": "variant_updated_at",
					"type": "String"
				},
				{
					"name": "Variant Taxable",
					"id": "variant_taxable",
					"type": "String"
				},
				{
					"name": "Variant Barcode",
					"id": "variant_barcode",
					"type": "String"
				},
				{
					"name": "Variant Image ID",
					"id": "variant_image_id",
					"type": "String"
				},
				{
					"name": "Variant Inventory Quantity",
					"id": "variant_inventory_quantity",
					"type": "String"
				},
				{
					"name": "Variant Weight",
					"id": "variant_weight",
					"description": "The weight of the product variant in the unit system specified with weight_unit",
					"type": "String"
				},
				{
					"name": "Variant Weight Unit",
					"id": "variant_weight_unit",
					"description": "The unit system that the product variant's weight is measure in. The weight_unit can be either g, kg, oz, or lb",
					"type": "String"
				},
				{
					"name": "Variant Old Inventory Quantity",
					"id": "variant_old_inventory_quantity",
					"description": "The original stock level the client believes the product variant has. This should be sent to avoid a race condition when the item being adjusted is simultaneously sold online.",
					"type": "String"
				},
				{
					"name": "Variant Requires Shipping",
					"id": "variant_requires_shipping",
					"type": "String"
				}
			],
			"params": []
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "New Fulfilled Order",
			"id": "order-fulfilled",
			"description": "Triggers when an order is fulfilled",
			"priority": 1,
			"entity": "invoice",
			"beta": true,
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'orders/fulfilled',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && response['statusCode'] == 201) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response) {\n      retObj['error']         = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['message']       = \"Invalid/Missing API response\";\n      return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful deletion of webhook\n   if (response['statusCode'] && response['statusCode'] == 200) {\n        // sending the succes return object\n        retObj['status'] = \"SUCCESS\";\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n\n    var BillingAddressPrefix = 'billing_address_';\n    var shippingAddressPrefix = 'shipping_address_';\n    var customerPrefix = 'customer_'\n    var SkipFields = ['gateway', 'test'];\n    var retObj = { status: \"ERROR\" };\n    var customerData = {};\n    var orderData = {};\n    var maxItemScan = 5;\n    var newOrder = {};\n    var newOrderObj = {};\n    var responseKeys;\n    var parsedBody;\n\n    // if body is not present in params\n    if (!params || !params.body || !(utils || {}).libDate) {\n        retObj['message'] = \"Invalid/Missing API body or libDate util\";\n        return callback(retObj);\n    } else {\n        parsedBody = params['body'];\n        // extracting the keys of response data of order\n        responseKeys = Object.keys(parsedBody);\n\n        if (responseKeys.length) {\n\n            // iterating each key of the order related data json\n            responseKeys.forEach(function (key) {\n\n                if (key === 'line_items') {\n\n                    //creating comma separated list of all line item names and ids\n\n                    let accumulated = null\n\n                    accumulated = parsedBody[key].reduce((acc, value) => {\n                        acc.line_item_ids.push(value.id ? value.id : '')\n                        acc.line_item_names.push(value.name ? value.name : '')\n                        acc.line_item_product_codes.push(value.product_id ? value.product_id : '')\n                        acc.line_item_titles.push(value.title ? value.title : '')\n                        acc.line_item_variant_ids.push(value.variant_id ? value.variant_id : '')\n                        acc.line_item_variant_titles.push(value.variant_title ? value.variant_title : '')\n                        acc.line_item_quantities.push(value.quantity ? value.quantity : '')\n                        acc.line_item_prices.push(value.price ? value.price : '')\n                        acc.line_item_skus.push(value.sku ? value.sku : '')\n                        acc.line_item_weights.push(value.grams ? value.grams : '')\n\n                        return acc\n                    }, {\n                            line_item_ids: [],\n                            line_item_names: [],\n                            line_item_product_codes: [],\n                            line_item_titles: [],\n                            line_item_variant_ids: [],\n                            line_item_variant_titles: [],\n                            line_item_quantities: [],\n                            line_item_prices: [],\n                            line_item_skus: [],\n                            line_item_weights: []\n                        }\n                    )\n\n                    Object.keys(accumulated).forEach(prop => {\n                        let fld = prop\n                        let data = accumulated[prop]\n\n                        if (data && data.length) {\n                            newOrder[fld] = data.toString()\n                        }\n                    })\n\n\n                    // var line_item_names = \"\";\n                    // var line_item_product_codes = \"\";\n\n                    // parsedBody[key].forEach(function (item) {\n                    //     line_item_product_codes += item.product_id + \",\";\n                    //     line_item_names += item.name + \",\";\n                    // });\n\n                    // if (line_item_product_codes && line_item_names) {\n                    //     newOrder['line_item_product_codes'] = line_item_product_codes.slice(0, line_item_product_codes.length - 1);\n                    //     newOrder['line_item_names'] = line_item_names.slice(0, line_item_names.length - 1);\n                    // }\n\n                    parsedBody[key].some(function (element, index) {\n                        // deciding the prefix for items\n                        const prefix = ['first', 'second', 'third', 'fourth', 'fifth']\n\n                        Object.keys(element).forEach(function (field) {\n                            if (field != 'properties' && field != 'tax_lines')\n                                newOrder[`${prefix[index]}_item_${field}`] = element[field] || '';\n                        }, this);\n\n                        // returning after maximum scanning of 3 items of orders\n                        return maxItemScan === index + 1;\n                    }, this);\n\n                } else if (key === 'billing_address' || key === 'shipping_address' || key === 'customer') {\n                    // extracting the basic info of customer \n                    if (key === 'customer') {\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n\n                            if (field === 'created_at' || field === 'updated_at')\n                                customerData[customerPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key][field]) || '';\n                            else if (field != 'default_address')\n                                customerData[customerPrefix + field] = parsedBody[key][field] || '';\n\n                        }, this);\n                    } else {\n                        // extracting the billing and shipping address of order\n                        var prefix = (key === 'billing_address') ? BillingAddressPrefix : shippingAddressPrefix;\n\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n                            newOrder[prefix + field] = parsedBody[key][field] || '';\n                        }, this);\n                    }\n\n                } else if (key === 'shipping_lines') {\n                    let shipping_lines = parsedBody[key]\n                    let selectFields = {\n                        title: true,\n                        price: true,\n                        source: true,\n                        phone: true,\n                        carrier_identifier: true\n                    }\n\n                    if (shipping_lines && shipping_lines.length) {\n\n                        Object.keys(shipping_lines[0]).forEach(field => {\n                            let data = shipping_lines[0][field]\n\n                            if (selectFields[field] && data) {\n                                orderData[`shipping_line_${field}`] = data\n                            }\n\n                        })\n                    }\n\n                } else if (key != 'refunds' && key != 'fulfillments' && key != 'tax_lines'\n                    && key != 'discount_codes' && key != 'note_attributes' && key != 'payment_gateway_names') {\n\n                    // standard format of date\n                    if (key === 'created_at' || key === 'updated_at' || key === 'processed_at')\n                        orderData[key] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key]) || '';\n                    else\n                        orderData[key] = parsedBody[key] || '';\n                    // extracting all the other non nested keys\n                }\n            }, this);\n\n            //parsing custom fields\n            const noteAttributes = parsedBody.note_attributes\n\n            if (noteAttributes && Array.isArray(noteAttributes) && noteAttributes.length) {\n                noteAttributes\n                    .forEach(attr => {\n                        if (attr.name && attr.value) {\n                            const key = `additional_details_${utils.libText.encodeKey(attr.name)}`\n                            newOrderObj[key] = attr.value\n                        } \n                    })\n            }\n\n            const lineItems = parsedBody.line_items.slice(0, 5)\n\n            if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n                \n                const indexMapping = ['first', 'second', 'third', 'fourth', 'fifth']\n                lineItems\n                    .forEach((item, index) => {\n                        const properties = item.properties\n                        if (properties && Array.isArray(properties) && properties.length) {\n                            properties.forEach(prop => {\n                                if (prop.name && prop.value) {\n                                    newOrderObj[`${indexMapping[index]}_item_property_${utils.libText.encodeKey(prop.name)}`] = prop.value\n                                }\n                            })\n                        }\n                    })\n            }\n\n            const discountCodes = parsedBody.discount_codes\n\n            if (discountCodes && Array.isArray(discountCodes) && discountCodes.length) {\n                newOrderObj.discount_codes = discountCodes\n                    .map(dc => dc.code)\n                    .toString()\n            }\n            \n            const landingSite = parsedBody.landing_site\n\n            if (landingSite) {\n                let utmParams = {}\n                const splitUrl = landingSite.split('?')\n                if (splitUrl[1]) {\n                    utmParams = splitUrl[1]\n                        .split('&')\n                        .reduce((acc, next) => {\n                            const splitParams = next.split('=')\n                            if (splitParams && splitParams.length === 2) {\n                                acc[splitParams[0]] = splitParams[1]\n                            }\n                            return acc\n                        }, {})\n                }\n                if(Object.keys(utmParams).length) {\n                    Object.keys(utmParams)\n                        .forEach(key => {\n                            newOrderObj[`campaign_${key}`] = utmParams[key]\n                        })\n                }\n            }\n\n            // reordering the JSON data\n            [orderData, customerData, newOrder].forEach(function (jsonObj) {\n                Object.keys(jsonObj).forEach(function (key) {\n                    newOrderObj[key] = jsonObj[key];\n                }, this);\n            }, this);\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { \"response\": newOrderObj };\n\n        } else {\n            retObj['error'] = {};\n            retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n            retObj['message'] = \"Trigger data not as expected from shopify webhook\"\n        }\n    }\n    // finally calling the callback function with retObj\n    callback(retObj);\n}"
			},
			"dynamicResponseFields": true,
			"dynamicResponseFieldsRequest": "function dynamicResponseFieldsRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/orders.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      limit: 20,\n      status: 'any',\n      fields: 'line_items,note_attributes,name'\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"dynamicResponseFieldsParse": "function dynamicResponseFieldsParse(params, utils, callback) {\n  const retObj = {}\n  const capitalize = word => word[0].toUpperCase() + word.slice(1, word.length).toLowerCase()\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n\n    retObj.status = 'SUCCESS'\n    retObj.data = []\n\n    if (body && body.orders && body.orders.length) {\n      const responseObjArray = []\n      const noteAtrrObj = {}\n      const propObj = {}\n\n      body.orders\n        .forEach(order => {\n          //note atrributes\n          const note_attributes = order.note_attributes\n          if (note_attributes && Array.isArray(note_attributes) && note_attributes.length) {\n            note_attributes\n              .forEach(attr => {\n                if (attr.name) {\n                  noteAtrrObj[attr.name] = attr.value || ''\n                }\n              })\n          }\n          //end note attributes\n\n          //line item properties\n          const lineItems = order.line_items\n          if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n            lineItems\n              .forEach(line => {\n                const props = line.properties\n                if (props && Array.isArray(props) && props.length) {\n                  props.forEach(prop => {\n                    if (prop.name) {\n                      propObj[prop.name] = prop.value || ''\n                    }\n                  })\n                }\n              })\n          }\n        })\n\n      Object.keys(noteAtrrObj)\n        .forEach(key => {\n          responseObjArray.push({\n            id: `additional_details_${utils.libText.encodeKey(key)}`,\n            name: `Additional Details ${key}`\n          })\n        })\n\n      if (Object.keys(propObj).length) {\n        ['first', 'second', 'third', 'fourth', 'fifth'].forEach(lineNum => {\n          Object.keys(propObj)\n            .forEach(key => {\n              responseObjArray.push({\n                id: `${lineNum}_item_property_${utils.libText.encodeKey(key)}`,\n                name: `${capitalize(lineNum)} Item Property ${key}`\n              })\n            })\n        })\n      }\n\n      retObj.data = responseObjArray\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"responseFields": [
				{
					"name": "Order ID",
					"id": "id",
					"description": "Shopify id of the order",
					"type": "String"
				},
				{
					"name": "Order Name",
					"id": "name",
					"type": "String"
				},
				{
					"name": "Email Address",
					"id": "email",
					"description": "Email address of customer",
					"type": "String"
				},
				{
					"name": "Closed At",
					"id": "closed_at",
					"description": "The date and time when the order was closed",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Shop Number",
					"id": "number",
					"description": "Unique identifier of the shop",
					"type": "String"
				},
				{
					"name": "Note",
					"id": "note",
					"type": "String"
				},
				{
					"name": "Token",
					"id": "token",
					"description": "Unique identifier for a particular order",
					"type": "String"
				},
				{
					"id": "discount_codes",
					"name": "Discount Codes Applied",
					"description": "comma seperated list of all discount codes applied"
				},
				{
					"name": "Total Price",
					"id": "total_price",
					"description": "The sum of prices of all the items in the order, taxes and discounts included",
					"type": "String"
				},
				{
					"name": "Subtotal Price",
					"id": "subtotal_price",
					"description": "Price of the order before shipping and taxes",
					"type": "String"
				},
				{
					"name": "Total Weight",
					"id": "total_weight",
					"description": "The sum of all the weights of the line items in the order(grams)",
					"type": "String"
				},
				{
					"name": "Tax Included",
					"id": "taxes_included",
					"description": "whether or not taxes are included in the order subtotal",
					"type": "String"
				},
				{
					"name": "Total Tax",
					"id": "total_tax",
					"type": "String"
				},
				{
					"name": "Currency",
					"id": "currency",
					"type": "String"
				},
				{
					"name": "Financial Status",
					"id": "financial_status",
					"type": "String"
				},
				{
					"name": "Confirmation Status",
					"id": "confirmed",
					"type": "String"
				},
				{
					"name": "Total Discounts",
					"id": "total_discounts",
					"type": "String"
				},
				{
					"name": "Total Line Item Price",
					"id": "total_line_items_price",
					"description": "The sum of all the prices of all the items in the order",
					"type": "String"
				},
				{
					"name": "Cart Token",
					"id": "cart_token",
					"description": "Unique token of cart attached to order",
					"type": "String"
				},
				{
					"name": "Buyer Accepts Marketing",
					"id": "buyer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Referring Site",
					"id": "referring_site",
					"description": "The website that the customer clicked on to come to the shop",
					"type": "String"
				},
				{
					"name": "Landing Site",
					"id": "landing_site",
					"description": "The URL for the page where the buyer landed when entering the shop",
					"type": "String"
				},
				{
					"id": "campaign_utm_source",
					"name": "Affiliate Link UTM Source"
				},
				{
					"id": "campaign_utm_medium",
					"name": "Affiliate Link UTM Medium"
				},
				{
					"id": "campaign_utm_campaign",
					"name": "Affiliate Link UTM Campaign Name"
				},
				{
					"id": "campaign_utm_content",
					"name": "Affiliate Link UTM Content"
				},
				{
					"name": "Total Price In USD",
					"id": "total_price_usd",
					"type": "String"
				},
				{
					"name": "User ID",
					"id": "user_id",
					"description": "The unique numerical identifier for the user logged into the terminal at the time the order was processed at POS",
					"type": "String"
				},
				{
					"name": "Location ID",
					"id": "location_id",
					"description": "The unique numeric identifier for the physical location of POS at which the order is created",
					"type": "String"
				},
				{
					"name": "Processing Date And Time",
					"id": "processed_at",
					"type": "String"
				},
				{
					"name": "Browser IP Address",
					"id": "browser_ip",
					"description": "IP address of the browser used by customer at the time of placing pf order",
					"type": "String"
				},
				{
					"name": "Order Number",
					"id": "order_number",
					"description": "Unique order number to be used by shop owners and customers",
					"type": "String"
				},
				{
					"name": "Processing Method",
					"id": "processing_method",
					"description": "Valid methods are: checkout, direct, manual, offsite or express",
					"type": "String"
				},
				{
					"id": "checkout_id",
					"name": "Order Checkout Id"
				},
				{
					"id": "checkout_token",
					"name": "Order Checkout Token"
				},
				{
					"id": "phone",
					"name": "Order Phone"
				},
				{
					"id": "customer_locale",
					"name": "Order Customer Locale"
				},
				{
					"id": "gateway",
					"name": "Order Payment Gateway"
				},
				{
					"name": "Order Fulfillment Status",
					"id": "fulfillment_status",
					"type": "String"
				},
				{
					"name": "Source Name",
					"id": "source_name",
					"description": "Source of the creation of order, example: shopify_draft_order, web etc",
					"type": "String"
				},
				{
					"name": "Tags",
					"id": "tags",
					"type": "String"
				},
				{
					"name": "Contact Email Address",
					"id": "contact_email",
					"type": "String"
				},
				{
					"name": "Order Status URL",
					"id": "order_status_url",
					"description": "The url pointing to the checkout accessible from the web",
					"type": "String"
				},
				{
					"name": "Customer ID",
					"id": "customer_id",
					"type": "String"
				},
				{
					"name": "Customer First Name",
					"id": "customer_first_name",
					"type": "String"
				},
				{
					"name": "Customer Last Name",
					"id": "customer_last_name",
					"type": "String"
				},
				{
					"name": "Customer Email Address",
					"id": "customer_email",
					"type": "String"
				},
				{
					"name": "Customer Phone Number",
					"id": "customer_phone",
					"type": "String"
				},
				{
					"name": "Customer Accepts Marketing",
					"id": "customer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Customer Creation Date And Time",
					"id": "customer_created_at",
					"type": "String"
				},
				{
					"name": "Customer Updation Date And Time",
					"id": "customer_updated_at",
					"type": "String"
				},
				{
					"name": "Customer Order Count",
					"id": "customer_orders_count",
					"type": "String"
				},
				{
					"name": "Customer Account State",
					"id": "customer_state",
					"type": "String"
				},
				{
					"name": "Customer Total Spendings",
					"id": "customer_total_spent",
					"type": "String"
				},
				{
					"name": "Customer Last Order ID",
					"id": "customer_last_order_id",
					"type": "String"
				},
				{
					"name": "Customer Note",
					"id": "customer_note",
					"type": "String"
				},
				{
					"name": "Customer Email Verified",
					"id": "customer_verified_email",
					"type": "String"
				},
				{
					"name": "Customer Tax Exempted",
					"id": "customer_tax_exempt",
					"type": "String"
				},
				{
					"name": "Customer Tags",
					"id": "customer_tags",
					"type": "String"
				},
				{
					"name": "Customer Last Order Name",
					"id": "customer_last_order_name",
					"type": "String"
				},
				{
					"name": "All Line Item Ids",
					"id": "line_item_ids",
					"type": "String",
					"description": "comma seperated list of line ids"
				},
				{
					"name": "All Line Item Product Codes",
					"id": "line_item_product_codes",
					"type": "String",
					"description": "comma seperated list of product codes"
				},
				{
					"name": "All Line Item Product Names",
					"id": "line_item_names",
					"type": "String",
					"description": "comma seperated list of product names"
				},
				{
					"name": "All Line Item Product Titles",
					"id": "line_item_titles",
					"type": "String",
					"description": "comma seperated list of product titles"
				},
				{
					"name": "All Line Item Product Variant Ids",
					"id": "line_item_variant_ids",
					"type": "String",
					"description": "comma seperated list of product variant ids"
				},
				{
					"name": "All Line Item Product Variant Titles",
					"id": "line_item_variant_titles",
					"type": "String",
					"description": "comma seperated list of product variant titles"
				},
				{
					"name": "All Line Item Quantities",
					"id": "line_item_quantities",
					"type": "String",
					"description": "comma seperated list of product quantities"
				},
				{
					"name": "All Line Item Prices",
					"id": "line_item_prices",
					"type": "String",
					"description": "comma seperated list of product unit prices"
				},
				{
					"name": "All Line Item Skus",
					"id": "line_item_skus",
					"type": "String",
					"description": "comma seperated list of product skus"
				},
				{
					"name": "All Line Item Product Weights",
					"id": "line_item_weights",
					"type": "String",
					"description": "comma seperated list of product weights"
				},
				{
					"name": "First Item ID",
					"id": "first_item_id",
					"type": "String"
				},
				{
					"name": "First Item Name",
					"id": "first_item_name",
					"type": "String"
				},
				{
					"name": "First Item Product ID",
					"id": "first_item_product_id",
					"type": "String"
				},
				{
					"name": "First Item Variant ID",
					"id": "first_item_variant_id",
					"type": "String"
				},
				{
					"name": "First Item Variant Title",
					"id": "first_item_variant_title",
					"type": "String"
				},
				{
					"name": "First Item Title",
					"id": "first_item_title",
					"type": "String"
				},
				{
					"name": "First Item Quantity",
					"id": "first_item_quantity",
					"type": "String"
				},
				{
					"name": "First Item Unit Price",
					"id": "first_item_price",
					"type": "String"
				},
				{
					"id": "first_item_sku",
					"name": "First Item SKU"
				},
				{
					"id": "first_item_grams",
					"name": "First Item Weight (grams)"
				},
				{
					"id": "first_item_gift_card",
					"name": "First Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "First Item Vendor",
					"id": "first_item_vendor",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Service",
					"id": "first_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "First Item Requires Shipping",
					"id": "first_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "First Item Taxable",
					"id": "first_item_taxable",
					"type": "String"
				},
				{
					"name": "First Item Exists",
					"id": "first_item_product_exists",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "First Item Total Discount",
					"id": "first_item_total_discount",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item ID",
					"id": "second_item_id",
					"type": "String"
				},
				{
					"name": "Second Item Name",
					"id": "second_item_name",
					"type": "String"
				},
				{
					"name": "Second Item Product ID",
					"id": "second_item_product_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant ID",
					"id": "second_item_variant_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant Title",
					"id": "second_item_variant_title",
					"type": "String"
				},
				{
					"name": "Second Item Title",
					"id": "second_item_title",
					"type": "String"
				},
				{
					"name": "Second Item Quantity",
					"id": "second_item_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Unit Price",
					"id": "second_item_price",
					"type": "String"
				},
				{
					"id": "second_item_sku",
					"name": "Second Item SKU"
				},
				{
					"id": "second_item_grams",
					"name": "Second Item Weight (grams)"
				},
				{
					"id": "second_item_gift_card",
					"name": "Second Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Second Item Vendor",
					"id": "second_item_vendor",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Service",
					"id": "second_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Second Item Requires Shipping",
					"id": "second_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Second Item Taxable",
					"id": "second_item_taxable",
					"type": "String"
				},
				{
					"name": "Second Item Exists",
					"id": "second_item_product_exists",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Total Discount",
					"id": "second_item_total_discount",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item ID",
					"id": "third_item_id",
					"type": "String"
				},
				{
					"name": "Third Item Name",
					"id": "third_item_name",
					"type": "String"
				},
				{
					"name": "Third Item Product ID",
					"id": "third_item_product_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant ID",
					"id": "third_item_variant_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant Title",
					"id": "third_item_variant_title",
					"type": "String"
				},
				{
					"name": "Third Item Title",
					"id": "third_item_title",
					"type": "String"
				},
				{
					"name": "Third Item Quantity",
					"id": "third_item_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Unit Price",
					"id": "third_item_price",
					"type": "String"
				},
				{
					"id": "third_item_sku",
					"name": "Third Item SKU"
				},
				{
					"id": "third_item_grams",
					"name": "Third Item Weight (grams)"
				},
				{
					"id": "third_item_gift_card",
					"name": "Third Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Third Item Vendor",
					"id": "third_item_vendor",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Service",
					"id": "third_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Third Item Requires Shipping",
					"id": "third_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Third Item Taxable",
					"id": "third_item_taxable",
					"type": "String"
				},
				{
					"name": "Third Item Exists",
					"id": "third_item_product_exists",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Total Discount",
					"id": "third_item_total_discount",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "third_item_properties",
					"name": "Third Item Properties"
				},
				{
					"name": "Fourth Item ID",
					"id": "fourth_item_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Name",
					"id": "fourth_item_name",
					"type": "String"
				},
				{
					"name": "Fourth Item Product ID",
					"id": "fourth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant ID",
					"id": "fourth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant Title",
					"id": "fourth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Title",
					"id": "fourth_item_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Quantity",
					"id": "fourth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Unit Price",
					"id": "fourth_item_price",
					"type": "String"
				},
				{
					"id": "fourth_item_sku",
					"name": "Fourth Item SKU"
				},
				{
					"id": "fourth_item_grams",
					"name": "Fourth Item Weight (grams)"
				},
				{
					"id": "fourth_item_gift_card",
					"name": "Fourth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fourth Item Vendor",
					"id": "fourth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Service",
					"id": "fourth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fourth Item Requires Shipping",
					"id": "fourth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fourth Item Taxable",
					"id": "fourth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fourth Item Exists",
					"id": "fourth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Total Discount",
					"id": "fourth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fourth_item_properties",
					"name": "Fourth Item Properties"
				},
				{
					"name": "Fifth Item ID",
					"id": "fifth_item_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Name",
					"id": "fifth_item_name",
					"type": "String"
				},
				{
					"name": "Fifth Item Product ID",
					"id": "fifth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant ID",
					"id": "fifth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant Title",
					"id": "fifth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Title",
					"id": "fifth_item_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Quantity",
					"id": "fifth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Unit Price",
					"id": "fifth_item_price",
					"type": "String"
				},
				{
					"id": "fifth_item_sku",
					"name": "Fifth Item SKU"
				},
				{
					"id": "fifth_item_grams",
					"name": "Fifth Item Weight (grams)"
				},
				{
					"id": "fifth_item_gift_card",
					"name": "Fifth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fifth Item Vendor",
					"id": "fifth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Service",
					"id": "fifth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fifth Item Requires Shipping",
					"id": "fifth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fifth Item Taxable",
					"id": "fifth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fifth Item Exists",
					"id": "fifth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Total Discount",
					"id": "fifth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fifth_item_properties",
					"name": "Fifth Item Properties"
				},
				{
					"name": "Billing address First Name",
					"id": "billing_address_first_name",
					"type": "String"
				},
				{
					"name": "Billing address Last Name",
					"id": "billing_address_last_name",
					"type": "String"
				},
				{
					"name": "Billing Address Name",
					"id": "billing_address_name",
					"type": "String"
				},
				{
					"name": "Billing address Line 1",
					"id": "billing_address_address1",
					"type": "String"
				},
				{
					"name": "Billing address Line 2",
					"id": "billing_address_address2",
					"type": "String"
				},
				{
					"name": "Billing address Phone Number",
					"id": "billing_address_phone",
					"type": "String"
				},
				{
					"name": "Billing address City",
					"id": "billing_address_city",
					"type": "String"
				},
				{
					"name": "Billing address Zip",
					"id": "billing_address_zip",
					"type": "String"
				},
				{
					"name": "Billing address Province",
					"id": "billing_address_province",
					"type": "String"
				},
				{
					"name": "Billing address Country",
					"id": "billing_address_country",
					"type": "String"
				},
				{
					"name": "Billing address Company",
					"id": "billing_address_company",
					"type": "String"
				},
				{
					"name": "Billing address Country Code",
					"id": "billing_address_country_code",
					"type": "String"
				},
				{
					"name": "Billing address Province Code",
					"id": "billing_address_province_code",
					"type": "String"
				},
				{
					"name": "Shipping address First Name",
					"id": "shipping_address_first_name",
					"type": "String"
				},
				{
					"name": "Shipping address Last Name",
					"id": "shipping_address_last_name",
					"type": "String"
				},
				{
					"name": "Shipping Address Name",
					"id": "shipping_address_name",
					"type": "String"
				},
				{
					"name": "Shipping address Line 1",
					"id": "shipping_address_address1",
					"type": "String"
				},
				{
					"name": "Shipping address Line 2",
					"id": "shipping_address_address2",
					"type": "String"
				},
				{
					"name": "Shipping address Phone Number",
					"id": "shipping_address_phone",
					"type": "String"
				},
				{
					"name": "Shipping address City",
					"id": "shipping_address_city",
					"type": "String"
				},
				{
					"name": "Shipping address Zip",
					"id": "shipping_address_zip",
					"type": "String"
				},
				{
					"name": "Shipping address Province",
					"id": "shipping_address_province",
					"type": "String"
				},
				{
					"name": "Shipping address Country",
					"id": "shipping_address_country",
					"type": "String"
				},
				{
					"name": "Shipping address Company",
					"id": "shipping_address_company",
					"type": "String"
				},
				{
					"name": "Shipping address Country Code",
					"id": "shipping_address_country_code",
					"type": "String"
				},
				{
					"name": "Shipping address Province Code",
					"id": "shipping_address_province_code",
					"type": "String"
				},
				{
					"id": "shipping_line_title",
					"name": "Order Shipping Line Title"
				},
				{
					"id": "shipping_line_price",
					"name": "Order Shipping Line Price"
				},
				{
					"id": "shipping_line_source",
					"name": "Order Shipping Line Source"
				},
				{
					"id": "shipping_line_phone",
					"name": "Order Shipping Line Phone"
				},
				{
					"id": "shipping_line_carrier_identifier",
					"name": "Order Shipping Line Carrier Identifier"
				}
			],
			"params": []
		},
		{
			"webhookType": "workflow",
			"dynamicResponseFieldsDependsOn": [],
			"name": "Updated Order",
			"id": "order-updated",
			"description": "Triggers when an existing order is updated or a new one gets created",
			"priority": 1,
			"entity": "invoice",
			"beta": true,
			"source": {
				"type": "webhook",
				"webhookRegisterRequest": "function webhookRegisterRequest(params, utils, callback) {\n\n  var registerUrl   = '/admin/webhooks.json';\n  var retObj        = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n        retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookRegister\";\n        callback(retObj);\n        return;\n  } else {\n      \n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl =  params['userapp']['params'].find(p => p.id === 'shop');\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!params['workflow']['_id'] ) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required worflow id\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'POST',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + registerUrl,\n                json: true,\n                body: {\n                    webhook:{\n                        topic:  'orders/updated',\n                        address: process.env['webhookUrl'] + '/webhook/' + params.workflow._id,\n                        format: 'json'\n                    } \n                }\n            }\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookRegisterParse": "function webhookRegisterParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response || !params.body) {\n    retObj['error']            = {code: \"ERROR_MISSING_PARAM\"};\n    retObj['message']          = \"Invalid/Missing API response.\"\n    return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 201, for successful registration of webhook\n   if (response['statusCode'] && response['statusCode'] == 201) {\n\n        retObj['status'] = \"SUCCESS\";\n        retObj['data'] = { webHook:{status: 'registered', data: parsedBody['webhook']} }; \n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n        retObj.data=  {};\n        retObj.data.webHook        = {};\n        retObj.data.webHook.status = 'Failed';\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookDeleteRequest": "function webhookDeleteRequest(params, utils, callback) {\n\n  var deleteUrl   = '/admin/webhooks/';\n  var retObj      = {status: \"ERROR\"};\n  var shopUrl;\n  var fetchedParams;\n  var parameters;\n  var options;\n  var webhook;\n  \n  // if the must params not available than return with error object straightaway\n  if (!params || !params.userapp || !params.appinfo || !params.workflow) {\n    retObj['error']             = {};\n    retObj['error']['code']     = 'ERROR_MISSING_PARAM'; \n    retObj['message']           = \"Missing the userapp, appinfo or workflow in webhookDeleteRequest\";\n    return callback(retObj);\n\n  } else {\n\n    // fetch the auth params for given userapp\n    fetchedParams = params.userapp.fetchAuthParams(params.appinfo);\n    // fetching the shop url\n    shopUrl = params['userapp']['params'].find(p => p.id === 'shop');\n    // fetching the webhook data\n    webhook = (params['workflow']['trigger'] && params['workflow']['trigger']['webHook']) ? params['workflow']['trigger']['webHook'] : null;\n\n    // if the access token not available than return with error object\n    if (!(fetchedParams || {}).access_token || !shopUrl.value) {\n        // checking for access token\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing access token or shop url in the fetched auth params\"; \n        return callback(retObj);\n\n    } else if (!webhook['data']['status'] && webhook['data']['status'] === 'registered' && webhook['data']['id']) {\n        // checking for must workflow parameters\n        retObj['error']             = {};\n        retObj['error']['code']     = 'ERROR_MISSING_PARAM';\n        retObj['message']           = \"Missing required webhook id to delete\";\n        return callback(retObj);\n\n    } else {\n            // compiling options for creating a new order\n            options = {\n                method: 'DELETE',\n                headers: {\n                    'X-Shopify-Access-Token': fetchedParams['access_token'],\n                    'Content-Type'          : 'application/json',\n                },\n                url: 'https://' + shopUrl.value + deleteUrl + webhook['data']['id'] + '.json',\n                json: true,\n            }\n\n            retObj['status']    = \"SUCCESS\";\n            retObj['data']      = { options: options };\n    }\n  }\n  // final callback\n  callback(retObj);\n}",
				"webhookDeleteParse": "function webhookDeleteParse(params, utils, callback) {\n\n  var retObj   = {status: \"ERROR\"};\n  var response;\n  var parsedBody;\n  var errors;\n  var errorMessage;\n  var body;\n\n  // if response and body are not present in params\n  if (!params || !params.response) {\n      retObj['error']         = {};\n      retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n      retObj['message']       = \"Invalid/Missing API response\";\n      return callback(retObj);\n  } else {\n\n    response    = params['response'];\n    parsedBody  = params['body'];\n\n    // if the response contains status code 200, for successful deletion of webhook\n   if (response['statusCode'] && response['statusCode'] == 200) {\n        // sending the succes return object\n        retObj['status'] = \"SUCCESS\";\n\n    } else {\n        // when error data present, flattening the object\n        errors   =  params['body']['errors']; \n        if(errors){\n            errorMessage = '';\n            if(typeof errors == 'string')\n                errorMessage  = errors;\n            else {\n                Object.keys(errors).forEach(function(key){\n                    errorMessage += key + ': ';\n                    if(errors[key] && errors[key] instanceof Array)\n                        errorMessage += errors[key].join(',');\n                    else if(typeof errors[key] == 'string')\n                        errorMessage += errors[key];\n                    else \n                        errorMessage += errors[key];\n                    errorMessage += ', ';\n                });\n            } \n        } \n        if (response['statusCode'] && response['statusCode'] == '401') {\n            // when oauth errors occurs because of wrong access token\n            retObj['error'] = {\n                code    : 'ERROR_AUTH',\n                message : 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n            };\n\n        } else if (response['statusCode'] && response['statusCode'] == '404') {\n            retObj.status = 'SUCCESS'\n        } else if (response['statusCode'] && response['statusCode'] == '429') {\n            // when rate limit occurs \n            retObj['error'] = {\n                code    : 'ERROR_RATE_LIMIT',\n                message : errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n            };\n\n        } else if (response['statusCode']){\n            // for all the other errors\n            retObj['error'] = {\n                code    : 'ERROR_UNKNOWN',\n                message : errorMessage ? errorMessage : 'Unknown error occurred with status code' + response['statusCode'] \n            };\n        }\n    }\n  }\n  // finally calling the callback function with retObj\n  callback(retObj);\n}",
				"webhookTriggerParse": "function webhookTriggerParse(params, utils, callback) {\n\n    var BillingAddressPrefix = 'billing_address_';\n    var shippingAddressPrefix = 'shipping_address_';\n    var customerPrefix = 'customer_'\n    var SkipFields = ['gateway', 'test'];\n    var retObj = { status: \"ERROR\" };\n    var customerData = {};\n    var orderData = {};\n    var maxItemScan = 5;\n    var newOrder = {};\n    var newOrderObj = {};\n    var responseKeys;\n    var parsedBody;\n\n    // if body is not present in params\n    if (!params || !params.body || !(utils || {}).libDate) {\n        retObj['message'] = \"Invalid/Missing API body or libDate util\";\n        return callback(retObj);\n    } else {\n        parsedBody = params['body'];\n        // extracting the keys of response data of order\n        responseKeys = Object.keys(parsedBody);\n\n        if (responseKeys.length) {\n\n            // iterating each key of the order related data json\n            responseKeys.forEach(function (key) {\n\n                if (key === 'line_items') {\n\n                    //creating comma separated list of all line item names and ids\n\n                    let accumulated = null\n\n                    accumulated = parsedBody[key].reduce((acc, value) => {\n                        acc.line_item_ids.push(value.id ? value.id : '')\n                        acc.line_item_names.push(value.name ? value.name : '')\n                        acc.line_item_product_codes.push(value.product_id ? value.product_id : '')\n                        acc.line_item_titles.push(value.title ? value.title : '')\n                        acc.line_item_variant_ids.push(value.variant_id ? value.variant_id : '')\n                        acc.line_item_variant_titles.push(value.variant_title ? value.variant_title : '')\n                        acc.line_item_quantities.push(value.quantity ? value.quantity : '')\n                        acc.line_item_prices.push(value.price ? value.price : '')\n                        acc.line_item_skus.push(value.sku ? value.sku : '')\n                        acc.line_item_weights.push(value.grams ? value.grams : '')\n\n                        return acc\n                    }, {\n                            line_item_ids: [],\n                            line_item_names: [],\n                            line_item_product_codes: [],\n                            line_item_titles: [],\n                            line_item_variant_ids: [],\n                            line_item_variant_titles: [],\n                            line_item_quantities: [],\n                            line_item_prices: [],\n                            line_item_skus: [],\n                            line_item_weights: []\n                        }\n                    )\n\n                    Object.keys(accumulated).forEach(prop => {\n                        let fld = prop\n                        let data = accumulated[prop]\n\n                        if (data && data.length) {\n                            newOrder[fld] = data.toString()\n                        }\n                    })\n\n\n                    // var line_item_names = \"\";\n                    // var line_item_product_codes = \"\";\n\n                    // parsedBody[key].forEach(function (item) {\n                    //     line_item_product_codes += item.product_id + \",\";\n                    //     line_item_names += item.name + \",\";\n                    // });\n\n                    // if (line_item_product_codes && line_item_names) {\n                    //     newOrder['line_item_product_codes'] = line_item_product_codes.slice(0, line_item_product_codes.length - 1);\n                    //     newOrder['line_item_names'] = line_item_names.slice(0, line_item_names.length - 1);\n                    // }\n\n                    parsedBody[key].some(function (element, index) {\n                        // deciding the prefix for items\n                        const prefix = ['first', 'second', 'third', 'fourth', 'fifth']\n\n                        Object.keys(element).forEach(function (field) {\n                            if (field != 'properties' && field != 'tax_lines')\n                                newOrder[`${prefix[index]}_item_${field}`] = element[field] || '';\n                        }, this);\n\n                        // returning after maximum scanning of 3 items of orders\n                        return maxItemScan === index + 1;\n                    }, this);\n\n                } else if (key === 'billing_address' || key === 'shipping_address' || key === 'customer') {\n                    // extracting the basic info of customer \n                    if (key === 'customer') {\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n\n                            if (field === 'created_at' || field === 'updated_at')\n                                customerData[customerPrefix + field] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key][field]) || '';\n                            else if (field != 'default_address')\n                                customerData[customerPrefix + field] = parsedBody[key][field] || '';\n\n                        }, this);\n                    } else {\n                        // extracting the billing and shipping address of order\n                        var prefix = (key === 'billing_address') ? BillingAddressPrefix : shippingAddressPrefix;\n\n                        Object.keys(parsedBody[key]).forEach(function (field) {\n                            newOrder[prefix + field] = parsedBody[key][field] || '';\n                        }, this);\n                    }\n\n                } else if (key === 'shipping_lines') {\n                    let shipping_lines = parsedBody[key]\n                    let selectFields = {\n                        title: true,\n                        price: true,\n                        source: true,\n                        phone: true,\n                        carrier_identifier: true\n                    }\n\n                    if (shipping_lines && shipping_lines.length) {\n\n                        Object.keys(shipping_lines[0]).forEach(field => {\n                            let data = shipping_lines[0][field]\n\n                            if (selectFields[field] && data) {\n                                orderData[`shipping_line_${field}`] = data\n                            }\n\n                        })\n                    }\n\n                } else if (key != 'refunds' && key != 'fulfillments' && key != 'tax_lines'\n                    && key != 'discount_codes' && key != 'note_attributes' && key != 'payment_gateway_names') {\n\n                    // standard format of date\n                    if (key === 'created_at' || key === 'updated_at' || key === 'processed_at')\n                        orderData[key] = utils.libDate.parseJSDateTimeToStandardString(parsedBody[key]) || '';\n                    else\n                        orderData[key] = parsedBody[key] || '';\n                    // extracting all the other non nested keys\n                }\n            }, this);\n\n            //parsing custom fields\n            const noteAttributes = parsedBody.note_attributes\n\n            if (noteAttributes && Array.isArray(noteAttributes) && noteAttributes.length) {\n                noteAttributes\n                    .forEach(attr => {\n                        if (attr.name && attr.value) {\n                            const key = `additional_details_${utils.libText.encodeKey(attr.name)}`\n                            newOrderObj[key] = attr.value\n                        } \n                    })\n            }\n\n            const lineItems = parsedBody.line_items.slice(0, 5)\n\n            if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n                \n                const indexMapping = ['first', 'second', 'third', 'fourth', 'fifth']\n                lineItems\n                    .forEach((item, index) => {\n                        const properties = item.properties\n                        if (properties && Array.isArray(properties) && properties.length) {\n                            properties.forEach(prop => {\n                                if (prop.name && prop.value) {\n                                    newOrderObj[`${indexMapping[index]}_item_property_${utils.libText.encodeKey(prop.name)}`] = prop.value\n                                }\n                            })\n                        }\n                    })\n            }\n\n            const discountCodes = parsedBody.discount_codes\n\n            if (discountCodes && Array.isArray(discountCodes) && discountCodes.length) {\n                newOrderObj.discount_codes = discountCodes\n                    .map(dc => dc.code)\n                    .toString()\n            }\n\n            const landingSite = parsedBody.landing_site\n\n            if (landingSite) {\n                let utmParams = {}\n                const splitUrl = landingSite.split('?')\n                if (splitUrl[1]) {\n                    utmParams = splitUrl[1]\n                        .split('&')\n                        .reduce((acc, next) => {\n                            const splitParams = next.split('=')\n                            if (splitParams && splitParams.length === 2) {\n                                acc[splitParams[0]] = splitParams[1]\n                            }\n                            return acc\n                        }, {})\n                }\n                if(Object.keys(utmParams).length) {\n                    Object.keys(utmParams)\n                        .forEach(key => {\n                            newOrderObj[`campaign_${key}`] = utmParams[key]\n                        })\n                }\n            }\n\n            // reordering the JSON data\n            [orderData, customerData, newOrder].forEach(function (jsonObj) {\n                Object.keys(jsonObj).forEach(function (key) {\n                    newOrderObj[key] = jsonObj[key];\n                }, this);\n            }, this);\n\n            retObj['status'] = \"SUCCESS\";\n            retObj['data'] = { \"response\": newOrderObj };\n\n        } else {\n            retObj['error'] = {};\n            retObj['error']['code'] = \"ERROR_MISSING_PARAM\";\n            retObj['message'] = \"Trigger data not as expected from shopify webhook\"\n        }\n    }\n    // finally calling the callback function with retObj\n    callback(retObj);\n}"
			},
			"dynamicResponseFields": true,
			"dynamicResponseFieldsRequest": "function dynamicResponseFieldsRequest(params, utils, callback) {\n  const retObj = {}\n\n  if (!params || !params.userapp || !params.appinfo) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'userapp or appinfo is missing from params'\n    }\n    return callback(retObj)\n  }\n\n  const { access_token } = params.userapp.fetchAuthParams(params.appinfo)\n\n  if (!access_token) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      code: 'ERROR_MISSING_PARAM',\n      message: 'auth params are missing'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrlObj = params.userapp.params.find(param => param.id === 'shop')\n\n  if (!shopUrlObj || !shopUrlObj.value) {\n    retObj.status = 'ERROR'\n    retObj.error = {\n      message: 'shop url is missing from userapp'\n    }\n    return callback(retObj)\n  }\n\n  const shopUrl = shopUrlObj.value\n\n  const url = `https://${shopUrl}/admin/orders.json`\n\n  const options = {\n    url,\n    method: 'GET',\n    headers: {\n      'X-Shopify-Access-Token': access_token,\n      'Content-Type': 'application/json',\n    },\n    qs: {\n      limit: 20,\n      status: 'any',\n      fields: 'line_items,note_attributes,name'\n    },\n    json: true\n  }\n\n  retObj.status = 'SUCCESS'\n  retObj.data = { options }\n\n  return callback(retObj)\n}",
			"dynamicResponseFieldsParse": "function dynamicResponseFieldsParse(params, utils, callback) {\n  const retObj = {}\n  const capitalize = word => word[0].toUpperCase() + word.slice(1, word.length).toLowerCase()\n\n  if (!params || !params.response || !params.body) {\n    retObj.status = \"ERROR\"\n    retObj.error = {\n      message: 'response or body is missing from params',\n      code: 'ERROR_MISSING_PARAM'\n    }\n    return callback(retObj)\n  }\n\n  const { response, body } = params\n\n  if (response.statusCode === 200) {\n\n    retObj.status = 'SUCCESS'\n    retObj.data = []\n\n    if (body && body.orders && body.orders.length) {\n      const responseObjArray = []\n      const noteAtrrObj = {}\n      const propObj = {}\n\n      body.orders\n        .forEach(order => {\n          //note atrributes\n          const note_attributes = order.note_attributes\n          if (note_attributes && Array.isArray(note_attributes) && note_attributes.length) {\n            note_attributes\n              .forEach(attr => {\n                if (attr.name) {\n                  noteAtrrObj[attr.name] = attr.value || ''\n                }\n              })\n          }\n          //end note attributes\n\n          //line item properties\n          const lineItems = order.line_items\n          if (lineItems && Array.isArray(lineItems) && lineItems.length) {\n            lineItems\n              .forEach(line => {\n                const props = line.properties\n                if (props && Array.isArray(props) && props.length) {\n                  props.forEach(prop => {\n                    if (prop.name) {\n                      propObj[prop.name] = prop.value || ''\n                    }\n                  })\n                }\n              })\n          }\n        })\n\n      Object.keys(noteAtrrObj)\n        .forEach(key => {\n          responseObjArray.push({\n            id: `additional_details_${utils.libText.encodeKey(key)}`,\n            name: `Additional Details ${key}`\n          })\n        })\n\n      if (Object.keys(propObj).length) {\n        ['first', 'second', 'third', 'fourth', 'fifth'].forEach(lineNum => {\n          Object.keys(propObj)\n            .forEach(key => {\n              responseObjArray.push({\n                id: `${lineNum}_item_property_${utils.libText.encodeKey(key)}`,\n                name: `${capitalize(lineNum)} Item Property ${key}`\n              })\n            })\n        })\n      }\n\n      retObj.data = responseObjArray\n    }\n  } else {\n    retObj.status = \"ERROR\"\n    const errors = body.errors || '';\n    let errorMessage = '';\n\n    //genrateErrorMessage\n    if (errors) {\n      if (typeof errors == 'string')\n        errorMessage = errors;\n      else {\n        Object.keys(errors).forEach(function (key) {\n          errorMessage += key + ': ';\n          if (errors[key] && errors[key] instanceof Array)\n            errorMessage += errors[key].join(',');\n          else if (typeof errors[key] == 'string')\n            errorMessage += errors[key];\n          else\n            errorMessage += errors[key];\n          errorMessage += ', ';\n        });\n      }\n    }\n\n    if (response.statusCode === 401) {\n      retObj.error = {\n        code: 'ERROR_AUTH',\n        message: 'Unauthorized. Did you uninstall Automate.io in your Shopify account?'\n      }\n      retObj.errorCode = 'ERROR_AUTH'\n    } else if (response.statusCode === 429) {\n      retObj.error = {\n        code: 'ERROR_RATE_LIMIT',\n        message: errorMessage ? errorMessage : 'Too many requests, request rate limit exceeded'\n      }\n      retObj.errorCode = 'ERROR_RATE_LIMIT'\n    } else {\n      retObj.error = {\n        code: 'ERROR_UNKNOWN',\n        message: errorMessage ? errorMessage : `Error occured with status code ${response.statusCode || ''}`\n      }\n    }\n  }\n  return callback(retObj)\n}",
			"responseFields": [
				{
					"name": "Order ID",
					"id": "id",
					"description": "Shopify id of the order",
					"type": "String"
				},
				{
					"name": "Order Name",
					"id": "name",
					"type": "String"
				},
				{
					"name": "Email Address",
					"id": "email",
					"description": "Email address of customer",
					"type": "String"
				},
				{
					"name": "Closed At",
					"id": "closed_at",
					"description": "The date and time when the order was closed",
					"type": "String"
				},
				{
					"name": "Created At",
					"id": "created_at",
					"type": "String"
				},
				{
					"name": "Updated At",
					"id": "updated_at",
					"type": "String"
				},
				{
					"name": "Shop Number",
					"id": "number",
					"description": "Unique identifier of the shop",
					"type": "String"
				},
				{
					"name": "Note",
					"id": "note",
					"type": "String"
				},
				{
					"name": "Token",
					"id": "token",
					"description": "Unique identifier for a particular order",
					"type": "String"
				},
				{
					"id": "discount_codes",
					"name": "Discount Codes Applied",
					"description": "comma seperated list of all discount codes applied"
				},
				{
					"name": "Total Price",
					"id": "total_price",
					"description": "The sum of prices of all the items in the order, taxes and discounts included",
					"type": "String"
				},
				{
					"name": "Subtotal Price",
					"id": "subtotal_price",
					"description": "Price of the order before shipping and taxes",
					"type": "String"
				},
				{
					"name": "Total Weight",
					"id": "total_weight",
					"description": "The sum of all the weights of the line items in the order(grams)",
					"type": "String"
				},
				{
					"name": "Tax Included",
					"id": "taxes_included",
					"description": "whether or not taxes are included in the order subtotal",
					"type": "String"
				},
				{
					"name": "Total Tax",
					"id": "total_tax",
					"type": "String"
				},
				{
					"name": "Currency",
					"id": "currency",
					"type": "String"
				},
				{
					"name": "Financial Status",
					"id": "financial_status",
					"type": "String"
				},
				{
					"name": "Confirmation Status",
					"id": "confirmed",
					"type": "String"
				},
				{
					"name": "Total Discounts",
					"id": "total_discounts",
					"type": "String"
				},
				{
					"name": "Total Line Item Price",
					"id": "total_line_items_price",
					"description": "The sum of all the prices of all the items in the order",
					"type": "String"
				},
				{
					"name": "Cart Token",
					"id": "cart_token",
					"description": "Unique token of cart attached to order",
					"type": "String"
				},
				{
					"name": "Buyer Accepts Marketing",
					"id": "buyer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Referring Site",
					"id": "referring_site",
					"description": "The website that the customer clicked on to come to the shop",
					"type": "String"
				},
				{
					"name": "Landing Site",
					"id": "landing_site",
					"description": "The URL for the page where the buyer landed when entering the shop",
					"type": "String"
				},
				{
					"id": "campaign_utm_source",
					"name": "Affiliate Link UTM Source"
				},
				{
					"id": "campaign_utm_medium",
					"name": "Affiliate Link UTM Medium"
				},
				{
					"id": "campaign_utm_campaign",
					"name": "Affiliate Link UTM Campaign Name"
				},
				{
					"id": "campaign_utm_content",
					"name": "Affiliate Link UTM Content"
				},
				{
					"name": "Total Price In USD",
					"id": "total_price_usd",
					"type": "String"
				},
				{
					"name": "User ID",
					"id": "user_id",
					"description": "The unique numerical identifier for the user logged into the terminal at the time the order was processed at POS",
					"type": "String"
				},
				{
					"name": "Location ID",
					"id": "location_id",
					"description": "The unique numeric identifier for the physical location of POS at which the order is created",
					"type": "String"
				},
				{
					"name": "Processing Date And Time",
					"id": "processed_at",
					"type": "String"
				},
				{
					"name": "Browser IP Address",
					"id": "browser_ip",
					"description": "IP address of the browser used by customer at the time of placing pf order",
					"type": "String"
				},
				{
					"name": "Order Number",
					"id": "order_number",
					"description": "Unique order number to be used by shop owners and customers",
					"type": "String"
				},
				{
					"name": "Processing Method",
					"id": "processing_method",
					"description": "Valid methods are: checkout, direct, manual, offsite or express",
					"type": "String"
				},
				{
					"id": "checkout_id",
					"name": "Order Checkout Id"
				},
				{
					"id": "checkout_token",
					"name": "Order Checkout Token"
				},
				{
					"id": "phone",
					"name": "Order Phone"
				},
				{
					"id": "customer_locale",
					"name": "Order Customer Locale"
				},
				{
					"id": "gateway",
					"name": "Order Payment Gateway"
				},
				{
					"name": "Order Fulfillment Status",
					"id": "fulfillment_status",
					"type": "String"
				},
				{
					"name": "Source Name",
					"id": "source_name",
					"description": "Source of the creation of order, example: shopify_draft_order, web etc",
					"type": "String"
				},
				{
					"name": "Tags",
					"id": "tags",
					"type": "String"
				},
				{
					"name": "Contact Email Address",
					"id": "contact_email",
					"type": "String"
				},
				{
					"name": "Order Status URL",
					"id": "order_status_url",
					"description": "The url pointing to the checkout accessible from the web",
					"type": "String"
				},
				{
					"name": "Customer ID",
					"id": "customer_id",
					"type": "String"
				},
				{
					"name": "Customer First Name",
					"id": "customer_first_name",
					"type": "String"
				},
				{
					"name": "Customer Last Name",
					"id": "customer_last_name",
					"type": "String"
				},
				{
					"name": "Customer Email Address",
					"id": "customer_email",
					"type": "String"
				},
				{
					"name": "Customer Phone Number",
					"id": "customer_phone",
					"type": "String"
				},
				{
					"name": "Customer Accepts Marketing",
					"id": "customer_accepts_marketing",
					"type": "String"
				},
				{
					"name": "Customer Creation Date And Time",
					"id": "customer_created_at",
					"type": "String"
				},
				{
					"name": "Customer Updation Date And Time",
					"id": "customer_updated_at",
					"type": "String"
				},
				{
					"name": "Customer Order Count",
					"id": "customer_orders_count",
					"type": "String"
				},
				{
					"name": "Customer Account State",
					"id": "customer_state",
					"type": "String"
				},
				{
					"name": "Customer Total Spendings",
					"id": "customer_total_spent",
					"type": "String"
				},
				{
					"name": "Customer Last Order ID",
					"id": "customer_last_order_id",
					"type": "String"
				},
				{
					"name": "Customer Note",
					"id": "customer_note",
					"type": "String"
				},
				{
					"name": "Customer Email Verified",
					"id": "customer_verified_email",
					"type": "String"
				},
				{
					"name": "Customer Tax Exempted",
					"id": "customer_tax_exempt",
					"type": "String"
				},
				{
					"name": "Customer Tags",
					"id": "customer_tags",
					"type": "String"
				},
				{
					"name": "Customer Last Order Name",
					"id": "customer_last_order_name",
					"type": "String"
				},
				{
					"name": "All Line Item Ids",
					"id": "line_item_ids",
					"type": "String",
					"description": "comma seperated list of line ids"
				},
				{
					"name": "All Line Item Product Codes",
					"id": "line_item_product_codes",
					"type": "String",
					"description": "comma seperated list of product codes"
				},
				{
					"name": "All Line Item Product Names",
					"id": "line_item_names",
					"type": "String",
					"description": "comma seperated list of product names"
				},
				{
					"name": "All Line Item Product Titles",
					"id": "line_item_titles",
					"type": "String",
					"description": "comma seperated list of product titles"
				},
				{
					"name": "All Line Item Product Variant Ids",
					"id": "line_item_variant_ids",
					"type": "String",
					"description": "comma seperated list of product variant ids"
				},
				{
					"name": "All Line Item Product Variant Titles",
					"id": "line_item_variant_titles",
					"type": "String",
					"description": "comma seperated list of product variant titles"
				},
				{
					"name": "All Line Item Quantities",
					"id": "line_item_quantities",
					"type": "String",
					"description": "comma seperated list of product quantities"
				},
				{
					"name": "All Line Item Prices",
					"id": "line_item_prices",
					"type": "String",
					"description": "comma seperated list of product unit prices"
				},
				{
					"name": "All Line Item Skus",
					"id": "line_item_skus",
					"type": "String",
					"description": "comma seperated list of product skus"
				},
				{
					"name": "All Line Item Product Weights",
					"id": "line_item_weights",
					"type": "String",
					"description": "comma seperated list of product weights"
				},
				{
					"name": "First Item ID",
					"id": "first_item_id",
					"type": "String"
				},
				{
					"name": "First Item Name",
					"id": "first_item_name",
					"type": "String"
				},
				{
					"name": "First Item Product ID",
					"id": "first_item_product_id",
					"type": "String"
				},
				{
					"name": "First Item Variant ID",
					"id": "first_item_variant_id",
					"type": "String"
				},
				{
					"name": "First Item Variant Title",
					"id": "first_item_variant_title",
					"type": "String"
				},
				{
					"name": "First Item Title",
					"id": "first_item_title",
					"type": "String"
				},
				{
					"name": "First Item Quantity",
					"id": "first_item_quantity",
					"type": "String"
				},
				{
					"name": "First Item Unit Price",
					"id": "first_item_price",
					"type": "String"
				},
				{
					"id": "first_item_sku",
					"name": "First Item SKU"
				},
				{
					"id": "first_item_grams",
					"name": "First Item Weight (grams)"
				},
				{
					"id": "first_item_gift_card",
					"name": "First Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "First Item Vendor",
					"id": "first_item_vendor",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Service",
					"id": "first_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "First Item Requires Shipping",
					"id": "first_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "First Item Taxable",
					"id": "first_item_taxable",
					"type": "String"
				},
				{
					"name": "First Item Exists",
					"id": "first_item_product_exists",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "First Item Total Discount",
					"id": "first_item_total_discount",
					"type": "String"
				},
				{
					"name": "First Item Fulfillment Quantity",
					"id": "first_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item ID",
					"id": "second_item_id",
					"type": "String"
				},
				{
					"name": "Second Item Name",
					"id": "second_item_name",
					"type": "String"
				},
				{
					"name": "Second Item Product ID",
					"id": "second_item_product_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant ID",
					"id": "second_item_variant_id",
					"type": "String"
				},
				{
					"name": "Second Item Variant Title",
					"id": "second_item_variant_title",
					"type": "String"
				},
				{
					"name": "Second Item Title",
					"id": "second_item_title",
					"type": "String"
				},
				{
					"name": "Second Item Quantity",
					"id": "second_item_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Unit Price",
					"id": "second_item_price",
					"type": "String"
				},
				{
					"id": "second_item_sku",
					"name": "Second Item SKU"
				},
				{
					"id": "second_item_grams",
					"name": "Second Item Weight (grams)"
				},
				{
					"id": "second_item_gift_card",
					"name": "Second Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Second Item Vendor",
					"id": "second_item_vendor",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Service",
					"id": "second_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Second Item Requires Shipping",
					"id": "second_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Second Item Taxable",
					"id": "second_item_taxable",
					"type": "String"
				},
				{
					"name": "Second Item Exists",
					"id": "second_item_product_exists",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Second Item Total Discount",
					"id": "second_item_total_discount",
					"type": "String"
				},
				{
					"name": "Second Item Fulfillment Quantity",
					"id": "second_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item ID",
					"id": "third_item_id",
					"type": "String"
				},
				{
					"name": "Third Item Name",
					"id": "third_item_name",
					"type": "String"
				},
				{
					"name": "Third Item Product ID",
					"id": "third_item_product_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant ID",
					"id": "third_item_variant_id",
					"type": "String"
				},
				{
					"name": "Third Item Variant Title",
					"id": "third_item_variant_title",
					"type": "String"
				},
				{
					"name": "Third Item Title",
					"id": "third_item_title",
					"type": "String"
				},
				{
					"name": "Third Item Quantity",
					"id": "third_item_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Unit Price",
					"id": "third_item_price",
					"type": "String"
				},
				{
					"id": "third_item_sku",
					"name": "Third Item SKU"
				},
				{
					"id": "third_item_grams",
					"name": "Third Item Weight (grams)"
				},
				{
					"id": "third_item_gift_card",
					"name": "Third Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Third Item Vendor",
					"id": "third_item_vendor",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Service",
					"id": "third_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Third Item Requires Shipping",
					"id": "third_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Third Item Taxable",
					"id": "third_item_taxable",
					"type": "String"
				},
				{
					"name": "Third Item Exists",
					"id": "third_item_product_exists",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Third Item Total Discount",
					"id": "third_item_total_discount",
					"type": "String"
				},
				{
					"name": "Third Item Fulfillment Quantity",
					"id": "third_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "third_item_properties",
					"name": "Third Item Properties"
				},
				{
					"name": "Fourth Item ID",
					"id": "fourth_item_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Name",
					"id": "fourth_item_name",
					"type": "String"
				},
				{
					"name": "Fourth Item Product ID",
					"id": "fourth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant ID",
					"id": "fourth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fourth Item Variant Title",
					"id": "fourth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Title",
					"id": "fourth_item_title",
					"type": "String"
				},
				{
					"name": "Fourth Item Quantity",
					"id": "fourth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Unit Price",
					"id": "fourth_item_price",
					"type": "String"
				},
				{
					"id": "fourth_item_sku",
					"name": "Fourth Item SKU"
				},
				{
					"id": "fourth_item_grams",
					"name": "Fourth Item Weight (grams)"
				},
				{
					"id": "fourth_item_gift_card",
					"name": "Fourth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fourth Item Vendor",
					"id": "fourth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Service",
					"id": "fourth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fourth Item Requires Shipping",
					"id": "fourth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fourth Item Taxable",
					"id": "fourth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fourth Item Exists",
					"id": "fourth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fourth Item Total Discount",
					"id": "fourth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fourth Item Fulfillment Quantity",
					"id": "fourth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fourth_item_properties",
					"name": "Fourth Item Properties"
				},
				{
					"name": "Fifth Item ID",
					"id": "fifth_item_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Name",
					"id": "fifth_item_name",
					"type": "String"
				},
				{
					"name": "Fifth Item Product ID",
					"id": "fifth_item_product_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant ID",
					"id": "fifth_item_variant_id",
					"type": "String"
				},
				{
					"name": "Fifth Item Variant Title",
					"id": "fifth_item_variant_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Title",
					"id": "fifth_item_title",
					"type": "String"
				},
				{
					"name": "Fifth Item Quantity",
					"id": "fifth_item_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Unit Price",
					"id": "fifth_item_price",
					"type": "String"
				},
				{
					"id": "fifth_item_sku",
					"name": "Fifth Item SKU"
				},
				{
					"id": "fifth_item_grams",
					"name": "Fifth Item Weight (grams)"
				},
				{
					"id": "fifth_item_gift_card",
					"name": "Fifth Line Item Gift Card Applied?",
					"description": "has value true or false"
				},
				{
					"name": "Fifth Item Vendor",
					"id": "fifth_item_vendor",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Service",
					"id": "fifth_item_fulfillment_service",
					"description": "Service provider who is doing the fulfillment",
					"type": "String"
				},
				{
					"name": "Fifth Item Requires Shipping",
					"id": "fifth_item_requires_shipping",
					"type": "String"
				},
				{
					"name": "Fifth Item Taxable",
					"id": "fifth_item_taxable",
					"type": "String"
				},
				{
					"name": "Fifth Item Exists",
					"id": "fifth_item_product_exists",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"name": "Fifth Item Total Discount",
					"id": "fifth_item_total_discount",
					"type": "String"
				},
				{
					"name": "Fifth Item Fulfillment Quantity",
					"id": "fifth_item_fulfillable_quantity",
					"type": "String"
				},
				{
					"id": "fifth_item_properties",
					"name": "Fifth Item Properties"
				},
				{
					"name": "Billing address First Name",
					"id": "billing_address_first_name",
					"type": "String"
				},
				{
					"name": "Billing address Last Name",
					"id": "billing_address_last_name",
					"type": "String"
				},
				{
					"name": "Billing Address Name",
					"id": "billing_address_name",
					"type": "String"
				},
				{
					"name": "Billing address Line 1",
					"id": "billing_address_address1",
					"type": "String"
				},
				{
					"name": "Billing address Line 2",
					"id": "billing_address_address2",
					"type": "String"
				},
				{
					"name": "Billing address Phone Number",
					"id": "billing_address_phone",
					"type": "String"
				},
				{
					"name": "Billing address City",
					"id": "billing_address_city",
					"type": "String"
				},
				{
					"name": "Billing address Zip",
					"id": "billing_address_zip",
					"type": "String"
				},
				{
					"name": "Billing address Province",
					"id": "billing_address_province",
					"type": "String"
				},
				{
					"name": "Billing address Country",
					"id": "billing_address_country",
					"type": "String"
				},
				{
					"name": "Billing address Company",
					"id": "billing_address_company",
					"type": "String"
				},
				{
					"name": "Billing address Country Code",
					"id": "billing_address_country_code",
					"type": "String"
				},
				{
					"name": "Billing address Province Code",
					"id": "billing_address_province_code",
					"type": "String"
				},
				{
					"name": "Shipping address First Name",
					"id": "shipping_address_first_name",
					"type": "String"
				},
				{
					"name": "Shipping address Last Name",
					"id": "shipping_address_last_name",
					"type": "String"
				},
				{
					"name": "Shipping Address Name",
					"id": "shipping_address_name",
					"type": "String"
				},
				{
					"name": "Shipping address Line 1",
					"id": "shipping_address_address1",
					"type": "String"
				},
				{
					"name": "Shipping address Line 2",
					"id": "shipping_address_address2",
					"type": "String"
				},
				{
					"name": "Shipping address Phone Number",
					"id": "shipping_address_phone",
					"type": "String"
				},
				{
					"name": "Shipping address City",
					"id": "shipping_address_city",
					"type": "String"
				},
				{
					"name": "Shipping address Zip",
					"id": "shipping_address_zip",
					"type": "String"
				},
				{
					"name": "Shipping address Province",
					"id": "shipping_address_province",
					"type": "String"
				},
				{
					"name": "Shipping address Country",
					"id": "shipping_address_country",
					"type": "String"
				},
				{
					"name": "Shipping address Company",
					"id": "shipping_address_company",
					"type": "String"
				},
				{
					"name": "Shipping address Country Code",
					"id": "shipping_address_country_code",
					"type": "String"
				},
				{
					"name": "Shipping address Province Code",
					"id": "shipping_address_province_code",
					"type": "String"
				},
				{
					"id": "shipping_line_title",
					"name": "Order Shipping Line Title"
				},
				{
					"id": "shipping_line_price",
					"name": "Order Shipping Line Price"
				},
				{
					"id": "shipping_line_source",
					"name": "Order Shipping Line Source"
				},
				{
					"id": "shipping_line_phone",
					"name": "Order Shipping Line Phone"
				},
				{
					"id": "shipping_line_carrier_identifier",
					"name": "Order Shipping Line Carrier Identifier"
				}
			],
			"params": []
		}
	],
	"version": "1.0"
}
